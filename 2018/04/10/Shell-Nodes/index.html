<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Shell笔记 | 木子人人人&#39;s 藏经阁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="想把Linux玩溜，怎可缺少Shell这个技能点呢。把它归在计算机语言里吧，毕竟也是种脚本语言（虽然它也被看做是一个应用程序）">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell笔记">
<meta property="og:url" content="http://avalonlz.github.io/2018/04/10/Shell-Nodes/index.html">
<meta property="og:site_name" content="木子人人人's 藏经阁">
<meta property="og:description" content="想把Linux玩溜，怎可缺少Shell这个技能点呢。把它归在计算机语言里吧，毕竟也是种脚本语言（虽然它也被看做是一个应用程序）">
<meta property="og:image" content="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_strlen.jpg">
<meta property="og:image" content="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_arraylen1.jpg">
<meta property="og:image" content="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_fromshell1.jpg">
<meta property="og:image" content="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_sum.jpg">
<meta property="og:updated_time" content="2020-12-13T13:59:16.502Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shell笔记">
<meta name="twitter:description" content="想把Linux玩溜，怎可缺少Shell这个技能点呢。把它归在计算机语言里吧，毕竟也是种脚本语言（虽然它也被看做是一个应用程序）">
<meta name="twitter:image" content="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_strlen.jpg">
  
    <link rel="alternative" href="/atom.xml" title="木子人人人&#39;s 藏经阁" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/profile_imageQQ%E6%88%AA%E5%9B%BE20160327215851.png" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">木子人人人</a></h1>
		</hgroup>

		
		<p class="header-subtitle">积跬步 至千里</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/avalonLZ" title="github">github</a>
					        
								<a class="mail" target="_blank" href="https://mail.qq.com/" title="mail">mail</a>
					        
								<a class="facebook" target="_blank" href="https://www.facebook.com/ren.li.16100" title="facebook">facebook</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/DPDK/" style="font-size: 10px;">DPDK</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Linux多线程编程/" style="font-size: 12px;">Linux多线程编程</a> <a href="/tags/Linux多进程编程/" style="font-size: 10px;">Linux多进程编程</a> <a href="/tags/Linux网络编程/" style="font-size: 20px;">Linux网络编程</a> <a href="/tags/RTOS-UCOSII/" style="font-size: 12px;">RTOS_UCOSII</a> <a href="/tags/Raspberry-Pi/" style="font-size: 12px;">Raspberry Pi</a> <a href="/tags/云计算/" style="font-size: 14px;">云计算</a> <a href="/tags/协议解析-MQTT/" style="font-size: 10px;">协议解析_MQTT</a> <a href="/tags/协议解析-定位/" style="font-size: 10px;">协议解析_定位</a> <a href="/tags/嵌入式-Linux/" style="font-size: 12px;">嵌入式_Linux</a> <a href="/tags/嵌入式-MTK/" style="font-size: 10px;">嵌入式_MTK</a> <a href="/tags/嵌入式-STM32/" style="font-size: 18px;">嵌入式_STM32</a> <a href="/tags/应用软件-PyQt/" style="font-size: 16px;">应用软件_PyQt</a> <a href="/tags/应用软件-Qt/" style="font-size: 10px;">应用软件_Qt</a> <a href="/tags/应用软件-Supervisor/" style="font-size: 10px;">应用软件_Supervisor</a> <a href="/tags/服务器-Django/" style="font-size: 12px;">服务器_Django</a> <a href="/tags/服务器-MySQL/" style="font-size: 10px;">服务器_MySQL</a> <a href="/tags/服务器-Tinyhttpd/" style="font-size: 10px;">服务器_Tinyhttpd</a> <a href="/tags/游戏编程/" style="font-size: 10px;">游戏编程</a> <a href="/tags/百科-DNSpod/" style="font-size: 10px;">百科_DNSpod</a> <a href="/tags/百科-Git/" style="font-size: 10px;">百科_Git</a> <a href="/tags/百科-Linux/" style="font-size: 16px;">百科_Linux</a> <a href="/tags/百科-双系统安装/" style="font-size: 10px;">百科_双系统安装</a> <a href="/tags/百科-存储/" style="font-size: 10px;">百科_存储</a> <a href="/tags/百科-网络/" style="font-size: 12px;">百科_网络</a> <a href="/tags/算法-Sort/" style="font-size: 10px;">算法_Sort</a> <a href="/tags/计算机语言-C/" style="font-size: 10px;">计算机语言_C</a> <a href="/tags/计算机语言-C/" style="font-size: 10px;">计算机语言_C++</a> <a href="/tags/计算机语言-Lua/" style="font-size: 10px;">计算机语言_Lua</a> <a href="/tags/计算机语言-Python/" style="font-size: 10px;">计算机语言_Python</a> <a href="/tags/计算机语言-Shell/" style="font-size: 10px;">计算机语言_Shell</a> <a href="/tags/轮子-C/" style="font-size: 10px;">轮子_C</a> <a href="/tags/软件工程-DesignPatterns/" style="font-size: 10px;">软件工程_DesignPatterns</a> <a href="/tags/软件工程-FrameWork/" style="font-size: 10px;">软件工程_FrameWork</a> <a href="/tags/软件工程-UML/" style="font-size: 10px;">软件工程_UML</a> <a href="/tags/飞思卡尔/" style="font-size: 10px;">飞思卡尔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">文章若有出入，还望大家指出，交流</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">木子人人人</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/profile_imageQQ%E6%88%AA%E5%9B%BE20160327215851.png" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">木子人人人</h1>
			</hgroup>
			
			<p class="header-subtitle">积跬步 至千里</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/avalonLZ" title="github">github</a>
			        
						<a class="mail" target="_blank" href="https://mail.qq.com/" title="mail">mail</a>
			        
						<a class="facebook" target="_blank" href="https://www.facebook.com/ren.li.16100" title="facebook">facebook</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Shell-Nodes" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/04/10/Shell-Nodes/" class="article-date">
  	<time datetime="2018-04-10T04:58:47.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Shell笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机语言-Shell/">计算机语言_Shell</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
		
		<!--
		<p><font size="1px"><span id="busuanzi_container_page_pv">This article has been read <span id="busuanzi_value_page_pv"></span> times</span></font></p>
		//-->
      
	  </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想把Linux玩溜，怎可缺少Shell这个技能点呢。把它归在计算机语言里吧，毕竟也是种脚本语言（虽然它也被看做是一个应用程序）<a id="more"></a>  </p>
<h3 id="需注意点"><a href="#需注意点" class="headerlink" title="需注意点"></a>需注意点</h3><p>1、在Shell中数字0和1并不代表真假<br>2、在Linux命令中-o这类表示选项，选项后紧跟着选项的参数。并且，不带选项的参数可以写在一起  </p>
<h3 id="脚本调试方法"><a href="#脚本调试方法" class="headerlink" title="脚本调试方法"></a>脚本调试方法</h3><p>sh/bash -x [脚本名称]  </p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>read variable：<br>等待用户输入，并将输入存放于variable中，回车为输入结束  </p>
<p>seq 结束值：<br>执行该语句，将以默认步长，从1开始递增到结束值  </p>
<p>grep：  </p>
<ul>
<li>-v反向过滤，表示过滤除xxx以外的内容    </li>
<li>-q过滤后非空的话则返回0，否则返回1  </li>
<li>-o部分匹配，并截取，输出，匹配-o之后的内容，但只要包含了这些内容就会被匹配，最后再截取这部分内容，输出到终端页面    </li>
<li>-i表示不区分大小写匹配</li>
<li>-E表示或匹配，grep -E “error|drop”，匹配含有error或drop字符串的行，并输出  </li>
<li>“\&lt;>“完全匹配，grep “\<xxx\>“，表示需要匹配到xxx，xxx前后可以是空格或者特殊字符  </xxx\></li>
<li>正则表达式（<a href="https://man.linuxde.net/docs/shell_regex.html）：grep" target="_blank" rel="external">https://man.linuxde.net/docs/shell_regex.html）：grep</a> “^eth[0-9]+$”，表示匹配eth开头并且以数字结尾的字符串。注意，如果加了-E参数，则grep表示使用扩展正则表达式(之前的匹配语句，将等价于^eth[0-9]+$)，  </li>
</ul>
<p>awk:     </p>
<ul>
<li>-F以某字符或符号进行分割，常见用法awk -F “2” ‘{print $1}’，表示用字符2进行分割，并输出第一部分  </li>
</ul>
<p>cut：  </p>
<ul>
<li>-d “x” -f 1表示以字符x作为分隔符，并输出第一部分</li>
</ul>
<h3 id="解释器："><a href="#解释器：" class="headerlink" title="解释器："></a>解释器：</h3><p>.sh文件开头一般都会有下面这句  </p>
<pre><code>#! /bin/bash：    
</code></pre><p>目的是为了告诉系统，该脚本是使用了bash这一个解释器（还存在多种解释器，但一般bash最常用）  </p>
<h3 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h3><p>单行注释：在行开头使用’#’字符，进行单行注释<br>多行注释（块注释）：     </p>
<pre><code>:&lt;&lt;BLOCK    
被注释的内容...  
BLOCK  
</code></pre><h3 id="echo命令："><a href="#echo命令：" class="headerlink" title="echo命令："></a>echo命令：</h3><p>用于向窗口输出文本<br>    <code>echo &quot;lz&quot;</code><br>若文本中需要使用转义字符，echo需要加-e参数<br>    <code>echo -e &quot;lz\nlz&quot;</code></p>
<h3 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h3><ul>
<li>变量前不加‘$’字符  </li>
<li><p>定义一个变量的时候就应该赋初值，且变量与等号之前不可以有空格  </p>
<p>  <code>my_age=24</code>  </p>
</li>
<li><p>读取变量时，需要在变量名前加入’$’符号(写入时不要要加)，并且最好在变量左右两边，加入’{}’符号，以便解释器识别变量边界  </p>
<p>  <code>echo &quot;my age is ${my_age}&quot;</code>  </p>
</li>
<li><p>只读变量可以使用readonly进行申明  </p>
<p>  <code>#只读变量，被申明后，将不可以有再次被赋值操作，否则运行时会报错</code><br>  <code>my_age=24</code><br>  <code>readonly my_age</code>  </p>
</li>
<li><p>可以使用unset关键字删除变量，变量被删除后，将不能继续使用，且unset关键字不能删除只读变量  </p>
<p>  <code>unset my_age</code>  </p>
</li>
<li><p>运行shell时，会同时存在3种变量：局部变量（程序员在shell脚本中，定义的仅在当前脚本中有效的变量）、环境变量（运行shell所需要的系统配置的环境变量，必要时也可以在shell脚本中进行定义）、shell变量（由shell脚本自身设置的特殊变量，shell变量中，有一部分是环境变量，有一部分是局部变量）  </p>
</li>
</ul>
<h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><ul>
<li><p>单引号：<br>1、在单引号中的任何字符都会原样输出，所以在单引号中读取/写入变量是无效的<br>2、在单引号中嵌套单引号，若里层单引号中的内容含有变量，该变量会被读取。<br>  <code>lz=&#39;yyy&#39;</code><br>  <code>echo &#39;12&#39;35${lz}4&#39;12&#39;</code><br>  <code>&gt;&gt;1235yyy412</code>    </p>
</li>
<li><p>双引号：<br>1、双引号中可以读取变量<br>2、双引号中可以存在转义字符  </p>
<p>  <code>name=&#39;lz&#39;</code><br>  <code>namestr1=&quot;hello,${name}!&quot;</code><br>  <code>namestr2=&quot;hello,&quot;${name}&quot;!&quot;</code><br>  <code>namestr3=&quot;hello,&quot;$name&quot;!&quot;</code><br>  <code>echo $namestr1 $namestr2 $namestr3</code><br>  <code>&gt;&gt;hello,lz! hello,lz! hello,lz!</code>   </p>
</li>
<li><p>获取字符串长度：<br>可以使用‘#’字符来获取字符串长度<br><img src="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_strlen.jpg" alt="">    </p>
<pre><code>lz=&apos;yyy&apos;  
echo ${#lz}  
&gt;&gt;3
</code></pre></li>
<li><p>提取子字符串：  </p>
<p>  <code>stringstr=&quot;hello lz&quot;</code><br>  <code>echo ${string:6:8}</code><br>  <code>&gt;&gt;lz</code>    </p>
</li>
<li><p>查找字符的位置：  </p>
<p>  <code>stringstr=&quot;hello lz&quot;</code><br>  <code>#下句是反引号而不是单引号</code><br>  <code>echo `expr index &quot;${stringstr}&quot; l`\</code></p>
</li>
</ul>
<h3 id="重定向："><a href="#重定向：" class="headerlink" title="重定向："></a>重定向：</h3><p>>:输出重定向   </p>
<pre><code>#输出1到ip_forward文件中，如果ip_forward文件存在则清空该文件，再更新内容。若不存在，则创建再更新内容
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre><p>>&gt;:输出追加重定向  </p>
<pre><code>#输出&quot;lz&quot;到test.txt文件夹，若test.txt文件存在，则在最后另起一行，追加输入字符串&quot;lz&quot;。若文件不存在，则创建再更新内容  
echo lz &gt;&gt; /home/lz/test.txt  
#重定向，并且不在末尾添加换行符  
echo -n lz &gt; /home/lz/test.txt  
echo -n lz &gt;&gt; /home/lz/test.txt    
</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>定义数组  </li>
</ul>
<p><code>#数组名=(值1 值2....)</code>  </p>
<pre><code>arrayone=(1 2 3 &apos;lz&apos;)  
#echo ${arrayone[@]}可以按角标递增顺序输出数组内的所有元素  
echo ${arrayone[@]}
&gt;&gt;1 2 3 lz       
#或者  
arrayone=(      
1  
2  
3  
&apos;lz&apos;  
)      
#也可以单独定义数组中的元素，且可以不按角标增长顺序  
arrayone[0]=1  
arrayone[3]=&apos;lz&apos;  
echo ${arrayone[@]}  
&gt;&gt;1 lz  
</code></pre><ul>
<li><p>获取数组长度<br><img src="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_arraylen1.jpg" alt="">  </p>
<pre><code>lz=(1 2 3)  
echo ${#lz[@]}  
&gt;&gt;3
</code></pre></li>
<li><p>数组合并<br>  <code>l1=(1 2 3)</code><br>  <code>l2=(4 5 6)</code><br>  <code>l3=(${l1[@]} ${l2[@]})</code>  </p>
<h1 id="或"><a href="#或" class="headerlink" title="或"></a>或</h1><p>  <code>l1+=(${l2[@]})</code>  </p>
</li>
</ul>
<h3 id="从命令行向shell脚本传递参数"><a href="#从命令行向shell脚本传递参数" class="headerlink" title="从命令行向shell脚本传递参数"></a>从命令行向shell脚本传递参数</h3><p><img src="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_fromshell1.jpg" alt="">  </p>
<p>还有些常用参数：<br>$$：脚本运行的当前进程ID号<br>$!：后台运行的最后一个进程的ID号<br>$-：显示Shell使用的当前选项，与set命令功能相同（没理解）</p>
<p>$?：显示最后命令的退出状态，0表示没有错误，其他任何值表名有错误，例：  </p>
<pre><code>#若编译成功则提示&quot;compile successfully&quot;  
echo gcc -o hello hello.c

if [ $? -eq 0 ]
then
    echo &quot;compile successfully&quot;
else 
    echo &quot;compile fail&quot;
fi 
</code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://lizhong-blog-image-1253513411.cos.ap-guangzhou.myqcloud.com/Shell_sum.jpg" alt="">      </p>
<p>其他运算符和其他语言一样<br>需要注意的地方：<br>1、乘号(*)前需要加反斜杠(\)才能作为乘号使用<br>2、mac中的shell的expr语法是$((表达式))，此处表达式中的 “<em>“ 不需要转义符号 “\”<br>    `lz=expr $((2</em>3))<code>`echo ${lz}</code><br>    <code>&gt;&gt;6</code>  </p>
<h3 id="关系运算符（重要）"><a href="#关系运算符（重要）" class="headerlink" title="关系运算符（重要）"></a>关系运算符（重要）</h3><p>-eq：检测两数是否相等，相等返回true，与shell运算符中的==号一样<br>-ne：检测两数是否不等，不等返回true，与shell运算符中的!=号一样<br>-gt：检测左边的数是否大于右边的，如果是，返回true<br>-lt：检测左边的数是否小于右边的，如果是，返回true<br>-ge：检测左边的数是否大于等于右边的，如果是，返回true<br>-le：检测左边的数是否小于等于右边的，如果是，返回true<br>例：  </p>
<pre><code>val=${1} +${2}

#和是否等于3  
if [ ${val} -eq 3 ]
then
    echo &quot;${1} + ${2} == 3&quot;
else
    echo &quot;${1} + ${2} != 3, == ${val}&quot;    
</code></pre><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>！：非运算，表达式为true则返回false，否则返回true<br>-o：或运算，有一个表达式为true则返回true<br>-a：与运算，两个表达式都为true才返回true<br>例：  </p>
<pre><code>if [ 1 -gt 0 -o 0 -gt 1 ]  
then
    echo &quot;true&quot;  
else
    echo &quot;false&quot;  
if
&gt;&gt;true  
</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>&amp;&amp;：逻辑与<br>||：逻辑或<br>逻辑运算符和上面的布尔运算符的-o和-a的用法相同  </p>
<h3 id="字符串运算符（重要）"><a href="#字符串运算符（重要）" class="headerlink" title="字符串运算符（重要）"></a>字符串运算符（重要）</h3><p>=或==：检测两个字符串是否相等，相等返回true<br>!=：检测两个字符串是否不等，不相等返回true<br>-z：检测字符串长度是否为0，为0返回true<br>-n：检测字符串长度是否为0，不为0返回true<br>${a}：搭配if语句可以检测字符串a是否为空，不为空，返回true<br>例：  </p>
<pre><code>str1=&quot;&quot;  

if [ ${str1} ]
then
    echo &quot;字符串不为空&quot;
else
    echo &quot;字符串为空&quot;  
fi  

if [ -z ${str1} ]
then
    echo &quot;字符串长度为0&quot;  
else
    echo &quot;字符串长度不为0&quot;  
fi

&gt;&gt;字符串为空
&gt;&gt;字符串长度为0
</code></pre><h3 id="文件测试运算符（重要）"><a href="#文件测试运算符（重要）" class="headerlink" title="文件测试运算符（重要）"></a>文件测试运算符（重要）</h3><p>-b：检测文件是否是块设备文件，如果是，则返回true<br>-c：检测文件是否是字符设备文件，如果是，则返回true<br>-d：检测文件是否是目录，如果是，则返回true<br>-p：检测文件是否是有名管道，如果是，则返回true<br>-f：检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回true  </p>
<p>-g：检测文件是否设置了SGID位，如果是，则返回true<br>-k：检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回true<br>-u：检测文件是否设置了SUID位，如果是，则返回true  </p>
<p>-r：检测文件是否可读，如果是，则返回true<br>-w：检测文件是否可写，如果是，则返回true<br>-x：检测文件是否可执行，如果是，则返回true  </p>
<p>-s：检测文件是否为空（文件大小是否大于0），不为空，则返回true<br>-e：检测文件（包括目录）是否存在，如果是，则返回true<br>例：  </p>
<pre><code>filedir=&quot;/home&quot;

if [ -d ${filedir} ]
then
    echo &quot;这是目录&quot;  
else
    echo &quot;这不是目录&quot;  
fi
&gt;&gt;这是目录  
</code></pre><h3 id="echo（该命令会自动添加换行符）（可以理解为只是用来输出字符串的，不需要输出时，可以不使用此命令，当printf一样用就好）"><a href="#echo（该命令会自动添加换行符）（可以理解为只是用来输出字符串的，不需要输出时，可以不使用此命令，当printf一样用就好）" class="headerlink" title="echo（该命令会自动添加换行符）（可以理解为只是用来输出字符串的，不需要输出时，可以不使用此命令，当printf一样用就好）"></a>echo（该命令会自动添加换行符）（可以理解为只是用来输出字符串的，不需要输出时，可以不使用此命令，当printf一样用就好）</h3><p>1、-e：开启转义，例：  </p>
<pre><code>echo -e &quot;hello world \r\nlz&quot;  
&gt;&gt;hello world
&gt;&gt;lz  
</code></pre><p>2、原样输出字符串，不进行转义或取变量，使用单引号：  </p>
<pre><code>name=&quot;lz&quot;
#注意，是单引号
echo &apos;${name}\r\n&apos;  
&gt;&gt;${name}\r\n  

echo -e &apos;${name}\r\nlz&apos;#开启转义  
&gt;&gt;${name}  
&gt;&gt;lz  
</code></pre><p>3、显示结果定向至文件：  </p>
<pre><code>#在home路径下，重写test.txt文件  
echo &quot;hello world&quot; &gt; /home/test.txt  
</code></pre><p>4、显示命令执行结果  </p>
<pre><code>#注意，是反引号，而不是单引号
echo `date`  
&gt;&gt;输出当前时间和日期  

#将时间和日期追加输出至date.txt文件中      
echo `date` &gt;&gt; /home/date.txt  
</code></pre><h3 id="printf-不会自带换行符"><a href="#printf-不会自带换行符" class="headerlink" title="printf(不会自带换行符)"></a>printf(不会自带换行符)</h3><p>Shell中的printf和C中的差不多，跟echo的差别也就是，printf主要用在格式化输出，例：  </p>
<pre><code>#%-10s表示左对齐10个字符，不足10个字符，自动补空格，超过10个字符，则全显示
printf &quot;%-10s %-8s %-4s\r\n&quot; 姓名 性别 年龄  
printf &quot;%-10s %-8s %-4d\r\n&quot; 李人 男 24  
printf &quot;%-10s %-8s %-4d\r\n&quot; 李人人 男 24
printf &quot;%-10s %-8s %-4d\r\n&quot; 李人人人 男 24  
</code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>test命令，常和if搭配使用，一般使用正常的if语句即可，可以不关注test  </p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>1、if else  </p>
<pre><code>#将then和fi看做if语句的花括号（{}）即可
if condition
then
    command
else
    command
fi  

#注意，最后只要一个fi即可
if condition
then
    command
elif condition
then
    command
else
    command
fi

# 简化版，[]中的表达式为真时，输出exec sueecss  
[ $? -eq 0 ] &amp;&amp; echo &quot;exec success&quot;   

# 多条件判断,如果lz等于yyy并且lz1等于xxx,则输出ok  
if [[ x&quot;${lz}&quot; == x&quot;yyy&quot; ]] &amp;&amp; [[ x&quot;${lz1}&quot; == x&quot;xxx&quot; ]]; then
    echo &quot;ok&quot;
fi
</code></pre><p>2、for循环<br>想循环一定次数，可以使用关键字seq实现，例：</p>
<pre><code>#seq，默认从1开始，且步长为1，seq 3 4 100 从3开始，步长为4，到100
for var in `seq 100`
do
    command
done     

#var依次为item1、item2...itemN，按此进行循环  
for var in item1 item2 ...itemN  
do   
    command  
done    

#var依次为str的下角标所对应的元素，按此进行循环
for var in str
do
    command
done  

#对执行该脚本时输入的参数进行遍历  
for var in $*
do
    command
done  

#无线循环
for (( ; ; ))  

#结合数组，遍历数组  
lz=(&apos;f&apos; &apos;y&apos; &apos;i&apos;)  
for element in ${lz[@]}; do echo &quot;${element}&quot;; done  
&gt;&gt;f  
&gt;&gt;y  
&gt;&gt;i  
</code></pre><p>3、while循环  </p>
<pre><code>while ((condition))
do
    command
done

#例  
var=89

while ((var &lt; 100))
do
    echo -e &quot;${var} \c&quot;
    let var++
done  

#无限循环
while :#或 while true
do
    command
done  
</code></pre><p>4、until循环：<br>until循环执行一系列命令，直到条件为true时为止，写法：  </p>
<pre><code>until condition
do 
    command
done  
</code></pre><p>5、case语句：<br>case语句为多选择语句，可以用case语句进行一个值匹配，写法：  </p>
<pre><code>case 值 in     
1模式/值)
    command
    ...
;;
2模式/值)
    command
    ...
;;  
*)
    command
;;  
...
esac
</code></pre><p>在Shell的case中，取值可以为变量或常数，若匹配上某模式或值时，将执行该段语句，到;;结束。并且匹配后，不会再继续向下执行(和C不同)。若无任何一值匹配时，则可使用星号通配（相当于default）  </p>
<p>6、break，continue语句，在Shell中同样适用，用法与C相同  </p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在Shell中函数的例子（带参数）：  </p>
<pre><code>functest()
{
    echo &quot;run functest function&quot;
    echo &quot;the first param is $1&quot;
}

functest 1 2 3  
</code></pre><h3 id="输入-出的重定向（重要）"><a href="#输入-出的重定向（重要）" class="headerlink" title="输入/出的重定向（重要）"></a>输入/出的重定向（重要）</h3><p>因为Shell主要是用来写脚本的，操作一些文件啥的，所以重定向还是很重要的<br>command &gt; file：将输出重定向到file<br>command &lt; file：将输入重定向到file<br>command &gt;&gt; file: 将输出以追加方式重定向到file  </p>
<p>下面这几个目前还不是很理解<br>n &gt; file：将文件描述符为n的文件重定向到file<br>n &gt;&gt; file：将文件描述符为n的文件以追加方式，重定向到file<br>n &gt;&amp; m：将输出文件m和n合并<br>n &lt;&amp; m：将输入文件m和n合并<br>&lt;&lt;tag：将开始标记tag和结束标记tag之间的内容作为输入    </p>
<p>注意：一般情况下，每个linux命令运行时，都会打开三个文件：<br>标准输入文件(stdin)，文件描述符为0，默认从stdin读取数据<br>标准输出文件(stdout)，文件描述符为1，默认向stdout输出数据<br>标准错误文件(stderr)，文件描述符为2，Shell脚本报错，会向stderr流中写入错误信息<br>其中stdout和stderr默认都是向屏幕输出的<br>默认情况下，command &gt; file会将stdout重定向到file<br>默认情况下，command &lt; file会将stdin重定向到file<br>如果希望stderr重定向到file，则：  </p>
<pre><code>command 2 &gt; file  

#追加
command 2 &gt;&gt; file    
</code></pre><p>如果希望将stdout和stderr合并后重定向到file，则：  </p>
<pre><code>command &gt; file 2&gt;&amp;1  
</code></pre><p>如果希望对stdin和stdout都重定向，则：  </p>
<pre><code>#将command命令的输入stdin重定向到file1，输出stdout重定向到file2
command &lt; file1 &gt;file2
</code></pre><h3 id="Here-Document（重要）"><a href="#Here-Document（重要）" class="headerlink" title="Here Document（重要）"></a>Here Document（重要）</h3><p>Here Document是Shell中的一种特殊的重定向方式，用来将输入重定向到一个交互式Shell脚本或程序，写法：  </p>
<pre><code>#将两个delimiter中的内容(document)作为命令的输入传递给command
#注意这里是命令的输入，也就是说，这个命令要求输入，才有用，并不是指紧跟在命令后的输入参数
command &lt;&lt; delimiter  
    document
delimiter    

#例
mkdir &lt;&lt; EOF
    testdir
EOF
</code></pre><h3 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h3><p>如果希望执行某命令后，不在屏幕或文件中进行输出，则可以将command的输出重定向到/dev/null下，写法：  </p>
<pre><code>command &gt; /dev/null

#屏蔽标准输出和错误输出
command &gt; /dev/null 2&gt;&amp;1
</code></pre><h3 id="包含Shell文件"><a href="#包含Shell文件" class="headerlink" title="包含Shell文件"></a>包含Shell文件</h3><p>主要是指，可以将Shell文件进行相互应用，例：  </p>
<pre><code>#在1.sh中(可以不升级成执行权限)
name=&quot;lz&quot;

#在2.sh中  
#包含1.sh文件，注意./1.sh是path路径  
. ./1.sh
echo &quot;my name is ${name}&quot;  
&gt;&gt;my name is lz  
</code></pre><h3 id="交互脚本"><a href="#交互脚本" class="headerlink" title="交互脚本"></a>交互脚本</h3><p>如果需要对某个应用程序进行一些交互操作，这里提供几种方式<br>1、利用重定向，将输入重定向至某个文件或某块文档，但不能在交互的时候使用条件语句和循环语句<br>2、使用“|”管道，缺点和上面相同<br>3、使用expect库<br>此处推荐使用expect库，在ubuntu下直接apt-get install expect即可，以下例子为使用expect库对ftp应用程序进行交互操作（./ftp_put.sh）    </p>
<pre><code>#! /usr/bin/expect

set openflag 1
set drthost 192.168.175.1
set localfile ./1.iso
set fcount 0

#使expect语句永久等待条件成立
set timeout -1

spawn ftp -n
send &quot;open ${drthost}\r&quot;
send &quot;user anonymous xxx@126.com\r&quot;

while { ${openflag} } {
    send &quot;put ${localfile}\r&quot;
    expect &quot;*Transfer complete*&quot;
    set fcount [expr ${fcount} + 1]
    send_user &quot;put file ok,${fcount}\r\n&quot;
    sleep 1
}
send &quot;close\r&quot;
send &quot;bye\r&quot;
interact
</code></pre><p>注意，如果需要在shell中嵌入expect可以单独写一个expect脚本，再在shell中调用即可，类似如下：  </p>
<pre><code>#! /bin/bash

date
./ftp_put.sh
</code></pre>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/04/18/Move-Vim/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          移植Vim到Cavium
        
      </div>
    </a>
  
  
    <a href="/2018/04/05/Iptables-Netfilter/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">iptables与netfilter</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>







<!--

//-->

 <!--以下为使用畅言的代码
  && post.comments
  style="padding: 0px 30px 0px 46px;">
  //-->
 
 
  <section id="comments">
<!--高速版，加载速度快，使用前需测试页面的兼容性-->
<div id="SOHUCS" sid="Shell笔记"></div>
<script>
  (function(){
    var appid = 'cyto4sUr6',
    conf = '5531a21399d22997758da7915e34b8fe';
    var doc = document,
    s = doc.createElement('script'),
    h = doc.getElementsByTagName('head')[0] || doc.head || doc.documentElement;
    s.type = 'text/javascript';
    s.charset = 'utf-8';
    s.src =  'http://assets.changyan.sohu.com/upload/changyan.js?conf='+ conf +'&appid=' + appid;
    h.insertBefore(s,h.firstChild);
    window.SCS_NO_IFRAME = true;
  })()
</script>
  </section>
  
</div>
      <!--
注释：用卜算子来统计网页访问量
//-->
<!--
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
//-->

<footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    	<!--	&copy; 2020 木子人人人 -->
    	</div>
      	<div class="footer-right">
      	<!--	<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten -->
		
		<!--
		<span id="busuanzi_container_site_uv"></span>
		Total visited <span id="busuanzi_value_site_uv"></span> times
		//-->
		
		
		<script>
		(function(){
			var bp = document.createElement('script');
			bp.src = '//push.zhanzhang.baidu.com/push.js';
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(bp, s);
		})();
		</script>
		
		
      	</div>
    </div>
  </div>
</footer>



    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>