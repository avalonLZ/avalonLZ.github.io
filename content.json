{"meta":{"title":"人人人's 藏经阁","subtitle":"积跬步 至千里","description":null,"author":"人人人","url":"http://avalonlz.github.io","root":"/"},"pages":[],"posts":[{"title":"Linux必学工具之LD_PRELOAD","slug":"Tools-LDPreload","date":"2022-02-19T05:04:35.000Z","updated":"2022-02-20T09:03:44.886Z","comments":true,"path":"2022/02/19/Tools-LDPreload/","link":"","permalink":"http://avalonlz.github.io/2022/02/19/Tools-LDPreload/","excerpt":"本文用于记录Linux工具LD_PRELOAD的使用","text":"本文用于记录Linux工具LD_PRELOAD的使用 简介LD_PRELOAD工具，更合理的称呼应该是LD_PRELOAD机制。它是Linux程序加载的一套机制：简单来说，就是可以将动态编译的程序（ldd有显示动态链接库的，都是动态编译的程序，且gcc编译时，如果未加-static参数，则就是使用动态编译程序），在加载其下所有需要的动态链接库前，先加载你所指定的动态链接库。并且LD_PRELOAD机制是每个Linux上所有动态编译的程序必走的流程，所以在Linux上，动态链接库的加载顺序应该是： 通过该机制，就可以实现动态链接库函数的劫持(即动态的实现hook函数)。该机制大大加快了排查问题的效率，原先需要修改内核，在系统调用处加入打印日志的排查方式，基本都可以用该机制平替。 LD_PRELOAD机制两种使用方式及区别●使用LD_PRELOAD环境变量一般使用LD_PRELOAD环境变量跑LD_PRELOAD有两种方式，其中一种是直接设置环境变量，如下所示： export LD_PRELOAD=/xxx/libxxx.so#绝对路径但此种方式意义不大，因为如果是想要截获某些系统命令，若该命令是bash中的内置命令（help命令可以列出bash所有内置命令，或使用type xxx（命令）查看是否是bash内置命令），由于bash启动时，无法设置该环境变量（环境变量的设置，总是要在bash启动后，才可设置），所以此种方式无法截获bash内置命令。但此方式可用于简单测试自己编写的动态链接库中，需要替换的函数符号，是否和原动态链接库（一般是glic库）的函数符号相同（一定要编译出的函数符号相同，才可成功劫持）下面以kill命令为例，演示下使用这个环境变量的效果： 1.查看kill命令用了哪个库函数（一般bash内置命令和非内置命令，所使用的库函数都是相同的） 2.重新定义该库函数，并将其编译成一个动态链接库 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&lt;dlfcn.h&gt; //在glibc中查看kill原本的定义为int kill (pid_t pid, int sig) //但其实只要定义的函数名称，也就是函数符号相同，则可被成功劫持 //所有这就不管参数了 int kill () { printf(&quot;******lz*******\\n&quot;); return 0; } 再将以上程序编译成动态链接库： gcc -shared -fPIC hook_kill.c -o libhook_kill.so 3.在需要执行/bin/kill命令的bash中，设置环境变量 export LD_PRELOAD=/xxx/libhook_kill.so 4.执行/bin/kill命令，结果如下图所示，说明已被成功劫持 另：如果不想设置环境变量，还可通过以下方式执行命令，控制影响范围 LD_PRELOAD=`pwd`/libhook_kill.so /bin/kill `pidof top` ●使用配置文件由以上可知，如果想bash中的内置命令也生效，则至少需要在bash启动时，就能识别到所替换的动态链接库，LD_PRELOAD机制则提供了/etc/ld.so.preload配置文件 1.将想要在程序启动时，就加载的动态链接库，写入该配置文件 echo “/home/lz/Desktop/ld_preload/libhook_kill.so.0” &gt; /etc/ld.so.preload 2.新开一个bash，再直接执行kill命令（bash内置），可以发现已成功被拦截 注意：/etc/ld.so.preload配置文件中的动态链接库的加载，是在程序启动的时候就已经加载完毕了（静态加载，而非懒加载），也就是说，在程序运行过程中，如果修改了/etc/ld.so.preload文件中的内容，也并不会影响当前已经启动了的bash内置程序的执行结果（因为修改前的函数符号及其指令，在该bash启动时就已经被识别到，并加载到内存中了），只会影响到在其修改操作之后，启动的应用程序或命令的执行结果 其他●hook_kill模板（摘抄自网络），学习该模板中的主要流程，即可编写出其他功能的hook工具： #define _GNU_SOURCE #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;dlfcn.h&gt; typedef int(*KILL)(pid_t pid, int sig); #define TMP_BUF_SIZE 256 /* 获取进程命令行参数 */ void get_cmd_by_pid(pid_t pid, char *cmd) { char buf[TMP_BUF_SIZE]; int i = 0; snprintf(buf, TMP_BUF_SIZE, &quot;/proc/%d/cmdline&quot;, pid); FILE* fp = fopen(buf, &quot;r&quot;); if(fp == NULL) { return; } memset(buf, 0, TMP_BUF_SIZE); size_t ret = fread(cmd, 1, TMP_BUF_SIZE - 1, fp); /* *需要下面for循环的原因是 *man手册资料 *This holds the complete command line for the process, unless the process is a zombie. *In the latter case,there is nothing in this file: that is, a read on this file will return 0 *characters. The command-line arguments appear in this file as a set of strings separated by *null bytes (&apos;\\0&apos;), with a further null byte after the last string. */ for (i = 0; ret != 0 &amp;&amp; i &lt; ret - 1; i++) { if (cmd[i] == &apos;\\0&apos;) { cmd[i] = &apos; &apos;; } } fclose(fp); cmd[TMP_BUF_SIZE - 1] = &apos;\\0&apos;; } //重新定义kill函数 int kill(pid_t pid, int sig) { static KILL orign_kill = NULL; //接收kill命令的进程信息 char buf_des[TMP_BUF_SIZE] = {0}; get_cmd_by_pid(pid, buf_des); //获取当前进程信息 char buf_org[TMP_BUF_SIZE] = {0}; get_cmd_by_pid(getpid(), buf_org); //获取父进程信息 char buf_porg[TMP_BUF_SIZE] = {0}; get_cmd_by_pid(getppid(), buf_porg); printf(&quot;hook kill(sig:%d): [%s(%d) -&gt; %s(%d)] -&gt; [%s(%d)]\\n&quot;, sig, buf_porg, getppid(), buf_org, getpid(), buf_des, pid); out: if(!orign_kill){ //获取下一个kill的函数指针 //这里如果下一次加载的是glibc中的kill //则就可获取到原本的kill函数指针 orign_kill = (KILL)dlsym(RTLD_NEXT, &quot;kill&quot;); } //调用原本的kill方法 return orign_kill(pid, sig); } ●想要更多的了解linux动态链接器，可参考其源码以及如下文章： 1.动态链接库的装载过程（动态链接器的工作流程）：https://blog.csdn.net/xiaofei0859/article/details/50588387?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-5.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=7 2.动态链接库的装载顺序：https://blog.csdn.net/whatday/article/details/108890018?spm=1001.2101.3001.6650.15&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-15.queryctrv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-15.queryctrv2&amp;utm_relevant_index=20","categories":[],"tags":[{"name":"Linux工具","slug":"Linux工具","permalink":"http://avalonlz.github.io/tags/Linux工具/"}]},{"title":"Linux必学工具之ftrace","slug":"Tools-ftrace","date":"2021-09-12T12:39:35.000Z","updated":"2021-09-25T08:39:17.826Z","comments":true,"path":"2021/09/12/Tools-ftrace/","link":"","permalink":"http://avalonlz.github.io/2021/09/12/Tools-ftrace/","excerpt":"本文用于记录Linux工具ftrace的使用","text":"本文用于记录Linux工具ftrace的使用 简介 使用要求 使用说明 举例 简介ftrace是Linux内核提供的，可动态捕获内核函数调用栈的工具，排查内核相关问题，必备良药 使用要求想要使用ftrace，对内核版本及其编译选项均有如下要求：1.内核版本2.6.27及以上2.编译内核时，需要使能所你需要的trace类型（3.10的话本质只提供的几个可选项） 使用说明当你已经编译完成并替换好内核后，便可以使用ftrace对某一操作的内核行为进行分析了，ftrace所涉及的文件结构如下图所示：下面对常用的文件进行说明： /* 所有跟踪器，常用公共配置文件： */ [root@localhost tracing]# cat available_tracers #内核目前所支持的追踪类型 hwlat blk function_graph wakeup_dl wakeup_rt wakeup function nop [root@localhost tracing]# cat tracing_on #开/关追踪功能 1 [root@localhost tracing]# cat current_tracer #设置当前追踪类型，nop表示啥也不追踪 nop [root@localhost tracing]# cat available_filter_functions #ftrace可支持的内核函数名称，位于该文件内的函数，写入set_ftrace_filter才有效 /* function跟踪器常用配置文件： */ [root@localhost tracing]# cat set_ftrace_filter #需要跟踪的函数名称 #### all functions enabled #### [root@localhost tracing]# cat options/func_stack_trace #开/关函数调用栈追踪功能 1 [root@localhost tracing]# cat trace_options #显示出当前所选择的跟踪器的option配置（function跟踪器内容如下） /* function_graph跟踪器，常用配置文件（3.10.0上无法配置跟踪函数调用栈所以一般还是用function）： */ [root@localhost tracing]# cat set_graph_function #指定function_graph跟踪器需要跟踪的函数 #### all functions enabled #### [root@localhost tracing]# cat max_graph_depth #设置function_graph跟踪函数嵌套的最大深度 10 举例下面采用Centos7，3.10.0内核版本，以设置中断为例子,演示如何使用function跟踪器实现内核函数调用栈的跟踪（此内核版本对function_graph跟踪器的功能有限，遂尚不用此举例） 1.配置当前跟踪器为function: [root@localhost tracing]# echo function &gt; current_tracer 2.设定所跟踪的内核函数为irq_do_set_affinity： [root@localhost tracing]# echo irq_do_set_affinity &gt; set_ftrace_filter 3.检查下option里是否开启了函数调用栈跟踪： [root@localhost tracing]# cat trace_options print-parent nosym-offset nosym-addr noverbose noraw nohex nobin noblock nostacktrace trace_printk noftrace_preempt nobranch annotate nouserstacktrace nosym-userobj noprintk-msg-only context-info nolatency-format sleep-time graph-time record-cmd overwrite nodisable_on_free irq-info markers function-trace func_stack_trace#启用了函数调用栈跟踪 4.开启跟踪： [root@localhost tracing]# echo 1 &gt; tracing_on 5.先清空一下trace中现有的内容： [root@localhost tracing]# echo &gt; trace 6.配置一个中断号的中断亲和性： [root@localhost Desktop]# echo 0 &gt; /proc/irq/16/smp_affinity_list 7.查看trace中的内容： [root@localhost tracing]# cat trace # tracer: function # # entries-in-buffer/entries-written: 2/2 #P:1 # # _-----=&gt; irqs-off # / _----=&gt; need-resched # | / _---=&gt; hardirq/softirq # || / _--=&gt; preempt-depth # ||| / delay # TASK-PID CPU# |||| TIMESTAMP FUNCTION # | | | |||| | | kworker/0:1-25 [000] d.h. 738.204946: irq_do_set_affinity &lt;-irq_move_masked_irq kworker/0:1-25 [000] d.h. 738.204955: &lt;stack trace&gt; =&gt; handle_fasteoi_irq =&gt; handle_irq =&gt; do_IRQ =&gt; ret_from_intr =&gt; process_one_work =&gt; worker_thread =&gt; kthread =&gt; ret_from_fork_nospec_end 可以看到内核函数的调用栈情况","categories":[],"tags":[{"name":"Linux工具","slug":"Linux工具","permalink":"http://avalonlz.github.io/tags/Linux工具/"}]},{"title":"Kubernetes(K8s)入门-1","slug":"Kubernetes-study-1","date":"2021-04-16T15:09:12.000Z","updated":"2021-04-16T15:45:15.385Z","comments":true,"path":"2021/04/16/Kubernetes-study-1/","link":"","permalink":"http://avalonlz.github.io/2021/04/16/Kubernetes-study-1/","excerpt":"Kubernetes(K8s)入门-1，最近参加了关于K8s的培训，为提升学习效果，所以想做个课程主要内容的回顾总结。本文主要会介绍下K8s必用的组件和对象，主要是些概念性的东西","text":"Kubernetes(K8s)入门-1，最近参加了关于K8s的培训，为提升学习效果，所以想做个课程主要内容的回顾总结。本文主要会介绍下K8s必用的组件和对象，主要是些概念性的东西 本文将按以下顺序，对K8s进行介绍：● 什么是K8s？● 为什么要用K8s？（K8s有什么作用？解决了什么问题？）● K8s有哪些基础组件，它们的作用/职责是什么？● K8s有哪些对象，它们的作用/职责是什么？● 培训过程中遗留的一些疑问及其解答 什么是K8s？为什么要用K8s？（K8s有什么作用？解决了什么问题？）K8s有哪些基础组件，它们的作用/职责是什么？K8s有哪些对象，它们的作用/职责是什么？培训过程中遗留的一些疑问及其解答1.问：容器自身进程，与容器内运行的应用进程之间的关系是怎样的？答： 2.问：为容器创建的veth设备，实际是个什么东西（tun or tap or other）？答： 3.问：若容器内运行的应用，是否能依赖与主机不同的内核版本或参数？答：不可以，容器虚拟化技术，始终是在进程级别的虚拟化，它无法虚拟化出整个操作系统（最多只能是打包环境变量和上层依赖库、文件系统等），所以容器内应用在运行时，若对内核有所依赖，则主机内核必须要能满足其需求。 4.问：Pod网络overlay解决方案中，所使用的flanneld是一个集群服务？答： 5.问：Pod网络underlay解决方案中，所提到的“将主机网卡添加到网桥，再将主机网卡的地址配置到网桥，并把默认路由规则转移到网桥xxx”具体该如何操作？答： 6.K8s中所定义的组件和对象间是否有所关系，若有，是种怎样的关系？","categories":[],"tags":[{"name":"云计算","slug":"云计算","permalink":"http://avalonlz.github.io/tags/云计算/"}]},{"title":"《怦然心动》","slug":"Articles-pengranxindong","date":"2021-03-06T14:21:55.000Z","updated":"2021-03-06T14:19:38.384Z","comments":true,"path":"2021/03/06/Articles-pengranxindong/","link":"","permalink":"http://avalonlz.github.io/2021/03/06/Articles-pengranxindong/","excerpt":"读文德琳·范·德拉安南的《怦然心动》小记","text":"读文德琳·范·德拉安南的《怦然心动》小记 喜欢的句子1、有些风筝很幸运，有的也很难搞。两种我都遇到过，一只幸运的风筝才值得你去追寻它。2、从长远来看，应该做出对所有人的伤害都是最小的决定。3、有人住高楼，有人在深沟。有人光万丈，有人一身锈。世人千万种，浮云莫去求。斯人若彩虹，遇上方知有4、大部分人，整体小于部分之和5、这种感觉，就像朝着风中吹散一朵蒲公英，看着细小的种子随风飘散。6、甲之熊掌，乙之砒霜。 《怦然心动》—文德琳·范·德拉安南全书用新颖的手法进行叙述（是用男主人公和女主人公两种视角叙述同一件事情。也就是说同一件事情，用两个章节去描述，分别是男女主人公的不同视角。）故事的发生在美国的一个小镇（好像书中没有交代）？真实善良的朱莉一家生活在小镇上，这天，街道对面搬来了一家新邻居（布莱斯一家）。朱莉被布莱斯的蓝色眼睛所吸引，在朱莉妈妈的劝说下，朱莉鼓起勇气去帮布莱斯一家搬家。布莱斯看到朱莉平凡的外表和脏兮兮的鞋，第一感觉就对朱莉很是不喜。而在朱莉看来，布莱斯种种躲避的动作，都被朱莉解释为害羞，不好意思。就这样，朱莉默默的喜欢着布莱斯，而布莱斯却一直躲避着她。日子一天天过去，朱莉在爸爸的教育下，渐渐长大，当她爬上无花果树，眺望大半个小镇的时候，才发现世界是这么的美丽。所以朱莉把这颗无花果树看的很重要，当人们想去将它砍倒，留出空地搭建房屋时，朱莉孤身一人勇敢的爬上树，保护着无花果树（也许是出于感恩，也许是出于对美丽世界的不舍，但无论怎样，她的感情是那么的美好和真诚）。这一切被刊登到了报纸上，布莱斯的外公查特注意到了这个小女孩，并对她产生了好感。而后发生了鸡蛋事件，布莱斯偷偷将朱莉送给他们家的鸡蛋丢掉，这一切被朱莉偶然的看到了，朱莉很伤心，对布莱斯的态度便是180度的大转弯了。因为布莱斯丢鸡蛋时候，提到很嫌弃朱莉家的脏院子和她脏脏的装扮，朱莉便想花些钱买原料自己修整院子。要花钱买原料的事，也就引申出了朱莉智力缺陷的叔叔。原来，善良的朱莉一家，大部分的钱都用于资助朱莉存在智力缺陷的叔叔了，自己一直过的很清贫。在布莱恩没说之前，朱莉其实一直都没感觉。当然，这样的朱莉很理解也很赞同父母的做法。在朱莉收拾院子的时候，布莱斯的外公查特便来帮忙，查特和朱莉交谈渐深，查特越发觉得朱莉向自己过世的妻子。在布莱恩某天晚饭时，查特说出了朱莉家的情况，布莱恩的母亲佩西决定邀请朱莉一家来自家吃晚宴。由于朱莉对布莱斯态度的转变，让布莱斯很不是滋味，本性善良的他，渐渐喜欢上了朱莉。晚宴上，布莱斯父亲瑞克，刻薄虚伪的为人，让布莱斯一家都十分厌恶。这次晚宴没能让朱莉和布莱恩和好，但接下来学校举办的篮子男孩活动，布莱斯的主动，让朱莉开始渐渐原谅他了。故事的最后，布莱斯在朱莉家院子里种了棵无花果树，朱莉也决定和布莱斯好好谈谈，想着，或许对布莱恩了解的还不深…全书到这里就结束了，故事的结尾是开放的，作者应该是想让每个读者自己去续写吧。一个暖心的故事，希望都能有个好结局。","categories":[],"tags":[{"name":"闲书小记","slug":"闲书小记","permalink":"http://avalonlz.github.io/tags/闲书小记/"}]},{"title":"《赶路人》&&《人间值得》","slug":"Articles-ganluren-renjianzhide","date":"2021-02-05T14:21:55.000Z","updated":"2021-02-05T15:01:37.591Z","comments":true,"path":"2021/02/05/Articles-ganluren-renjianzhide/","link":"","permalink":"http://avalonlz.github.io/2021/02/05/Articles-ganluren-renjianzhide/","excerpt":"读李小晓的《赶路人》，中村恒子的《人间值得》小记","text":"读李小晓的《赶路人》，中村恒子的《人间值得》小记 《赶路人》—李小晓全书每个章节都由一个个真实的故事改编，代入感极强，强烈推荐1、刘清莲的小奇迹，此章节的故事阐述了一个典型的中国母亲2、我的父亲老何，此章节的故事阐述了一个典型的中国父亲3、金钱只是表达情感的工具4、朋友的来源，不外乎两类，一类是有些共同的生活经历，一类是有着共同的人生志趣5、志趣一致，又可反应为：我们所念所想，不过是共同经营好这份来之不易的生活。愿子女成才，愿老人安康，愿彼此笑口常开6、重物质的社会 简单 冰冷7、重精神的社会 复杂 温情8、安然若素 岁月静好9、有人予你轰轰烈烈 有人与你平平淡淡 时光匆匆 不负赶路之人10、金钱能买到的幸福感是低廉的，真正值得追求的幸福感，是金钱无法给予的 《人间值得》—中村恒子全书讲述了日本精神医生中村恒子的一生。看完全书，会感觉到，她的一生跟其他普通人并没有什么不同，一样的快乐，一样的烦恼。相对来说值得她烦恼的事，可能还更多。但医生她以低欲望和平易近人的态度，去度过每一天。这样的生活态度，让她不纠结于烦恼，just do it坦率的接受每一天。全书平平淡淡，有些为人处世的技巧，初次回味，并没有人间值得的感觉。但细细想来，也是想告诉读者，这便是人生，每个人都在过着阴暗与光明相互交织的日子，而你要做的，便是向着光明，感受人间值得。太宰治的《人间失格》，过于阴暗，没有把握抓住生活的光明，暂时没有翻看","categories":[],"tags":[{"name":"闲书小记","slug":"闲书小记","permalink":"http://avalonlz.github.io/tags/闲书小记/"}]},{"title":"《曾国潘：又笨又慢平天下》&&《心》","slug":"Articles-zengguopan-xin","date":"2021-02-05T13:43:31.000Z","updated":"2021-02-05T15:01:42.369Z","comments":true,"path":"2021/02/05/Articles-zengguopan-xin/","link":"","permalink":"http://avalonlz.github.io/2021/02/05/Articles-zengguopan-xin/","excerpt":"读度阴山的《曾国潘：又笨又慢平天下》，稻盛和夫的《心》小记","text":"读度阴山的《曾国潘：又笨又慢平天下》，稻盛和夫的《心》小记 《曾国潘：又笨又慢平天下》—度阴山1、人生最好是“小满”，花未全开月未圆2、月满则亏，杯满则溢，自满则败,自矜则愚3、曾国藩被后人称为“半个完人”，资质平平，做事迟缓，甚至可以说是“庸人”的他，无外乎是做到了自省、自律、踏实、勤奋、坚持。所以为人“心”才是主要的，这也和稻盛和夫所强调的《心》不谋而合，追求完美的向上之心，催生出强大的自驱力，再加上坚持，剩下的，时间会说话4、修身、齐家、平天下在曾国潘身上体现为：自省克己、坚持写家书、平复太平天国5、领导力，执行力和吸引力比起，为属下争利，往往都是次要的6、世上能一个人完成的事情，都惧怕坚持 《心》—稻盛和夫1、企业经营界神话，稻盛和夫，尊崇“现实又心塑造”，《心》全书也都在说明，要修怎样的心，要怎样修心，才能成就事业2、事在人为3、将是非善恶，真善美，作为行动准则，怀抱利他思想，坚持，全力以赴实现目标，事物便会良性循环4、这本书的译者导读挺有意思的，开篇三连问，将人生对未知的疑问全盘抛出，仿佛只要你读了此书，就能找到答案","categories":[],"tags":[{"name":"闲书小记","slug":"闲书小记","permalink":"http://avalonlz.github.io/tags/闲书小记/"}]},{"title":"DPDK网口操作必用API","slug":"DPDK_API_Port","date":"2020-12-13T13:16:35.000Z","updated":"2020-12-20T15:26:24.875Z","comments":true,"path":"2020/12/13/DPDK_API_Port/","link":"","permalink":"http://avalonlz.github.io/2020/12/13/DPDK_API_Port/","excerpt":"本文主要想简单记录下，一个DPDK应用必须要使用的，一些网口操作API首先会先介绍下，DPDK应用启动，必须要做的一些事情（参照l2fwd例程）","text":"本文主要想简单记录下，一个DPDK应用必须要使用的，一些网口操作API首先会先介绍下，DPDK应用启动，必须要做的一些事情（参照l2fwd例程） DPDK APP Start 相关API使用流程对于一个DPDK应用来说，要想使用DPDK的PMD驱动，至少要做以下几件事情（按API的使用顺序罗列）： 初始化环境（rte_eal_init） 启动参数解析（xxx_parse_args） 转发核与网口绑定（自定义函数，自行维护对应关系） 创建mempool（rte_pktmbuf_pool_create） 配置网口（rte_eth_dev_configure） 初始化/配置网口收包队列（rte_eth_rx_queue_setup） 初始化/配置网口收包队列（rte_eth_tx_queue_setup） 启动网口/设备（rte_eth_dev_start） 注册转发核处理函数（rte_eal_mp_remote_launch）本文将会提及，其中4-8步所使用的API，及其关键功能 创建mempool首先说下创建内存池 //创建一个mempool struct rte_mempool *rte_pktmbuf_pool_create(const char *name, unsigned int n, unsigned int cache_size, uint16_t priv_size, uint16_t data_room_size, int socket_id) name：mempool名称 n：mempool中mbuf的数量 cache_size：mempool针对不同cpu（core），自己做的一个cache，减少不同cpu访问mempool的上锁操作（一般是用32或250？） priv_size：mempool的私有数据结构长度（正常收发包一般不用，加解密方面会用到） data_room_size：指明一个rte_mbuf的大小 socket_id：指明该mempool要从哪个cpu插槽申请（一般是找到转发core所在的cpu插槽） 其中比较有疑问的参数是cache_size，DPDK的mempool针对不同core,所做的软件cache（并非一个core内部的cache）。目的，是为了减少不同core访问mempool时的上锁操作（原理大致如下图所示）。cache_size在DPDK中默认最大是250，理论上来说cache应该是尽可能的大，所以一般也将此值设为250（有的例程是32可能是出于DPDK应用所占用的内存考虑？） 针对priv_size和data_room_size，结合l2fwd的例程和以下mempool/mbuf结构图，可以看出priv_size是算作mbuf中的一部分（猜测应该是修改mbuf结构后，需要加入的size大小？在二层加密例程中有使用，一般转发应该不用这个变量）。data_room_size参考例程填写即可 配置网口接下来说下rte_eth_dev_configure配置网口这个API，首先强调一下，调用此API，需要网口处于stop状态 int rte_eth_dev_configure(uint16_t port_id, uint16_t nb_rx_q, uint16_t nb_tx_q, const struct rte_eth_conf *dev_conf) port_id：网口id nb_rx_q：收包队列数（有几个转发核就需要有几个队列） nb_tx_q：发包队列数（有几个转发核就需要有几个队列） dev_conf：网口需要使能的offload特性、max_pkg_len等配置信息 简单说一下：1.这个API里头会调用rte_eth_dev_rx_queue_config和rte_eth_dev_tx_queue_config，去初始化一个可以存放queue结构的指针数组，而此指针数组被填充（queue被初始化）是在setup阶段，并且queue中填充desc(mbuf)，则是在dev_start中2.dev_conf这个结构需要对网卡特性有一定了解，才能把控好它（必要时，需要结合各款网卡的datasheet）。另外，在此API中，会通过rte_eth_dev_info_get（ops-&gt;dev_infos_get）获取不同网卡所支持的特性，并比较用户下发的conf，若用户下发了该网卡不支持的特性，将抛出错误。网卡特性是否使能，在DPDK中有点恶心的是，不同厂家维护的PMD并不统一。比如，Intel可能由于你配置的包过大，会在设备start的时候再去config一次网卡(开启scattert特性)，自动设置一些特性。而Mellanox就并不会这样，一切特性都需要你自己去配置，并不会帮你自动关联开启某特性。这点就导致，若上层框架直接调用DPDK的API，就有可能会出现比较凌乱的代码结构。比较合理的做法，应该是针对必要的APi，想办法再封装一层适配层 初始化/配置网口收包队列下面再说下，用于初始化网口收包队列的rte_eth_rx_queue_setup API吧 int rte_eth_tx_queue_setup(uint16_t port_id, uint16_t tx_queue_id, uint16_t nb_tx_desc, unsigned int socket_id, const struct rte_eth_txconf *tx_conf) port_id：网口id rx_queue_id：需要配置的收包队列id（nb_rx_q是几，就从0到几） nb_rx_desc：配置收包队列描述符个数（收包队列的大小） socket_id：指明收包队列以及sw_ring等数据结构，从哪个socket上申请（一般和mempool来源的cpu物理插槽id相同） rx_conf：需要生效的收包队列的配置 mp：指定收包队列中，mbuf来源的mempool 这个API的话，比较关键的就是会将mempool和rx_queue进行关联，后面调用start的时候，就会从这里关联的mempool中获取空间，填充rx_queue的收包描述符了（其实如果要深入的话，还可以探究下它sw_ring的玩法） 初始化/配置网口发包队列rte_eth_tx_queue_setup API用于初始化/配置网口发包队列，这个API，跟上面介绍的rte_eth_rx_queue_setup，大同小异，理论上来说它比收包还更简单，因为它无需和mempool关联 int rte_eth_tx_queue_setup(uint16_t port_id, uint16_t tx_queue_id, uint16_t nb_tx_desc, unsigned int socket_id, const struct rte_eth_txconf *tx_conf) port_id：网口id tx_queue_id：需要配置的发包队列id（nb_tx_q是几，就从0到几） nb_tx_desc：配置发包队列描述符个数（发包队列的大小） socket_id：指明发包队列数据结构所占内存，从哪个socket上申请（填写和收包队列相同的socket_id，性能最优） tx_conf：需要生效的发包队列的配置 启动网口/设备rte_eth_dev_start用于启动网口/设备，这个API主要干的活，就是根据之前config和setup所下发的配置，去start网口，会进行rx/tx queue的init和start。并且一般是在xxx_alloc_rx_queue_mbufs里，从mempool获取desc，填充到queue中 int rte_eth_dev_start(uint16_t port_id) port_id：网口id 总结DPDK提供的网口操作API远不止这些，rte_ethdev.c下定义的函数，均是其对外提供的，网口操作API接口。本文只是选出了一个DPDK APP所必须要存在的网口操作API，进行简单说明（若有出入，还请指正，谢谢）","categories":[],"tags":[{"name":"DPDK","slug":"DPDK","permalink":"http://avalonlz.github.io/tags/DPDK/"}]},{"title":"Docker使用笔记","slug":"DockerNotes","date":"2020-11-15T03:13:18.000Z","updated":"2020-11-15T04:07:17.159Z","comments":true,"path":"2020/11/15/DockerNotes/","link":"","permalink":"http://avalonlz.github.io/2020/11/15/DockerNotes/","excerpt":"记录下Docker的一些常用命令","text":"记录下Docker的一些常用命令 查看所有镜像docker images 查看所有容器docker ps -a 查看运行中的容器docker ps 开始/停止/重启容器docker start/stop/restart [容器名称] 删除容器docker rm -f [容器名称] 进入容器docker exec -it [容器名称] /bin/bash 容器外执行容器内的命令docker exec [容器名称] /bin/bash -c ‘xxx;xxx;’ 创建一个新容器，并运行docker run -it –privileged=true -u root –name lz（容器名称） -v /alz:/home/alz（映射路径） registry.me/lz-ci/compiler（镜像名称） /bin/bash 查看容器的挂载目录docker inspect [容器名称] | grep Mounts -A 20","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://avalonlz.github.io/tags/Docker/"}]},{"title":"DPDK驱动框架","slug":"DPDK_Driver_Frame","date":"2020-09-19T13:24:43.000Z","updated":"2020-12-13T15:15:47.517Z","comments":true,"path":"2020/09/19/DPDK_Driver_Frame/","link":"","permalink":"http://avalonlz.github.io/2020/09/19/DPDK_Driver_Frame/","excerpt":"从源码说明下DPDK驱动框架","text":"从源码说明下DPDK驱动框架既然有时间了，那就写点东西吧。 DPDK驱动框架先找下DPDK环境初始化中，与网卡驱动相关的几个函数，以这几个函数为入口，再进行深入分析● rte_bus_scan● rte_bus_probe rte_bus_scan先来看下rte_bus_scan这个函数： int rte_bus_scan(void) { int ret; struct rte_bus *bus = NULL; TAILQ_FOREACH(bus, &amp;rte_bus_list, next) { ret = bus-&gt;scan(); if (ret) RTE_LOG(ERR, EAL, &quot;Scan for (%s) bus failed.\\n&quot;, bus-&gt;name); } return 0; } 可以看到它是再遍历rte_bus_list这个链表，再分别各个bus的scan函数，这样的话就有三个疑问了● rte_bus_list这里面放了什么东西？● 元素是如何被放到rte_bus_list中的？● scan做了什么？ 先来看下rte_bus_list放了什么东西分析代码可以看到，注册了各种不同总线上的ops函数，包含：dpaa、fslmc、ifpga、pci、vdev以及vmbus，这里我们就重点关注pci吧 那么这一个个元素是如何被注册进rte_bus_list的呢，可以看到每个bus，都会调用RTE_REGISTER_BUS宏，而这个宏的定义就是调用了rte_bus_register函数，将不同bus注册到list上的。并且我们还可以看到RTE_REGISTER_BUS宏中使用的RTE_INIT_PRIO，其定义是如下： #define RTE_INIT_PRIO(func, prio) \\ static void __attribute__((constructor(RTE_PRIO(prio)), used)) func(void) 所以在main函数执行前，便会将rte_bus_list初始化完成 最后我们以pci scan为例，看下都做了些什么： -&gt;rte_pci_scan//遍历/sys/bus/pci/devices路径下的内容，并格式化路径名称 -&gt;pci_scan_one //获得该pci总线下，设备的vendor id、device_id以及当前所使用的驱动，并放入rte_pci_bus.device_list链表中，rte_pci_bus.device_list链表在RTE_REGISTER_BUS宏中就已经被初始化了，直接插入即可 rte_bus_proberte_bus_scan看完了，再看下rte_bus_probe，大概也就知道是调用不同bus的probe函数了，我们看下pci的probe做了些什么？ -&gt;rte_pci_probe -&gt;FOREACH_DEVICE_ON_PCIBUS(dev)//遍历rte_pci_bus.device_list链表中的dev -&gt;pci_probe_all_drivers -&gt;FOREACH_DRIVER_ON_PCIBUS(dr)//遍历rte_pci_bus.driver_list（我们好像还不知道这个list是做什么的，在哪被初始化的，跟一下看看） 可以看到这个list里放了各种dpdk pmd驱动的信息，并且用RTE_PMD_REGISTER_PCI宏，在main函数执行前，将dpdk的pmd driver信息，放入rte_pci_bus.driver_list中 -&gt;rte_pci_probe_one_driver -&gt;rte_pci_match//判断当前dev是否支持dpdk的pmd驱动，若不支持,则直接返回尝试下一个dpdk pmd -&gt;dr-&gt;probe//调用匹配到的dpdk pmd driver的probe函数 -&gt;rte_eth_dev_create//创建一个dpdk pmd driver -&gt;rte_eth_dev_allocate//从rte_eth_devices[RTE_MAX_ETHPORTS]链表里申请一个坑位，并填充一些信息 -&gt;ethdev_init//调用当前驱动的ini函数进行初始化 以上大概就是DPDK驱动框架的内容了，总的来说就是3个链表、1个数组，需要掌握：1、rte_bus_list2、device_list3、driver_list4、rte_eth_devices","categories":[],"tags":[{"name":"DPDK","slug":"DPDK","permalink":"http://avalonlz.github.io/tags/DPDK/"}]},{"title":"LLDP","slug":"LLDP","date":"2020-02-08T15:23:27.000Z","updated":"2020-02-10T09:55:17.968Z","comments":true,"path":"2020/02/08/LLDP/","link":"","permalink":"http://avalonlz.github.io/2020/02/08/LLDP/","excerpt":"LLDP用于发现该局域网内所有网络设备，探测网络拓扑。下面将简要介绍下LLDP协议，以及针对目前主流存在的LLDP开源软件进行分析","text":"LLDP用于发现该局域网内所有网络设备，探测网络拓扑。下面将简要介绍下LLDP协议，以及针对目前主流存在的LLDP开源软件进行分析 LLDP协议LLDP相关软件目前本人已知的开源LLDP软件包括：1、Ubuntu中的lldpd(https://github.com/vincentbernat/lldpd)2、Centos中的lldpad(https://github.com/jrfastab/lldpad)3、Open lldp(https://github.com/intel/openlldp) 这三款软件中，在github上看，还有在维护的就是lldpd了，所以将lldpd作为LLDP协议的试验软件，下面就将介绍如何在Centos下安装lldpd（本人的开发/测试环境是Centos7） 下载相关软件及其依赖首先，下载lldpd和libevent(https://github.com/libevent/libevent) 的源码（安装编译lldpd的时候需要libevent库），我下载的lldpd-1.0.5，依赖libevent-2.0.22这里下载zip或者git clone都可以 git clone --branch 1.0.5 https://github.com/vincentbernat/lldpd.git git clone --branch release-2.0.22-stable https://github.com/libevent/libevent.git 编译安装libevent下面先编译安装libevent（libevent不指定路径的话，默认安装到/usr/local/lib下） ./configure make make install 配置环境变量因为lldpd的configure是通过pkg-config，来检测系统是否含有相关依赖库的，所以在安装完libevent后，还需要配置下pkg-config的环境变量 export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig pkg-config --cflags libevent#检查一下，看下pkg-config是否找到了libevent 编译安装lldpd最后编译安装lldpd ./autogen.sh ./configure --enable-privsep=no #如果libevent有问题，check libevent会提示 make make install 最后在创建lldp指定的存放unix socket文件的路径 mkdir -p /usr/local/var/run/ 以上，便是lldpd的编译安装步骤（编译安装时注意lldpd的configure提示即可），接下来将介绍下lldpd的使用 lldpd的使用lldpd -d#测试下程序是否可以正常启动 systemctl start lldpd.service#若可以正常启动，则使用systemctl启动lldpd #启动后，可使用tcpdump抓取lldp数据包（在eth0口，每30s即可抓取到一个本机发出的lldp数据包） tcpdump -e -x -i eth0 ether dst 01:80:c2:00:00:0e -nn #还可以使用lldpcli查看本机维护的邻居表 lldpcli show neighbors #输出json格式的邻居表 lldpcli show neighbors -f json","categories":[],"tags":[{"name":"百科_网络","slug":"百科-网络","permalink":"http://avalonlz.github.io/tags/百科-网络/"}]},{"title":"Supervisor说明","slug":"Supervisor","date":"2020-02-08T10:15:57.000Z","updated":"2020-02-08T14:28:33.623Z","comments":true,"path":"2020/02/08/Supervisor/","link":"","permalink":"http://avalonlz.github.io/2020/02/08/Supervisor/","excerpt":"介绍下Supervisor进程监控工具","text":"介绍下Supervisor进程监控工具 安装使用pip安装： pip install supervisor 配置1、配置supervisor自身：生成一个默认配置 echo_supervisord_conf &gt; /etc/supervisor.conf 2、创建被监控程序配置文件存放路径 mkdir /etc/supervisor 3、修改配置文件中的最后两行，开放针对被监控程序的配置文件 [include] files = /etc/supervisor/*.ini 4、针对需要监控的进程，在/etc/supervisor中，创建单独的ini文件，方便管理（ini文件内容，参考/etc/supervisor.conf中;[program:theprogramname]，这一段的内容） [program:eventreport] directory=/home/lz/Desktop/GitHub/Practices/Python/Practice_event command=/usr/bin/python /home/lz/Desktop/GitHub/Practices/Python/Practice_event/inotify.py startsecs=1 startretries=3 autorestart=true autostart=true stderr_logfile=/tmp/event_report.log stdout_logfile=/tmp/event_report.log user=root 运行启动supervisor: supervisord -c /etc/supervisor.conf 启动supervisor cli控制台： supervisorctl -c /etc/supervisor.conf 以上便是supervisor整体的使用思路","categories":[],"tags":[{"name":"应用软件_Supervisor","slug":"应用软件-Supervisor","permalink":"http://avalonlz.github.io/tags/应用软件-Supervisor/"}]},{"title":"内存池实现","slug":"mempool","date":"2019-09-22T01:45:38.000Z","updated":"2019-09-22T02:54:21.359Z","comments":true,"path":"2019/09/22/mempool/","link":"","permalink":"http://avalonlz.github.io/2019/09/22/mempool/","excerpt":"好久没写代码了，弄个内存池找下想法（没加锁，暂不支持多线程）","text":"好久没写代码了，弄个内存池找下想法（没加锁，暂不支持多线程） 查找时间复杂度O(1)核心思想：横列数组用于存放不同内存块大小的内存池（可以看做是一个内存桶），纵列采用单链表的方式存放同一类内存块，直接pop和push此链表，已实现malloc和free时间复杂度均为O(1)的效率（内存块间无序的特性，支撑了此思想） 查找时间复杂度O(n)核心思想:横列数组用于存放不同内存块大小的内存池（可以看做是一个内存桶），纵列数组则用于存放相同内存块，及一类大小的内存池mempool_array.h: /************************************************************************* &gt; File Name: mempool_array.h &gt; Author:lizhong &gt; Mail:423810942@qq.com &gt; Instruction: ************************************************************************/ #ifndef _MEMPOOL_ARRAY_H #define _MEMPOOL_ARRAY_H typedef struct { unsigned char used:1; }mem_block_flag_t; //定义了具体的内存块地址和该块内存是否被使用 typedef struct { mem_block_flag_t *flag; void *addr; }mem_block_t; //定义了某种内存节点下有多少个内存块 typedef struct { unsigned int mem_block_size; unsigned int mem_block_array_size; mem_block_t *mem_block_array; }mem_pool_node_t; //定义了有多少种内存节点 typedef struct { unsigned int mem_pool_node_size; mem_pool_node_t* mem_pool_node; }mem_pool_t; mem_pool_t *mem_pool_init(unsigned int types, ...); void *malloc_from_mp(mem_pool_t *mp, unsigned int mem_block_size); void free_to_mp(void *addr); #endif mempool_array.c: /************************************************************************* &gt; File Name: mempool_array.c &gt; Author:lizhong &gt; Mail:423810942@qq.com &gt; Instruction: ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&lt;stdarg.h&gt; #include&quot;mempool_array.h&quot; mem_pool_t *mem_pool_init(unsigned int types, ...) { int i = 0; int j = 0; mem_pool_t *mp = NULL; mp = (mem_pool_t *)malloc(sizeof(mem_pool_t)); if(mp == NULL) return NULL; memset(mp, 0, sizeof(mem_pool_t)); mp-&gt;mem_pool_node_size = types; mp-&gt;mem_pool_node = (mem_pool_node_t *)malloc(sizeof(mem_pool_node_t) * types); if(mp-&gt;mem_pool_node == NULL) { free(mp); return NULL; } memset(mp-&gt;mem_pool_node, 0, sizeof(mem_pool_node_t) * types); va_list val = {0}; va_start(val, types); for(i = 0; i &lt; types; ++i) { unsigned int mem_block_array_size = 0; unsigned int mem_block_size = 0; mem_block_array_size = va_arg(val, unsigned int); mem_block_size = va_arg(val, unsigned int); mp-&gt;mem_pool_node[i].mem_block_array = (mem_block_t *)malloc(sizeof(mem_block_t) * mem_block_array_size); if(mp-&gt;mem_pool_node[i].mem_block_array == NULL) { free(mp-&gt;mem_pool_node); free(mp); va_end(val); return NULL; } memset(mp-&gt;mem_pool_node[i].mem_block_array, 0, sizeof(mem_block_t) * mem_block_array_size); mp-&gt;mem_pool_node[i].mem_block_array_size = mem_block_array_size; mp-&gt;mem_pool_node[i].mem_block_size = mem_block_size; mp-&gt;mem_pool_node[i].mem_block_array[0].flag = malloc((sizeof(mem_block_flag_t) + mem_block_size) * mem_block_array_size); memset(mp-&gt;mem_pool_node[i].mem_block_array[0].flag, 0, (sizeof(mem_block_flag_t) + mem_block_size) * mem_block_array_size); mp-&gt;mem_pool_node[i].mem_block_array[0].addr = mp-&gt;mem_pool_node[i].mem_block_array[0].flag + sizeof(mem_block_flag_t); for(j = 1; j &lt; mem_block_array_size; ++j) { mp-&gt;mem_pool_node[i].mem_block_array[j].flag = mp-&gt;mem_pool_node[i].mem_block_array[j - 1].flag + sizeof(mem_block_flag_t) + mem_block_size; mp-&gt;mem_pool_node[i].mem_block_array[j].addr = mp-&gt;mem_pool_node[i].mem_block_array[j - 1].addr + sizeof(mem_block_flag_t) + mem_block_size; printf(&quot;FUNCTION:%s, i:%d, j:%d, addr:%ld, flag:%ld\\n&quot;, __FUNCTION__, i, j, mp-&gt;mem_pool_node[i].mem_block_array[j].addr, mp-&gt;mem_pool_node[i].mem_block_array[j].flag); } } va_end(val); return mp; } void *malloc_from_mp(mem_pool_t *mp, unsigned int mem_block_size) { int i = 0; int j = 0; for(i = 0; i &lt; mp-&gt;mem_pool_node_size; ++i) { if(mp-&gt;mem_pool_node[i].mem_block_size == mem_block_size) { for(j = 0; j &lt; mp-&gt;mem_pool_node[i].mem_block_array_size; ++j) { if(mp-&gt;mem_pool_node[i].mem_block_array[j].flag-&gt;used == 0) { mp-&gt;mem_pool_node[i].mem_block_array[j].flag-&gt;used = 1; return mp-&gt;mem_pool_node[i].mem_block_array[j].addr; } } } } return NULL; } void free_to_mp(void *addr) { mem_block_flag_t *flag = NULL; flag = addr - sizeof(mem_block_flag_t); flag-&gt;used = 0; } mempool_main.c: /************************************************************************* &gt; File Name: mempool_u.c &gt; Author:lizhong &gt; Mail:423810942@qq.com &gt; Instruction: ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&quot;mempool_array.h&quot; int main(int argc, char *argv[]) { void *addr = NULL; mem_pool_t *mp = NULL; mp = mem_pool_init(2, 3, 16, 5, sizeof(char)); addr = malloc_from_mp(mp, 16); printf(&quot;%s addr:%ld\\n&quot;, __FUNCTION__, addr); memset(addr, 5, 16); free_to_mp(addr); printf(&quot;%s addr:%ld\\n&quot;, __FUNCTION__, addr); addr = malloc_from_mp(mp, 16); printf(&quot;%s addr:%ld\\n&quot;, __FUNCTION__, addr); addr = malloc_from_mp(mp, 16); printf(&quot;%s addr:%ld\\n&quot;, __FUNCTION__, addr); addr = malloc_from_mp(mp, 16); printf(&quot;%s addr:%ld\\n&quot;, __FUNCTION__, addr); addr = malloc_from_mp(mp, 16); printf(&quot;%s addr:%ld\\n&quot;, __FUNCTION__, addr); return 0; }","categories":[],"tags":[{"name":"轮子_C","slug":"轮子-C","permalink":"http://avalonlz.github.io/tags/轮子-C/"}]},{"title":"Vxlan","slug":"Vxlan","date":"2019-09-08T13:00:03.000Z","updated":"2019-09-08T14:49:53.913Z","comments":true,"path":"2019/09/08/Vxlan/","link":"","permalink":"http://avalonlz.github.io/2019/09/08/Vxlan/","excerpt":"深入学习下vxlan的玩法","text":"深入学习下vxlan的玩法 VTEPVTEP，即Vxlan隧道端点，可以是单独的硬件设备，也可以集合在软件中，主要作用就是封装、解封vxlan报文。VTEP成员需要知道自己下连所有终端（vm）的MAC地址，同时需要知道其他所有VTEP成员下所有终端的MAC地址表，其他终端MAC地址表是通过底层物理网络组播进行传播，一个VXLAN网络一个组播地址 VNIVNI（3个字节），即vxlan报文的网络标识符，用于隔离不同的网络（租户），不同的VNI网络间，不能直接进行源二层的通信（因为一个VNI对应了一个Vxlan的组播组） 报文格式由上图可知，vxlan报文，是在主机报文的UDP载荷字段中再嵌套一个Vxlan Header和其真实报文（两端VTEP通信的报文）实现的。其中Vxlan Header占了8个字节注：上图的UDP Header中的VXLAN Port指的就是UDP传输中的目的端口号，只不过在VXLAN报文中，又被称为VXLAN Port，一般为默认值4789（可以修改） vm arp请求及回应流程首先，明确一点，在传输过程中，将先以组播报文进行传输，对端收到后，再由对端VTEP进行其下联vm的广播，而回复数据包则是以单播的形式在underlay网络中进行传输 VM1——VTEP1——物理交换机——VTEP2——VM21、VM1使用广播发送ARP请求查找VM2的MAC地址2、VTEP1收到VM1的广播后，查找自己的MAC地址表，如果下联vm没有此mac地址，则将封装报文为VXLAN，内层VNI为100，外层目的地址为此VNI对应的组播地址，外层源IP为VTEP1地址。3、通过组播VTEP2接受到VTEP1的报文，解封装后。记录报文的内层VNI、外层源VTEP1的IP、内层MAC地址4、VTEP2通过广播将数据包广播到自己连接的vm5、VM2接受到ARP请求后，做出回应6、VTEP2接受到VM2的回应后，查找流表，发现需要发送给VTEP1，重新把数据包进行封装为VXLAN并以单播的形式发送给VTEP17、VTEP1收到回应后，记录内层VNI、外层源VTEP2的IP、内层VM2的MAC地址8、VTEP1解封装后转发给VM1。至此VM1收到了VM2的MAC地址 vm TCP/UDP数据传输流程vm间正常的数据传输，在underlay网络中都将以单播的形式进行 VM1——VTEP1——物理交换机——VTEP2——VM21、VM1给VM2发送了一个TCP/UDP报文2、VTEP1收到报文后检查VM1和VM2是否属于同一个VNI，（如果不属于将转发给VXLAN网关）检查后属于一个VNI，需要转发给VTEP23、VTEP1封装VXLAN报文以单播的形式发送给VTEP24、VTEP2收到报文后解封装，查找流表，找到vm2对应的端口，进行发送5、VTEP2单播的形式发送给VM2，至此一个报文发送完毕 注意：若不存在VXLAN网关设备，则此VXLAN网络中，只存在一个VNI和一个组播组","categories":[],"tags":[{"name":"百科_网络","slug":"百科-网络","permalink":"http://avalonlz.github.io/tags/百科-网络/"}]},{"title":"ioctl实验","slug":"ioctrl_test","date":"2019-09-01T04:00:47.000Z","updated":"2019-09-01T05:46:58.054Z","comments":true,"path":"2019/09/01/ioctrl_test/","link":"","permalink":"http://avalonlz.github.io/2019/09/01/ioctrl_test/","excerpt":"最近遇到比较多的问题同样的ioctl命令，对于有些网卡，执行此命令可以被up起来，对于某些网卡却无法被up起来，于是就研究了下ioctl命令","text":"最近遇到比较多的问题同样的ioctl命令，对于有些网卡，执行此命令可以被up起来，对于某些网卡却无法被up起来，于是就研究了下ioctl命令 问题为啥同样的ioctl命令对一些网卡生效，能将网卡up起来，而一些网卡却完全不感冒（内核未出现任何异常日志），无法被up起来 分析在网上查了些资料，发现ioctl命令最终调用的还是网卡驱动中的接口，那就很好理解了，因为驱动中没有提供相应接口（假设网卡固件已支持该up处理逻辑），导致ioctl无法调用到驱动中的up接口（驱动也没有日志提示说不支持），所以就导致了同样的ioctl对于一些网卡可以正常up操作，而一些网卡却不行（当然若驱动中支持了up接口，也还需要网卡固件同样也能支持才可以） 实验了解了以上大致原因后，自己写模块和用户态程序，验证一下即可，此处以字符设备为例（驱动分块设备、字符设备和网络设备，每类设备都有相应的驱动程序框架，按此框架，初始化相关结构体，关联相关处理函数即可） 内核驱动(ko模块)： /************************************************************************* &gt; File Name: lz_test.c &gt; Author:lizhong &gt; Mail:423810942@qq.com &gt; Created Time:Tue 27 Aug 2019 06:22:47 PM PDT &gt; Instruction: ************************************************************************/ #include&lt;linux/module.h&gt; #include&lt;linux/kernel.h&gt; #include&lt;linux/init.h&gt; #include&lt;linux/slab.h&gt; #include&lt;linux/fs.h&gt; #include&lt;linux/device.h&gt; #include&lt;asm/io.h&gt; MODULE_LICENSE(&quot;GPL&quot;); MODULE_AUTHOR(&quot;StayrealS&quot;); MODULE_DESCRIPTION(&quot;Driver as a lz test&quot;); #define DEVICE_NAME &quot;lz_test&quot; #define CLASS_NAME &quot;lz_test_module&quot; static int lz_test_ioctl(struct file* filp, unsigned int cmd, unsigned long arg); static int major_number; static struct class* test_module_class = NULL; static struct device* test_module_device = NULL; static const struct file_operations tmf = { .owner = THIS_MODULE, .unlocked_ioctl = lz_test_ioctl }; static int lz_test_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { switch(cmd) { case 0: printk(&quot;ioctl cmd is LZ_TEST_CL\\n&quot;); break; default: printk(&quot;ioctl cmd is other\\n&quot;); return -EINVAL; } return 0; } static int __init lz_test_init(void) { printk(&quot;start init lz_test ko\\n&quot;); major_number = register_chrdev(0, DEVICE_NAME, &amp;tmf); test_module_class = class_create(THIS_MODULE, CLASS_NAME); test_module_device = device_create(test_module_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME); printk(&quot;end init lz_test ko\\n&quot;); return 0; } static void __exit lz_test_exit(void) { printk(&quot;start uinit lz_test ko\\n&quot;); device_destroy(test_module_class, MKDEV(major_number, 0)); class_destroy(test_module_class); unregister_chrdev(major_number, DEVICE_NAME); printk(&quot;end unint lz_test ko\\n&quot;); } module_init(lz_test_init); module_exit(lz_test_exit); Makefile(注意指定清楚内核源码目录环境变量) MODULE_NAME := lz_test obj-m := ${MODULE_NAME}.o PWD := $(shell pwd) all: $(MAKE) -C $(KSRCDIR) M=$(PWD) clean: $(MAKE) -C $(KSRCDIR) M=$(PWD) clean 用户态程序(c文件)： /************************************************************************* &gt; File Name: lz_test_user.c &gt; Author:lizhong &gt; Mail:423810942@qq.com &gt; Created Time:Tue 27 Aug 2019 06:30:33 PM PDT &gt; Instruction: ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;math.h&gt; #include&lt;sys/ioctl.h&gt; #include&lt;fcntl.h&gt; #include&quot;lz_test_user.h&quot; int main(int argc, char *argv[]) { int fd = -1; fd = open(&quot;/dev/lz_test&quot;, O_RDWR); ioctl(fd, LZ_TEST_CL); printf(&quot;send ioctl cmd\\n&quot;); return 0; } 头文件： /************************************************************************* &gt; File Name: lz_test.h &gt; Author:lizhong &gt; Mail:423810942@qq.com &gt; Created Time:Tue 27 Aug 2019 06:21:34 PM PDT &gt; Instruction: ************************************************************************/ #ifndef _LZ_TEST_H #define _LZ_TEST_H #define LZ_TEST_CL 0 #endif 再编译下用户态程序。之后insmod加载内核驱动，再运行下用户态程序，就可以看到打印出的内核日志了，说明用户态的ioctl最后调用到了该模块注册的操作函数（内核如何注册上这个模块的tmf操作变量，这回就没分析了）","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"Mininet+OVS+ONOS搭建SDN仿真环境","slug":"Mininet-OVS-ONOS","date":"2019-03-05T12:14:33.000Z","updated":"2019-03-09T11:29:13.918Z","comments":true,"path":"2019/03/05/Mininet-OVS-ONOS/","link":"","permalink":"http://avalonlz.github.io/2019/03/05/Mininet-OVS-ONOS/","excerpt":"最近又开始了疯狂的学习模式，为了方便学习、开发、测试，有一套SDN仿真环境，就显得很重要了。如果是控制面的开发，不涉及性能问题，完全可以先在Mininet的环境下，写几个Deamon。本文，就记录下，使用Ubuntu如何搭建一套Mininet+OVS+ONOS的SDN仿真环境，注意，以下的操作都在普通用户权限下进行","text":"最近又开始了疯狂的学习模式，为了方便学习、开发、测试，有一套SDN仿真环境，就显得很重要了。如果是控制面的开发，不涉及性能问题，完全可以先在Mininet的环境下，写几个Deamon。本文，就记录下，使用Ubuntu如何搭建一套Mininet+OVS+ONOS的SDN仿真环境，注意，以下的操作都在普通用户权限下进行 Ubunut我这里选用的Ubuntu是ubuntu-18.04.2LTS(Bionic Beaver)版，下载链接如下：http://120.198.248.41/cache/releases.ubuntu.com/18.04/ubuntu-18.04.2-desktop-amd64.iso?ich_args2=30-05202509001074_56bfc1eb28abf9721328755ab0a40e58_10001002_9c89612dd0cbf9d69539518939a83798_99a52f5e2482f7b0f5af737b3e5b3518 注意：1、使用VM安装时，最好不要是简易安装系统（不过，不简易安装，好像也没多装啥工具，都需要后面apt安装）2、安装完后记得更新下apt源，可在清华开源镜像站下(https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/)，找到此ubuntu版本适合的源 安装MininetMininet是一款网络仿真软件，具体安装步骤如下（这个版本，带的是2.9.2的OVS） git clone git://github.com/mininet/mininet #先clone下来 git checkout 1969669f510a7443f58b27b1640884b06b6867d4 #转到2.3.0d4这个版本分支上 cd ./mininet/util ./install.sh -a #安装全部组件 mn --version #安装完成后，使用该命令，即可查看到其版本为2.3.0d4 解决JAVA依赖ONOS的安装，主要也是按照它wiki上所说的做（最新版的onos是要求使用bazel编译器了，所以，网上有些过时的安装教程就不可参考了）按wiki上说的，我们先安装下java依赖 sudo apt-get install software-properties-common -y &amp;&amp; \\ sudo add-apt-repository ppa:webupd8team/java -y &amp;&amp; \\ sudo apt-get update &amp;&amp; \\ echo &quot;oracle-java8-installer shared/accepted-oracle-license-v1-1 select true&quot; | sudo debconf-set-selections &amp;&amp; \\ sudo apt-get install oracle-java8-installer oracle-java8-set-default -y 安装bazel之后还需要装下bazel编译器。注意，wiki上说支持onos的最后一版bazel编译器版本是0.19.2（我这里用最新的0.23.1）。在https://github.com/bazelbuild/bazel/releases上找到bazel-0.23.1-installer-linux-x86_64.sh并下载，之后在执行（如果要跟换版本，也只需要下载相应版本的sh文件，再--user执行，并设置好环境变量即可）： ./bazel-0.23.1-installer-linux-x86_64.sh --user #设置环境变量 export PATH=&quot;$PATH:$HOME/bin&quot; 安装Karaf进入karaf的官网，下载apache-karaf-4.2.3该版本的源码（非二进制代码） cd /root mkdir Applications #再将源码解压至Applications目录下 编译ONOS之后，就可以使用bazel编译ONOS了下载ONOS源码，并编译 git clone https://gerrit.onosproject.org/onos sudo chmod -R 777 onos #开放此文件夹的权限 cd onos git checkout -b 2.0.0 #使用目前最新的onos发布版本 #配置下环境变量 export ONOS_ROOT=/home/lz/Desktop/ONOS/onos #保证能定位到onos文件夹即可 source $ONOS_ROOT/tools/dev/bash_profile #编译onos bazel build onos 测试ONOS之后，再测试下onos，看下是否成功编译了 #成功启动后，可以通过http://localhost:8181/onos/ui进行访问 #onos/rocks是默认的用户名和密码 bazel run onos-local -- clean debug 测试Mininet+ONOS1、首先，在ONOS的web界面中，开启openflow（openflow协议）和fwd（转发功能）应用（默认是开启的）2、之后，执行类似如下的命令sudo mn –custom ./custom/topo-2sw-2host.py –topo mytopo –controller remote,ip=127.0.0.1,port=66533、之后在ONOS的web界面，或后台LOG中，都能看到在mininet中创建的设备了 配置环境变量最后说下启动ONOS时，环境变量的配置，在~/.bashrc中加入如下命令 #配置bazel环境变量 export PATH=&quot;$PATH:$HOME/bin&quot; #配置ONOS环境变量 export ONOS_ROOT=/home/lz/Desktop/ONOS/onos source /home/lz/Desktop/ONOS/onos/tools/dev/bash_profile","categories":[],"tags":[{"name":"云计算","slug":"云计算","permalink":"http://avalonlz.github.io/tags/云计算/"}]},{"title":"Openstack与SDN","slug":"Openstack_SDN","date":"2019-03-03T03:48:34.000Z","updated":"2019-03-03T05:05:20.911Z","comments":true,"path":"2019/03/03/Openstack_SDN/","link":"","permalink":"http://avalonlz.github.io/2019/03/03/Openstack_SDN/","excerpt":"之前写过《OVS与DPDK》，这一篇可以看做是其更外层的框架图吧（假设使用的是Openstack开源云框架）","text":"之前写过《OVS与DPDK》，这一篇可以看做是其更外层的框架图吧（假设使用的是Openstack开源云框架）先简单总结下云计算、Openstack、OVS、DPDK直接的关系吧，大概是这样： 云计算--&gt;Openstack框架--&gt;Neutron模块--&gt;通过SDN实现--&gt;数据面：OVS或OVS+DPDK等 --&gt;控制面：ODL、ONOS等 大概就是这么个关系 接下来用图说明下Openstack架构（主要模块），以及Neutron与SDN Openstack架构（主要模块） Neutron与SDNNeutron和SDN的关系，我觉得应该是这样：SDN是Neutron的一种实现思想/框架（当然，只要你能管理虚拟机的网络，不用SDN的思想当然也没问题）。可以用于构建Neutron的SDN开源组件，则是OVS数据面+ODL、ONOS等控制面软件，具体关系如下图 总结由以上两图就可以总结出，最上层的云计算，到最底层的SDN控制面或数据面的关系了 因为主要是做Neutron这部分，所以Openstack中的其他模块，在此图就简略了下","categories":[],"tags":[{"name":"云计算","slug":"云计算","permalink":"http://avalonlz.github.io/tags/云计算/"}]},{"title":"OVS与DPDK","slug":"OVS_DPDK","date":"2019-02-17T13:24:43.000Z","updated":"2019-03-03T05:03:04.026Z","comments":true,"path":"2019/02/17/OVS_DPDK/","link":"","permalink":"http://avalonlz.github.io/2019/02/17/OVS_DPDK/","excerpt":"做个学习笔记，也算一只脚进了云计算的大门了","text":"做个学习笔记，也算一只脚进了云计算的大门了OVS是什么就不在说明了（软交换机），我学习的思路还是从整体到细节，从大到小。 未使用DPDK首先说下未使用DPDK时，OVS是怎样的一个东西吧。大概画了下OVS在单台云主机上的模型，如下图： 在单台主机上的众多虚拟机中，起着软交换的作用（想想你买的VPS，就能明白为啥需要OVS了） 然后是关于OVS内部的模块关系，以及未使用DPDK时的走包流程总的来说，组件还是很多的。刚接触，感觉有些组件的部分功能存在重叠。不过还没怎么玩过，所以不吐槽了，既然存在那一定有他的道理，只是“功力”不到，无法领会到罢了 下面还有一张主要模块，vswitchd和DataPath模块，未使用DPDK时的模块内部详细架构 使用DPDK当使用DPDK时，单台云主机上的OVS模型则变成下图：图中宿主机上的NIC网卡被DPDK托管，收到的包经过OVS，再被DPDK的vhost-user模块，发送至虚拟机上的DPDK的virtio-user模块。虚拟机上的回复包则相反（其中虚拟机上的virtio-user模块，可以替换成虚拟机内核原本就支持的virtio-net模块，这样的话在虚拟机中，数据包依然可以走内核协议栈）特别说明一点：在linux内核中已经实现了vhost-net和virtio-net，且DPDK的vhost-user可以和linux实现的virtio-net进行交互。相对于内核的vhost-net/virtio-net全面的功能，DPDK的vhost-user/virtio-user则更加注重性能","categories":[],"tags":[{"name":"云计算","slug":"云计算","permalink":"http://avalonlz.github.io/tags/云计算/"}]},{"title":"四层常见网络协议解析","slug":"Net-Protocol-Summed","date":"2018-12-30T14:37:40.000Z","updated":"2020-02-07T04:34:07.753Z","comments":true,"path":"2018/12/30/Net-Protocol-Summed/","link":"","permalink":"http://avalonlz.github.io/2018/12/30/Net-Protocol-Summed/","excerpt":"物理层、网络层、传输层、应用层，对这四层常见的协议，做一个关于报文格式的总结","text":"物理层、网络层、传输层、应用层，对这四层常见的协议，做一个关于报文格式的总结 物理层 （有的网络设备A用以太帧数据段的长度，作为mtu值，若对接网络设备B已以太帧+18Byte作为mtu，则就会出现对接网络设备A mtu为1600，设备B需要配置1618的mtu才可正常通讯的情况） 网络层 传输层","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"Linux内存管理","slug":"Linux_Memory_Manage","date":"2018-12-10T13:27:51.000Z","updated":"2018-12-30T14:28:59.440Z","comments":true,"path":"2018/12/10/Linux_Memory_Manage/","link":"","permalink":"http://avalonlz.github.io/2018/12/10/Linux_Memory_Manage/","excerpt":"断断续续的研究了一段时间的Linux内存管理，大概能理出个框架。不过Cache那部分还是有点不太确定了（手头这三本书，只有《深入浅出DPDK》对Cache有提及），所以若有不正确的地方，还需大家提醒纠正","text":"断断续续的研究了一段时间的Linux内存管理，大概能理出个框架。不过Cache那部分还是有点不太确定了（手头这三本书，只有《深入浅出DPDK》对Cache有提及），所以若有不正确的地方，还需大家提醒纠正 寻址方式从图中可以看出，在Linux上，采用了虚拟地址的方式（而不是真实的物理地址），尽可能的利用有限的物理地址空间，并且为了硬件平台的可移植性，巧妙的绕过x86架构的段机制，统一采用分页机制，进行内存管理 内存的访问先简单介绍下在Linux的内存管理中采取了哪些机制（这里顺便验证了下malloc是否可以申请到超过物理内存大小的空间，网上有人说可以，但是我实际测试却返回NULL，glibc中的malloc实现可能有答案，有空再去确认下）下面，将以“页表项的建立与物理内存的映射”流程图为例，将Linux上的内存管理机制串接起来（在某些场景下，某些管理机制也可能单独被使用，例如：交换机制，就会在kswapd守护进程中所使用）当获取到物理地址后，CPU又将如何获取到物理地址处存放的数据呢？这就需要了解Cache机制了 Cache 其他大页内存（为什么说大页内存速度快呢，原因就在于它的TLB是可以做到100%命中的）：大页内存，又可称为大页框内存。大页（框）的单位（2MB）越大，在Linux的分页机制中，页表项就越少，虚拟地址中的页内偏移量所占bit也就越多。正常页框单位是4KB，也就是页内偏移会占用虚拟地址的12个bit 可执行程序的加载流程（这部分也不太确定）：1、首先，通过mmap建立起磁盘中可执行程序和虚拟地址的映射关系（全映射）2、然后执行“内存管理中的，页表项的建立与物理内存的映射”中的流程，获得虚拟地址与物理地址的映射（访问虚拟地址时才执行）3、之后会检查该虚拟地址上是否有跟磁盘建立映射，若有，则将磁盘数据拷贝到物理地址页框中（访问虚拟地址时才执行）4、最后通过虚拟地址运行可执行程序（访问虚拟地址时才执行） 最后再说下mmap：1、mmap可以将磁盘地址映射至虚拟地址2、mmap可以将多个虚拟地址映射至同一物理地址（用户空间可以利用此来访问内核空间）（内核空间访问用户空间，需使用内核空间的“高端内存”）3、mmap可以将外设地址映射成虚拟地址（DPDK中用户态驱动，由此实现）","categories":[],"tags":[{"name":"百科_Linux","slug":"百科-Linux","permalink":"http://avalonlz.github.io/tags/百科-Linux/"}]},{"title":"单核多线程自旋锁至CPU假死","slug":"spin-clock","date":"2018-08-02T15:54:13.000Z","updated":"2018-12-10T13:12:43.492Z","comments":true,"path":"2018/08/02/spin-clock/","link":"","permalink":"http://avalonlz.github.io/2018/08/02/spin-clock/","excerpt":"今天填了个CPU假死的大BUG（其实本质还是违背了spin_lock的设计原则），赶快写篇相关的文章，记录下。先说下结论吧：在各种锁中，只有自旋锁处于busy-wait状态时，自旋着的线程/进程将获得大量时间片，占用大量cpu资源，从而引发该CPU假死状态（理论场景中其实还有可能获得锁（上锁的线程以龟速处理完逻辑，释放锁），所以在理论场景中，不能算是死锁（此时死锁条件=CPU假死+获得spin锁的线程需要处理实时的大流量任务））","text":"今天填了个CPU假死的大BUG（其实本质还是违背了spin_lock的设计原则），赶快写篇相关的文章，记录下。先说下结论吧：在各种锁中，只有自旋锁处于busy-wait状态时，自旋着的线程/进程将获得大量时间片，占用大量cpu资源，从而引发该CPU假死状态（理论场景中其实还有可能获得锁（上锁的线程以龟速处理完逻辑，释放锁），所以在理论场景中，不能算是死锁（此时死锁条件=CPU假死+获得spin锁的线程需要处理实时的大流量任务）） 需要了解的知识要解释CPU假死现象，首先需要知道以下知识点：使用默认参数创建的线程，系统是根据优先级来分配时间片的（而不是简单均分的），优先级高的分配的时间片越多，并且系统自身存在优先级的动态补偿特性（也就是说若线程A和线程B的用户指定的优先级相同（用户只能指定静态优先级），但是操作系统中的调度系统自身会会算出基于静态优先级的动态优先级，并且以该优先级来分配各自的时间片，这叫做优先级的动态补偿）（结合优先级的动态补偿，就可以解释自旋线程占用大量时间片的原因了） 具体运行模型首先该设备是多核机（但是做了核隔离，接手的QOS模块的模型是单核多线程）。导致CPU假死并升级为死锁的线程模型如下图（当初设计思想应该是想追求高性能，所以大量使用了自旋锁，谁知道最后偷鸡不成蚀把米）： CPU假死及升级为死锁的原因分析首先（CPU假死）：在某一时刻，线程1获得了spin锁A，接着处理它自身的任务，当线程1的时间片用完，此时该CPU被切换到了线程2。注意，此时线程1的任务还未处理完，spin锁A也还未被释放。在线程2中，线程2尝试获取spin锁A，显然它不能拿到锁A，于是它就进入了busy-wait状态，在该状态下，系统调度程序将其动态优先级调度到了最高（猜测，暂无法证实），使得线程2接下来获得了大部分的时间片（CPU大部分时间用于线程2的自旋），导致线程1只能分配到很少的时间片，这样一来，CPU很大一部分时间就进入了自旋空跑状态（CPU假死），线程1的处理时间变得更长其次（升级为死锁）：若线程1处理的是需要长时间处理的任务（实时的大流量或大数据量的任务），线程1将无法在少量的时间片内处理完这些任务，无法解锁，从而引发死锁 试验程序根据以上分析，编写了相关试验程序：https://github.com/avalonLZ/Practices/blob/master/C_and_CPP/C/%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F/test_spin_lock.c 1、使用gcc test_spin_lock.c -lpthread编译程序2、使用taskset -c 3 ./a.out将程序绑定在第3个核上运行3、使用top -H -d 0.1进入top，进入后并按1，显示每个CPU的状态等待一段时间，可以发现CPU3被跑满，并且线程2进入了自旋状态，此时观察线程1的TIME+选项，会发现它获得的时间片大量减少了，从而证实了以上分析（疑问点：线程2按道理它的S项应该在线程1的S项变成R时，变为S才对，但也可能是线程1的R时间太短，top中S字段的状态还未刷新吧），总的试验结果和分析吻合。 以后使用spin需要注意的地方单核多线程使用spin：1、在需要长时间处理的线程上使用pthread_spin_lock获取锁，其他实时性不强的线程需要使用tryspin2、或者谨遵spin的设计原则，上锁后保证只处理短时间的任务，保证在时间片用完前可以释放锁3、若需求中不可避免的有长时间的任务，则使用sleep-wait型的mutex锁代替spin锁4、或想其他办法代替，但总的来说spin的效率应该还是最高的 多核多线程使用spin：可以在需要上锁的地方都使用pthread_spin_lock或取锁，但要注意实时性强的线程需要绑定在独立的CPU上，否则就会出现CPU假死，甚至升级为死锁","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"利用OpenVPN实现...","slug":"OpenVPN-Ladder","date":"2018-07-09T00:41:28.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/07/09/OpenVPN-Ladder/","link":"","permalink":"http://avalonlz.github.io/2018/07/09/OpenVPN-Ladder/","excerpt":"此篇文章只为研究OpenVPN，不为其他目的","text":"此篇文章只为研究OpenVPN，不为其他目的早些时候有试过用OpenVPN去实现一些需求，但最终被墙。之前在项目上又用上了OpenVPN，实现的灵感也来自项目。下面具体介绍下如何修改，其实原理很简单。 OpenVPN的源码以及如何编译安装，都在之前的文章《OpenVPN的编译安装、配置、使用及注意事项》中详细说过，在这里就直接说需要修改哪些东西了 进入OpenVPN源码目录（解压完后进入xxx/openvpn-2.4.6/src/openvpn目录下）找到以下几个文件，并做相应修改（这里为什么这样修改只是提供了一个思路，大家灵活变通） 1、进入socket.c文件，找到link_socket_read_tcp,做如下修改: int link_socket_read_tcp(struct link_socket *sock, struct buffer *buf) { int len = 0; //add myself unsigned int i; if (!sock-&gt;stream_buf.residual_fully_formed) { #ifdef _WIN32 len = socket_finalize(sock-&gt;sd, &amp;sock-&gt;reads, buf, NULL); #else struct buffer frag; stream_buf_get_next(&amp;sock-&gt;stream_buf, &amp;frag); len = recv(sock-&gt;sd, BPTR(&amp;frag), BLEN(&amp;frag), MSG_NOSIGNAL); //add myself for(i = 0; i &lt;= BLEN(&amp;frag); ++i) { *(BPTR(&amp;frag) + i) ^= 0xff; } #endif if (!len) { sock-&gt;stream_reset = true; } if (len &lt;= 0) { return buf-&gt;len = len; } } if (sock-&gt;stream_buf.residual_fully_formed || stream_buf_added(&amp;sock-&gt;stream_buf, len)) /* packet complete? */ { stream_buf_get_final(&amp;sock-&gt;stream_buf, buf); stream_buf_reset(&amp;sock-&gt;stream_buf); return buf-&gt;len; } else { return buf-&gt;len = 0; /* no error, but packet is still incomplete */ } } 2、进入socket.h文件，找到link_socket_write_tcp_posix,做如下修改: static inline size_t link_socket_write_tcp_posix(struct link_socket *sock, struct buffer *buf, struct link_socket_actual *to) { //add myself unsigned int i; for(i = 0; i &lt;= BLEN(buf); ++i) { *(BPTR(buf) + i) ^= 0xff; } return send(sock-&gt;sd, BPTR(buf), BLEN(buf), MSG_NOSIGNAL); } 配置文件的话，只要在Server端增加以下两条即可： #重定向网关，因为需要另一边所有的服务器ip，所以直接将OpenVPN作为全局的隧道（可以理解为Shadowsocks中的全局代理） push &quot;redirect-gateway def1 bypass-dhcp&quot; #推送DNS，使得客户机可以正常解析域名 push &quot;dhcp-option DNS 108.61.10.10&quot; 之后在编译安装即可，这样修改后就可以支持tcp的链接了，速度比做代理快。在我机子上试出现推送DNS不生效的情况，没有时间去查具体原因，暂时需要用的时候就修改客户机的/etc/resolv.conf文件，手动切换DNS(不用了记得切换回来)，可以看出用OpenVPN的话DNS请求都是走加密隧道的，目的达成。","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"OpenVPN的编译安装、配置、使用及注意事项","slug":"OpenVPN","date":"2018-06-06T08:00:56.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/06/06/OpenVPN/","link":"","permalink":"http://avalonlz.github.io/2018/06/06/OpenVPN/","excerpt":"记录OpenVPN一些相关的知识点，先用一张图说下Openet、Teamviewer、Shadowsocks这三者实现的区别","text":"记录OpenVPN一些相关的知识点，先用一张图说下Openet、Teamviewer、Shadowsocks这三者实现的区别 Openet、Teamviewer、Shadowsocks三者实现区别OpenVPN的安装：我这里提供一套安装套件，是目前最新版的OpenVPN：链接：https://pan.baidu.com/s/1gg-AuCFgjAB2jn9ilapSTQ 密码：3h45里面有详细的ReadMe，按照ReadMe来安装即可 OpenVPN的配置：1、创建目录放置相关配置文件和证书： mkdir /etc/openvpn cp -rpf xxx/openvpn-2.4.6/sample/sample-config-files/server.conf #拷贝一个config模板到目录 cp -rpf easyrsa/ /etc/openvpn/easy-rsa #拷贝解压出的证书生成工具，随便放哪，放解压处也可以，最后在配置文件指定好路径就行 2、使用easyrsa生成相关证书和DH参数，制作根证书： ./easyrsa init-pki #初始化证书目录 ./easyrsa build-ca nopass #创建根证书，需要输入证书名，不和服务端和客户端证书同名即可。这步后issued文件夹下生成将会生成ca.crt，private文件夹下将会生成ca.key私钥文件，还有一些serial、reqs文件 ./easyrsa gen-dh #生成DH参数，用于密钥协商过程。这步后将生成dh.pem文件 3、制作服务端证书 ./easyrsa build-server-full lz_server nopass #lz_server是证书名称 ，issued文件夹下生成lz_server.crt证书，private文件夹下生成lz_server.key私钥 4、制作客户端证书 ./easyrsa build-client-full lz_client nopass #lz_client是证书名称，同理生成相关证书和私钥 5、服务端配置在此说明下，配置文件中的分号和井号都起到了注释的作用 #一个ip，client no to client模式下需要能从这个ip(主机)，Ping通两端主机 local ooo.xxx.ooo.xxx port 7333 proto tcp dev tun ca /etc/openvpn/easy-rsa/easyrsa3/pki/ca.crt cert /etc/openvpn/easy-rsa/easyrsa3/pki/issued/lz_server.crt key /etc/openvpn/easy-rsa/easyrsa3/pki/private/lz_server.key # This file should be kept secret dh /etc/openvpn/easy-rsa/easyrsa3/pki/dh.pem server 10.3.3.0 255.255.255.0 ifconfig-pool-persist ipp.txt #import需要访问的内网IP地址或网段 push &quot;route xxx.xxx.xxx.xxx 255.255.255.0&quot; ;client-to-client keepalive 10 120 #允许使用同一客户端证书多处登录 duplicate-cn cipher AES-256-CBC comp-lzo user nobody persist-key persist-tun status /var/log/openvpn-status.log log /var/log/openvpn.log verb 3 6、客户端配置 client dev tun proto tcp remote ooo.xxx.ooo.xxx 7333 resolv-retry infinite nobind persist-key persist-tun ca ca.crt cert lz_client.crt key lz_client.key remote-cert-tls server cipher AES-256-CBC comp-lzo verb 3 #myself add auth-nocache OpenVPN的使用 Client no to Client模式下：要求：在该模式下Server上的ip必须能ping通Client和另一端的主机（这是OpenVPN的原理决定的） Server端：按照以上步骤完成，直接使用./openvpn –config /etc/openvpn/server.conf就可以启动Server服务了 Client端：在Win下就安装压缩包中的OpenGUI，然后拷贝在Server上制作好的根证书、客户端证书和客户端私钥到Client上，并在client.ovpn中配置好路径，之后直接启动连接即可。连接成功后，便可以访问xxx.xxx.xxx.xxx 255.255.255.0。在Linux下则只需要吧Server的配置文件更换为Client的配置文件即可 Client to Client模式下：要求：在该模式下则要求各个Client可以路由到Server Server端：开启client-to-client选项，可以关闭push “route xxx.xxx.xxx.xxx 255.255.255.0” 选项，其他不做修改 Client端：可以不做修改 注意：1、Client no to Client 和 Client to Client两个模式可以同时存在，但是要需要注意当前网络环境是否真的可以同时满足这两个模式的要求。2、若存在多个Client则可以选择不同的Client使用不同的客户端证书和私钥（需要Server生成多个客户端证书和私钥）。或者在启动Server时加入–duplicate-cn启动选项","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"HTTPS(TLS/SSL)与加/解密","slug":"Crypt","date":"2018-05-13T13:26:10.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/05/13/Crypt/","link":"","permalink":"http://avalonlz.github.io/2018/05/13/Crypt/","excerpt":"最近由于工作需要，学习了下HTTPS（SSL/TLS）及加解密相关的知识，在此记录下。就最近的接触来看，挺多应用（加/解密）算法的实现都是基于OpenSSL来实现的，像下面要说的HTTPS，一般就可能用Nginx + OpenSSL来实现","text":"最近由于工作需要，学习了下HTTPS（SSL/TLS）及加解密相关的知识，在此记录下。就最近的接触来看，挺多应用（加/解密）算法的实现都是基于OpenSSL来实现的，像下面要说的HTTPS，一般就可能用Nginx + OpenSSL来实现 加解密相关算法总框图 SSL/TLS协议栈注：SSL位于表示层，会对应用层的HTTP所有部分进行加密 HTTPS的SequenceSimple版： Normal版：","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"移植GDB到Cavium","slug":"Move-GDB","date":"2018-04-24T07:08:27.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/04/24/Move-GDB/","link":"","permalink":"http://avalonlz.github.io/2018/04/24/Move-GDB/","excerpt":"开发机上已经有gdb了，不过同事说不能用tui（文本用户界面）功能，不太方便，所以最好再移植个。其实关键还是使能tui，以及使能tui后需要ncurses库支持。中途遇到几个错误，其实都是引用的头文件路径问题而已（交叉编译过程的makefile一般是不会错的，所以最大的问题也就是依赖和路径问题，耐心看错误，结合搜索引擎，一般都能解决）。既然做了，就简单记录下","text":"开发机上已经有gdb了，不过同事说不能用tui（文本用户界面）功能，不太方便，所以最好再移植个。其实关键还是使能tui，以及使能tui后需要ncurses库支持。中途遇到几个错误，其实都是引用的头文件路径问题而已（交叉编译过程的makefile一般是不会错的，所以最大的问题也就是依赖和路径问题，耐心看错误，结合搜索引擎，一般都能解决）。既然做了，就简单记录下 编译ncurses跟vim一样，gdb也需要ncurses这个依赖库，在移vim的时候已经编译过了，所以这里就不再编译了，直接拿来用 cp -rf ~/MoveVim/ncurses-5.8/* ~/MoveGDB/ncurses-5.8/ 下载相应版本的gdbgdb的下载可以到这里：http://ftp.gnu.org/gnu/gdb/因为板子上已经有7.6的了，所以我也就下了7.6的 wget http://ftp.gnu.org/gnu/gdb/gdb-7.6.tar.gz 然后解压 tar -zxvf gdb-7.6.tar.gz 进入解压目录，编写build脚本进行配置，生成Makefile cd vim build.sh #build.sh中填入如下内容，通用部分CC、CPPFLAGS、LDFLAGS #! /bin/sh ./configure --with-features=huge --enable-shared --prefix=/home/lizhong/MoveGDB/gdb-7.6/output --enable-tui CC=mips64-octeon-linux-gnu-gcc CPPFLAGS=-I/home/lizhong/MoveGDB/ncurses-5.8/output/include/ncurses LDFLAGS=-L/home/lizhong/MoveGDB/ncurses-5.8/output/lib --host=mips64-octeon-linux-gnu --with-tlib=ncurses 需要注意的是–enable-tui，因为我们主要是需要使用这个功能，所以要将它使能。之后执行该build脚本 chmod 777 ./build.sh ./build.sh #可以看见，已成功生成了Makefile，然后make make 这里应该会遇到问题，说找不到xxx头文件，我的解决方案就是用find找到那个文件（不是在ncurses里，就是在gdb这边，两边都找下），后来发现是在ncurses里，那就把它们cp过来 cp /home/lizhong/MoveGDB/ncurses-5.8/output/include/ncurses/* /home/lizhong/MoveGDB/gdb-7.6/gdb/ 然后还需要做一些修改，因为之前这些头文件的引用不同，可能是绝对路径，也可能是相对路径，也可能因为没有宏定义而没有引用，反正就是该下报错的文件就可以了（不要惧怕源文件），这种东西出错（有坑）是正常的，大胆改就行，修改完后再次make #先把之前生成的文件全删了。要先clean再distclean，否则就会先把Makefile删了，就没法make clean了 make clean make distclean #再make make make install 最后搞定了，在./output/bin目录下可以看到gdb和gdbserver，之后将这两个文件拷贝到开发板的/usr/bin目录下，覆盖原文件，就OK了 注意：gdb是依赖一些动态库的，所以可能移植后还需要一些动态库，不过都在ncurses里面了，需要啥就移啥，然后再加入环境变量就可以了，这里就不细说了，如果按上一篇文章说的，已经移植过vim，那就已经有了那些动态库","categories":[],"tags":[{"name":"嵌入式_Linux","slug":"嵌入式-Linux","permalink":"http://avalonlz.github.io/tags/嵌入式-Linux/"}]},{"title":"移植Vim到Cavium","slug":"Move-Vim","date":"2018-04-18T09:34:15.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/04/18/Move-Vim/","link":"","permalink":"http://avalonlz.github.io/2018/04/18/Move-Vim/","excerpt":"为了练手（也为了在Cavium下修改文件方便点），将vim交叉编译，移植到Cavium上。参考了网上两篇文件，再此记录下","text":"为了练手（也为了在Cavium下修改文件方便点），将vim交叉编译，移植到Cavium上。参考了网上两篇文件，再此记录下 下载两个源码包，一个是vim的，一个是它依赖的库vim和ncurses:百度云盘地址：https://pan.baidu.com/s/1aUvv1pyjC_tYhFFa8yJ-xw密码：t27m 先对vim依赖的ncurses进行交叉编译tar -xvf ncurses-5.8 cd ncurses-5.8/ 然后在解压目录下建一个build.sh脚本，方便执行./configure配置命令 #! /bin/sh ./configure --prefix=/home/lizhong/MoveVIM/ncurses-5.8/output --host=mips64-octeon-linux-gnu CC=mips64-octeon-linux-gnu-gcc --without-cxx --without-cxx-binding --without-ada --without-manpages --without-progs --without-tests --with-shared 注意：–prefix是需要编译生成的文件的存放路径,–host是指定主机的系统,CC就是指定交叉编译器了，剩下的参数比较有针对性，可以通过./configure –help来查看相关说明 保存此文件,再提升下权限 chmod 777 build.sh 执行 make make install 可以看到在output目录下，生成了相关文件（动态链接库等）： [lizhong@localhost ncurses-5.8]$ cd output/ [lizhong@localhost output]$ ls bin include lib share [lizhong@localhost lib]$ ls -l total 7244 -rw-r--r--. 1 lizhong lizhong 207140 Apr 17 17:58 libform.a -rw-r--r--. 1 lizhong lizhong 1079288 Apr 17 17:58 libform_g.a lrwxrwxrwx. 1 lizhong lizhong 12 Apr 17 17:58 libform.so -&gt; libform.so.5 lrwxrwxrwx. 1 lizhong lizhong 14 Apr 17 17:58 libform.so.5 -&gt; libform.so.5.8 -rwxrwxr-x. 1 lizhong lizhong 108435 Apr 17 17:58 libform.so.5.8 -rw-r--r--. 1 lizhong lizhong 101532 Apr 17 17:58 libmenu.a -rw-r--r--. 1 lizhong lizhong 548440 Apr 17 17:58 libmenu_g.a lrwxrwxrwx. 1 lizhong lizhong 12 Apr 17 17:58 libmenu.so -&gt; libmenu.so.5 lrwxrwxrwx. 1 lizhong lizhong 14 Apr 17 17:58 libmenu.so.5 -&gt; libmenu.so.5.8 -rwxrwxr-x. 1 lizhong lizhong 45387 Apr 17 17:58 libmenu.so.5.8 -rw-r--r--. 1 lizhong lizhong 766984 Apr 17 17:58 libncurses.a -rw-r--r--. 1 lizhong lizhong 3846990 Apr 17 17:58 libncurses_g.a lrwxrwxrwx. 1 lizhong lizhong 15 Apr 17 17:58 libncurses.so -&gt; libncurses.so.5 lrwxrwxrwx. 1 lizhong lizhong 17 Apr 17 17:58 libncurses.so.5 -&gt; libncurses.so.5.8 -rwxrwxr-x. 1 lizhong lizhong 424626 Apr 17 17:58 libncurses.so.5.8 -rw-r--r--. 1 lizhong lizhong 41714 Apr 17 17:58 libpanel.a -rw-r--r--. 1 lizhong lizhong 213232 Apr 17 17:58 libpanel_g.a lrwxrwxrwx. 1 lizhong lizhong 13 Apr 17 17:58 libpanel.so -&gt; libpanel.so.5 lrwxrwxrwx. 1 lizhong lizhong 15 Apr 17 17:58 libpanel.so.5 -&gt; libpanel.so.5.8 -rwxrwxr-x. 1 lizhong lizhong 18125 Apr 17 17:58 libpanel.so.5.8 lrwxrwxrwx. 1 lizhong lizhong 13 Apr 17 19:22 libtinfo.so -&gt; libtinfo.so.5 lrwxrwxrwx. 1 lizhong lizhong 15 Apr 17 19:22 libtinfo.so.5 -&gt; libncurses.so.5 lrwxrwxrwx. 1 lizhong lizhong 17 Apr 17 17:58 terminfo -&gt; ../share/terminfo 注意：这里需要做两个软连接文件（软连接，其实就是win下的快捷方式），在lib文件夹下，执行 ln -s libncurses.so.5 libtinfo.so.5 ln -s libtinfo.so.5 libtinfo.so 就放在lib文件夹下就好，后面编译vim的时候会找这两个文件 编译vim下面就可以开始编译vim了，这个还是挺折腾的，进入vim解压出的目录 [lizhong@localhost MoveVIM]$ cd vim74/ 执行下面语句： ./configure --with-features=huge --disable-gui --without-x --disable-selinux --disable-acl --disable-gpm --enable-cscope --enable-sniff --enable-multibyte CC=mips64-octeon-linux-gnu-gcc CPPFLAGS=-I/home/lizhong/MoveVIM/ncurses-5.8/output/include/ncurses LDFLAGS=-L/home/lizhong/MoveVIM/ncurses-5.8/output/lib --host=mips64-octeon-linux-gnu vim_cv_toupper_broken=no vim_cv_tty_group=root vim_cv_tty_mode=0620 vim_cv_terminfo=yes vim_cv_tgetent=zero vim_cv_stat_ignores_slash=yes vim_cv_memmove_handles_overlap=yes vim_cv_getcwd_broken=no vim_cv_terminfo=yes --with-tlib=ncurses 之前也写了这个的build.sh，但是一直报错，最后一点点排查问题，最后这个语句可以成功配置。简单说下这些配置参数（同样在./configure –hlep下也可以看到这些参数说明）–with-features=huge#保留大部分特性编译–disable-selinux#这个一定要加，因为在这个vim源码中没有selinux相关的代码，不加的话会编译出错CC#指定交叉编译工具–with-tlib=ncurses#指定库PPFLAGS#指定库路径LDFLAGS#指定库路径–host#指定主机系统 配置完成后会生成config.mk等文件，不过ls是看不到的，如果需要清空配置，需要执行make distclean该条命令 编译： make 注意按以上步骤进行交叉编译时，有一步会出现找不到某个头文件的错误（具体忘了是编译哪一个出问题了），原因在于那个头文件就在当前目录，而不在它指定的目录下，所以将那个出错的.c文件引用的头文件进行修改（改成#include “xxxx.h”）就可以正常编译了。 迁移vim编译完成后，在该路径的src/文件夹下，可以看到vim。下面，将编译好的vim以及一些依赖的文件移入Cavium开发机中，具体如下1、将ncurses编译完成的output文件夹下,lib文件夹中的内容,全部拷贝到开发机的/usr/lib/目录下(需要注意的是拷贝至开发机下的文件权限会被改变，需要对比编译机下的文件进行权限修改。先提权限为775，再做软链接) 2、将ncurses编译完成的output文件夹下,share文件夹中的内容，全部拷贝到开发机的/usr/share目录下(这里可以不用改变权限) 3、再将vim编译完成后的，src中的vim可执行程序，拷贝到开发机的/usr/sbin目录下，并将其权限提升为777 4、注意，vim的运行需要一些动态链接库，所以需要配置环境变量，在/etc/profile中加入/usr/lib这个动态链接库的路径 5、最后将vim的配置文件拷贝到开发机的~/路径下，注意需要将名字改为.vimrc（最好找个“干净”的vimrc） 至此完成了vim的移植操作","categories":[],"tags":[{"name":"嵌入式_Linux","slug":"嵌入式-Linux","permalink":"http://avalonlz.github.io/tags/嵌入式-Linux/"}]},{"title":"Shell笔记","slug":"Shell-Nodes","date":"2018-04-10T04:58:47.000Z","updated":"2020-12-13T13:59:16.502Z","comments":true,"path":"2018/04/10/Shell-Nodes/","link":"","permalink":"http://avalonlz.github.io/2018/04/10/Shell-Nodes/","excerpt":"想把Linux玩溜，怎可缺少Shell这个技能点呢。把它归在计算机语言里吧，毕竟也是种脚本语言（虽然它也被看做是一个应用程序）","text":"想把Linux玩溜，怎可缺少Shell这个技能点呢。把它归在计算机语言里吧，毕竟也是种脚本语言（虽然它也被看做是一个应用程序） 需注意点1、在Shell中数字0和1并不代表真假2、在Linux命令中-o这类表示选项，选项后紧跟着选项的参数。并且，不带选项的参数可以写在一起 脚本调试方法sh/bash -x [脚本名称] 常用命令read variable：等待用户输入，并将输入存放于variable中，回车为输入结束 seq 结束值：执行该语句，将以默认步长，从1开始递增到结束值 grep： -v反向过滤，表示过滤除xxx以外的内容 -q过滤后非空的话则返回0，否则返回1 -o部分匹配，并截取，输出，匹配-o之后的内容，但只要包含了这些内容就会被匹配，最后再截取这部分内容，输出到终端页面 -i表示不区分大小写匹配 -E表示或匹配，grep -E “error|drop”，匹配含有error或drop字符串的行，并输出 “\\&lt;>“完全匹配，grep “\\“，表示需要匹配到xxx，xxx前后可以是空格或者特殊字符 正则表达式（https://man.linuxde.net/docs/shell_regex.html）：grep “^eth[0-9]+$”，表示匹配eth开头并且以数字结尾的字符串。注意，如果加了-E参数，则grep表示使用扩展正则表达式(之前的匹配语句，将等价于^eth[0-9]+$)， awk: -F以某字符或符号进行分割，常见用法awk -F “2” ‘{print $1}’，表示用字符2进行分割，并输出第一部分 cut： -d “x” -f 1表示以字符x作为分隔符，并输出第一部分 解释器：.sh文件开头一般都会有下面这句 #! /bin/bash： 目的是为了告诉系统，该脚本是使用了bash这一个解释器（还存在多种解释器，但一般bash最常用） 注释：单行注释：在行开头使用’#’字符，进行单行注释多行注释（块注释）： :&lt;&lt;BLOCK 被注释的内容... BLOCK echo命令：用于向窗口输出文本 echo &quot;lz&quot;若文本中需要使用转义字符，echo需要加-e参数 echo -e &quot;lz\\nlz&quot; 变量： 变量前不加‘$’字符 定义一个变量的时候就应该赋初值，且变量与等号之前不可以有空格 my_age=24 读取变量时，需要在变量名前加入’$’符号(写入时不要要加)，并且最好在变量左右两边，加入’{}’符号，以便解释器识别变量边界 echo &quot;my age is ${my_age}&quot; 只读变量可以使用readonly进行申明 #只读变量，被申明后，将不可以有再次被赋值操作，否则运行时会报错 my_age=24 readonly my_age 可以使用unset关键字删除变量，变量被删除后，将不能继续使用，且unset关键字不能删除只读变量 unset my_age 运行shell时，会同时存在3种变量：局部变量（程序员在shell脚本中，定义的仅在当前脚本中有效的变量）、环境变量（运行shell所需要的系统配置的环境变量，必要时也可以在shell脚本中进行定义）、shell变量（由shell脚本自身设置的特殊变量，shell变量中，有一部分是环境变量，有一部分是局部变量） 字符串： 单引号：1、在单引号中的任何字符都会原样输出，所以在单引号中读取/写入变量是无效的2、在单引号中嵌套单引号，若里层单引号中的内容含有变量，该变量会被读取。 lz=&#39;yyy&#39; echo &#39;12&#39;35${lz}4&#39;12&#39; &gt;&gt;1235yyy412 双引号：1、双引号中可以读取变量2、双引号中可以存在转义字符 name=&#39;lz&#39; namestr1=&quot;hello,${name}!&quot; namestr2=&quot;hello,&quot;${name}&quot;!&quot; namestr3=&quot;hello,&quot;$name&quot;!&quot; echo $namestr1 $namestr2 $namestr3 &gt;&gt;hello,lz! hello,lz! hello,lz! 获取字符串长度：可以使用‘#’字符来获取字符串长度 lz=&apos;yyy&apos; echo ${#lz} &gt;&gt;3 提取子字符串： stringstr=&quot;hello lz&quot; echo ${string:6:8} &gt;&gt;lz 查找字符的位置： stringstr=&quot;hello lz&quot; #下句是反引号而不是单引号 echo `expr index &quot;${stringstr}&quot; l`\\ 重定向：>:输出重定向 #输出1到ip_forward文件中，如果ip_forward文件存在则清空该文件，再更新内容。若不存在，则创建再更新内容 echo 1 &gt; /proc/sys/net/ipv4/ip_forward >&gt;:输出追加重定向 #输出&quot;lz&quot;到test.txt文件夹，若test.txt文件存在，则在最后另起一行，追加输入字符串&quot;lz&quot;。若文件不存在，则创建再更新内容 echo lz &gt;&gt; /home/lz/test.txt #重定向，并且不在末尾添加换行符 echo -n lz &gt; /home/lz/test.txt echo -n lz &gt;&gt; /home/lz/test.txt 数组 定义数组 #数组名=(值1 值2....) arrayone=(1 2 3 &apos;lz&apos;) #echo ${arrayone[@]}可以按角标递增顺序输出数组内的所有元素 echo ${arrayone[@]} &gt;&gt;1 2 3 lz #或者 arrayone=( 1 2 3 &apos;lz&apos; ) #也可以单独定义数组中的元素，且可以不按角标增长顺序 arrayone[0]=1 arrayone[3]=&apos;lz&apos; echo ${arrayone[@]} &gt;&gt;1 lz 获取数组长度 lz=(1 2 3) echo ${#lz[@]} &gt;&gt;3 数组合并 l1=(1 2 3) l2=(4 5 6) l3=(${l1[@]} ${l2[@]}) 或 l1+=(${l2[@]}) 从命令行向shell脚本传递参数 还有些常用参数：$$：脚本运行的当前进程ID号$!：后台运行的最后一个进程的ID号$-：显示Shell使用的当前选项，与set命令功能相同（没理解） $?：显示最后命令的退出状态，0表示没有错误，其他任何值表名有错误，例： #若编译成功则提示&quot;compile successfully&quot; echo gcc -o hello hello.c if [ $? -eq 0 ] then echo &quot;compile successfully&quot; else echo &quot;compile fail&quot; fi 运算符 其他运算符和其他语言一样需要注意的地方：1、乘号(*)前需要加反斜杠(\\)才能作为乘号使用2、mac中的shell的expr语法是$((表达式))，此处表达式中的 ““ 不需要转义符号 “\\” `lz=expr $((23))`echo ${lz} &gt;&gt;6 关系运算符（重要）-eq：检测两数是否相等，相等返回true，与shell运算符中的==号一样-ne：检测两数是否不等，不等返回true，与shell运算符中的!=号一样-gt：检测左边的数是否大于右边的，如果是，返回true-lt：检测左边的数是否小于右边的，如果是，返回true-ge：检测左边的数是否大于等于右边的，如果是，返回true-le：检测左边的数是否小于等于右边的，如果是，返回true例： val=${1} +${2} #和是否等于3 if [ ${val} -eq 3 ] then echo &quot;${1} + ${2} == 3&quot; else echo &quot;${1} + ${2} != 3, == ${val}&quot; 布尔运算符！：非运算，表达式为true则返回false，否则返回true-o：或运算，有一个表达式为true则返回true-a：与运算，两个表达式都为true才返回true例： if [ 1 -gt 0 -o 0 -gt 1 ] then echo &quot;true&quot; else echo &quot;false&quot; if &gt;&gt;true 逻辑运算符&amp;&amp;：逻辑与||：逻辑或逻辑运算符和上面的布尔运算符的-o和-a的用法相同 字符串运算符（重要）=或==：检测两个字符串是否相等，相等返回true!=：检测两个字符串是否不等，不相等返回true-z：检测字符串长度是否为0，为0返回true-n：检测字符串长度是否为0，不为0返回true${a}：搭配if语句可以检测字符串a是否为空，不为空，返回true例： str1=&quot;&quot; if [ ${str1} ] then echo &quot;字符串不为空&quot; else echo &quot;字符串为空&quot; fi if [ -z ${str1} ] then echo &quot;字符串长度为0&quot; else echo &quot;字符串长度不为0&quot; fi &gt;&gt;字符串为空 &gt;&gt;字符串长度为0 文件测试运算符（重要）-b：检测文件是否是块设备文件，如果是，则返回true-c：检测文件是否是字符设备文件，如果是，则返回true-d：检测文件是否是目录，如果是，则返回true-p：检测文件是否是有名管道，如果是，则返回true-f：检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回true -g：检测文件是否设置了SGID位，如果是，则返回true-k：检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回true-u：检测文件是否设置了SUID位，如果是，则返回true -r：检测文件是否可读，如果是，则返回true-w：检测文件是否可写，如果是，则返回true-x：检测文件是否可执行，如果是，则返回true -s：检测文件是否为空（文件大小是否大于0），不为空，则返回true-e：检测文件（包括目录）是否存在，如果是，则返回true例： filedir=&quot;/home&quot; if [ -d ${filedir} ] then echo &quot;这是目录&quot; else echo &quot;这不是目录&quot; fi &gt;&gt;这是目录 echo（该命令会自动添加换行符）（可以理解为只是用来输出字符串的，不需要输出时，可以不使用此命令，当printf一样用就好）1、-e：开启转义，例： echo -e &quot;hello world \\r\\nlz&quot; &gt;&gt;hello world &gt;&gt;lz 2、原样输出字符串，不进行转义或取变量，使用单引号： name=&quot;lz&quot; #注意，是单引号 echo &apos;${name}\\r\\n&apos; &gt;&gt;${name}\\r\\n echo -e &apos;${name}\\r\\nlz&apos;#开启转义 &gt;&gt;${name} &gt;&gt;lz 3、显示结果定向至文件： #在home路径下，重写test.txt文件 echo &quot;hello world&quot; &gt; /home/test.txt 4、显示命令执行结果 #注意，是反引号，而不是单引号 echo `date` &gt;&gt;输出当前时间和日期 #将时间和日期追加输出至date.txt文件中 echo `date` &gt;&gt; /home/date.txt printf(不会自带换行符)Shell中的printf和C中的差不多，跟echo的差别也就是，printf主要用在格式化输出，例： #%-10s表示左对齐10个字符，不足10个字符，自动补空格，超过10个字符，则全显示 printf &quot;%-10s %-8s %-4s\\r\\n&quot; 姓名 性别 年龄 printf &quot;%-10s %-8s %-4d\\r\\n&quot; 李人 男 24 printf &quot;%-10s %-8s %-4d\\r\\n&quot; 李人人 男 24 printf &quot;%-10s %-8s %-4d\\r\\n&quot; 李人人人 男 24 testtest命令，常和if搭配使用，一般使用正常的if语句即可，可以不关注test 流程控制1、if else #将then和fi看做if语句的花括号（{}）即可 if condition then command else command fi #注意，最后只要一个fi即可 if condition then command elif condition then command else command fi # 简化版，[]中的表达式为真时，输出exec sueecss [ $? -eq 0 ] &amp;&amp; echo &quot;exec success&quot; # 多条件判断,如果lz等于yyy并且lz1等于xxx,则输出ok if [[ x&quot;${lz}&quot; == x&quot;yyy&quot; ]] &amp;&amp; [[ x&quot;${lz1}&quot; == x&quot;xxx&quot; ]]; then echo &quot;ok&quot; fi 2、for循环想循环一定次数，可以使用关键字seq实现，例： #seq，默认从1开始，且步长为1，seq 3 4 100 从3开始，步长为4，到100 for var in `seq 100` do command done #var依次为item1、item2...itemN，按此进行循环 for var in item1 item2 ...itemN do command done #var依次为str的下角标所对应的元素，按此进行循环 for var in str do command done #对执行该脚本时输入的参数进行遍历 for var in $* do command done #无线循环 for (( ; ; )) #结合数组，遍历数组 lz=(&apos;f&apos; &apos;y&apos; &apos;i&apos;) for element in ${lz[@]}; do echo &quot;${element}&quot;; done &gt;&gt;f &gt;&gt;y &gt;&gt;i 3、while循环 while ((condition)) do command done #例 var=89 while ((var &lt; 100)) do echo -e &quot;${var} \\c&quot; let var++ done #无限循环 while :#或 while true do command done 4、until循环：until循环执行一系列命令，直到条件为true时为止，写法： until condition do command done 5、case语句：case语句为多选择语句，可以用case语句进行一个值匹配，写法： case 值 in 1模式/值) command ... ;; 2模式/值) command ... ;; *) command ;; ... esac 在Shell的case中，取值可以为变量或常数，若匹配上某模式或值时，将执行该段语句，到;;结束。并且匹配后，不会再继续向下执行(和C不同)。若无任何一值匹配时，则可使用星号通配（相当于default） 6、break，continue语句，在Shell中同样适用，用法与C相同 函数在Shell中函数的例子（带参数）： functest() { echo &quot;run functest function&quot; echo &quot;the first param is $1&quot; } functest 1 2 3 输入/出的重定向（重要）因为Shell主要是用来写脚本的，操作一些文件啥的，所以重定向还是很重要的command &gt; file：将输出重定向到filecommand &lt; file：将输入重定向到filecommand &gt;&gt; file: 将输出以追加方式重定向到file 下面这几个目前还不是很理解n &gt; file：将文件描述符为n的文件重定向到filen &gt;&gt; file：将文件描述符为n的文件以追加方式，重定向到filen &gt;&amp; m：将输出文件m和n合并n &lt;&amp; m：将输入文件m和n合并&lt;&lt;tag：将开始标记tag和结束标记tag之间的内容作为输入 注意：一般情况下，每个linux命令运行时，都会打开三个文件：标准输入文件(stdin)，文件描述符为0，默认从stdin读取数据标准输出文件(stdout)，文件描述符为1，默认向stdout输出数据标准错误文件(stderr)，文件描述符为2，Shell脚本报错，会向stderr流中写入错误信息其中stdout和stderr默认都是向屏幕输出的默认情况下，command &gt; file会将stdout重定向到file默认情况下，command &lt; file会将stdin重定向到file如果希望stderr重定向到file，则： command 2 &gt; file #追加 command 2 &gt;&gt; file 如果希望将stdout和stderr合并后重定向到file，则： command &gt; file 2&gt;&amp;1 如果希望对stdin和stdout都重定向，则： #将command命令的输入stdin重定向到file1，输出stdout重定向到file2 command &lt; file1 &gt;file2 Here Document（重要）Here Document是Shell中的一种特殊的重定向方式，用来将输入重定向到一个交互式Shell脚本或程序，写法： #将两个delimiter中的内容(document)作为命令的输入传递给command #注意这里是命令的输入，也就是说，这个命令要求输入，才有用，并不是指紧跟在命令后的输入参数 command &lt;&lt; delimiter document delimiter #例 mkdir &lt;&lt; EOF testdir EOF /dev/null如果希望执行某命令后，不在屏幕或文件中进行输出，则可以将command的输出重定向到/dev/null下，写法： command &gt; /dev/null #屏蔽标准输出和错误输出 command &gt; /dev/null 2&gt;&amp;1 包含Shell文件主要是指，可以将Shell文件进行相互应用，例： #在1.sh中(可以不升级成执行权限) name=&quot;lz&quot; #在2.sh中 #包含1.sh文件，注意./1.sh是path路径 . ./1.sh echo &quot;my name is ${name}&quot; &gt;&gt;my name is lz 交互脚本如果需要对某个应用程序进行一些交互操作，这里提供几种方式1、利用重定向，将输入重定向至某个文件或某块文档，但不能在交互的时候使用条件语句和循环语句2、使用“|”管道，缺点和上面相同3、使用expect库此处推荐使用expect库，在ubuntu下直接apt-get install expect即可，以下例子为使用expect库对ftp应用程序进行交互操作（./ftp_put.sh） #! /usr/bin/expect set openflag 1 set drthost 192.168.175.1 set localfile ./1.iso set fcount 0 #使expect语句永久等待条件成立 set timeout -1 spawn ftp -n send &quot;open ${drthost}\\r&quot; send &quot;user anonymous xxx@126.com\\r&quot; while { ${openflag} } { send &quot;put ${localfile}\\r&quot; expect &quot;*Transfer complete*&quot; set fcount [expr ${fcount} + 1] send_user &quot;put file ok,${fcount}\\r\\n&quot; sleep 1 } send &quot;close\\r&quot; send &quot;bye\\r&quot; interact 注意，如果需要在shell中嵌入expect可以单独写一个expect脚本，再在shell中调用即可，类似如下： #! /bin/bash date ./ftp_put.sh","categories":[],"tags":[{"name":"计算机语言_Shell","slug":"计算机语言-Shell","permalink":"http://avalonlz.github.io/tags/计算机语言-Shell/"}]},{"title":"iptables与netfilter","slug":"Iptables-Netfilter","date":"2018-04-05T08:20:11.000Z","updated":"2018-11-26T15:32:59.026Z","comments":true,"path":"2018/04/05/Iptables-Netfilter/","link":"","permalink":"http://avalonlz.github.io/2018/04/05/Iptables-Netfilter/","excerpt":"iptables/netfilter，WF开发、家用路由开发的重中之重。网络方面之前都是自己瞎鼓捣，没多深入。入职一星期，就俩字“狂补”，这文章就总结下近期对iptables的学习吧","text":"iptables/netfilter，WF开发、家用路由开发的重中之重。网络方面之前都是自己瞎鼓捣，没多深入。入职一星期，就俩字“狂补”，这文章就总结下近期对iptables的学习吧iptables/netfilter是啥？概念就不多说了，网上一搜一大片，“开胃菜”就不吃了，直接上干货 iptables/netfilter的四表五链结构：注意：如果想要数据包走非转发路径，则本机必须含有此数据包的目的IP，而非同一网段 iptables规则相关语句结构：用分块的形式总结，比较直观 iptables常用查看语句：iptables -t filter -L -n -v//显示filter表的详细信息 iptables -t filter -L --line-numbers//显示filter表的规则编号 iptables -L -n -v主要字段解释:pkts：由规则或链匹配到的报文个数bytes：由规则或链匹配到的所有报文大小之和","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"利用NFS建立Linux共享文件夹","slug":"Win-Linux-NFS","date":"2018-03-23T01:16:35.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/03/23/Win-Linux-NFS/","link":"","permalink":"http://avalonlz.github.io/2018/03/23/Win-Linux-NFS/","excerpt":"为了在Win下更方便的查看Linux下的代码，利用NFS搭建网络共享文件夹，记录下","text":"为了在Win下更方便的查看Linux下的代码，利用NFS搭建网络共享文件夹，记录下先强调下需要共享的Linux下的文件夹，所以Linux作为NFS的服务端，Win安装NFS的客户端 注意防火墙等软件的设置 Win安装NFS服务(客户端)Win7:控制面板-&gt;卸载程序-&gt;打开或关闭Windows功能（在左边框栏）-&gt;勾选NFS服务（子选项也勾选）-&gt;确定 Linux安装NFS服务(服务器端)Ubuntu14.04LTS:1、sudo apt-get install nfs-kernel-server2、使用chmodm命令调整需要共享的文件夹的权限，可结合后面的anonuid和anongid来配置3、 sudo vim /etc/exports 在最后一行加入： /home/lz *(rw,sync,all_squash,no_subtree_check,anonuid=1000,anongid=1000) 之后运行：sudo exportfs -rv 说明： *：允许所有的网段访问，也可以使用具体的ip rw：此目录的客户端对该共享目录具有读写权限 sync:资料同步读写 no_subtree_check：不检查父目录的权限 root_squash：在登入 NFS 主机使用分享之目录的使用者如果是 root 时，那么这个使用者的权限将被压缩成为匿名使用者，通常他的 UID 与 GID 都会变成 nobody 那个系统账号的身份。 no_root_squash：登入 NFS 主机使用分享目录的使用者，如果是 root 的话，那么对于这个分享的目录来说，他就具有 root 的权限！这个项目『极不安全』，不建议使用！ all_squash：登入 NFS 主机使用分享目录的使用者，所有用户均被压缩成为匿名使用者，即已nobody用户的身份登录。 anonuid和anongid：明确指定匿名使用者使用指定的id值用户的权限，访问分享的目录(当前用户id可以输入id查看)。 secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）。 insecure：允许客户端从大于1024的tcp/ip端口连接服务器。 4、 sudo /etc/init.d/rpcbind restart//重启portmap sudo /etc/init.d/nfs-kernel-sever restart//重启nfs服务 showmount -e//检查共享文件夹 在Win7上挂载该共享文件夹在cmd中输入： showmount -e 192.168.175.129//显示该主机上共享的文件夹 mount -o mtype=soft 192.168.175.129:/home/lz z://从上一条显示的共享文件夹中选择一个文件夹挂载到该系统上（注意需要使用软件挂载，否则可能卡顿），z为挂载的盘符，此处选择了/home/lz文件夹 至此，完成所有操作，可以在Win7上查看、修改Ubuntu上的文件夹了","categories":[],"tags":[{"name":"百科_Linux","slug":"百科-Linux","permalink":"http://avalonlz.github.io/tags/百科-Linux/"}]},{"title":"stm32-启动文件","slug":"stm32-StartUp","date":"2018-03-13T06:01:21.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/03/13/stm32-StartUp/","link":"","permalink":"http://avalonlz.github.io/2018/03/13/stm32-StartUp/","excerpt":"马上要暂时告别MCU的开发了（进入Linux），趁着闲时，就整理着大学以来在MCU开发过程中的种种笔记，看到启动这块，回想下好像有些遗忘，就随手记录下吧，东西不多，但也写下，防止遗忘","text":"马上要暂时告别MCU的开发了（进入Linux），趁着闲时，就整理着大学以来在MCU开发过程中的种种笔记，看到启动这块，回想下好像有些遗忘，就随手记录下吧，东西不多，但也写下，防止遗忘 启动stm32的启动主要依赖BOOT0，BOOT1的引脚电平，以及它的启动文件（也就是正宗的Bootload）,那么在MCU上，启动文件做了哪些操作呢，见下图：在多说一句，UCOS这类的实时操作系统，也是依赖MCU自带的启动文件的，实时操作系统的任务堆栈初始化，也都是在MCU跳转到main后所做的操作。远程升级所说的“Bootload”也是在跳转到main后，自己写的一个判断引导程序","categories":[],"tags":[{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"}]},{"title":"OSI与TCP/IP","slug":"OSI-TCP-IP","date":"2018-03-06T14:07:23.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/03/06/OSI-TCP-IP/","link":"","permalink":"http://avalonlz.github.io/2018/03/06/OSI-TCP-IP/","excerpt":"马上要进行网络方面的开发工作了，记录总结下OSI七层模型以及TCP/IP四层模型相关的知识点，也方便日后查看复习","text":"马上要进行网络方面的开发工作了，记录总结下OSI七层模型以及TCP/IP四层模型相关的知识点，也方便日后查看复习 OSI VS TCP/IP: OSI各层所包含的主要协议： 应用层：DHCP、DNS、FTP、HTTP、IMAP4、Gopher、IRC、NNTP、XMPP、POP3、SIP、SMTP、SNMP、SSH、TELNET、RPC、RTCP、RTSP、TLS、SDP、SOAP、GTP、STUN、NTP、SDP、SSDP、STUN… 表示层：HTTP/HTML、FTP、TELNET、ASN.1… 会话层：ADSP、ASP、H.245、ISO-SP、iSNS、NetBIOS、PAP、RPC、RTCP、SMPP、SCP、SSH、ZIP、SDP 传输层：TCP、UDP、TLS、DCCP、SCTP、RSVP、PPTP 网络层：IP（IPv4、IPv6）、ICMP、ICMPv6、IGMP、IS-IS、IPsec、BGP、RIP、OSPF、ARP、RARP 数据链路层：WiFi（IEEE 802.11）、WiMAX（IEEE 802.16）、ATM、DTM、令牌环、以太网路、FDDI、帧中继、GPRS、EVDO、HSPA、HDLC、PPP、L2TP、ISDN、STP 物理层：以太网路卡、调制解调器、电力线通信（PLC）、SONET/SDH（光同步数字传输网）、G.709（光传输网络）、光导纤维、同轴电缆、双绞线 TCP/IP四层所包含的主要协议： 应用层：DHCP、DNS、FTP、Gopher、HTTP、IMAP4、IRC、NNTP、XMPP、POP3、SIP（信令控制协议）、SMTP（简单邮件传输协议）、SNMP（简单网络管理协议）、SSH（安全外壳协议）、TELNET、RPC（远程过程调用协议）、RTCP（RTP控制协议）、RTSP（实时流传输协议）、TLS（安全传输层协议）、SDP（会话描述协议）、SOAP（简单对象访问协议）、GTP（通用数据传输平台）、STUN（NAT会话穿透）、NTP（网络校时协议）… 传输层：TCP（传输控制协议）、UDP（用户数据报协议）、DCCP（数据报拥塞控制协议）、SCTP（流控制传输协议）、RTP（实时传送协议）、RSVP（资源预留协议）、PPTP（点对点隧道协议）… 网络层：IP（IPv4、IPv6）、ARP（地址解析协议）、RARP（反向地址转换协议）、ICMP（Internet控制报文协议）、IGMP（组管理协议，组播协议）、RIP（路由信息协议）、OSPF（开放式最短路径优先）、BGP（边界网关协议）、IS-IS（中间系统到中间系统的路由选择协议）、IPsec（Internet协议安全性，是一种开放标准的框架结构）… 链路层：以太网、网桥","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"Linux多进程与多线程之间的关系","slug":"Linux-MultiProcess-MultiThreadRel","date":"2018-01-12T00:56:22.000Z","updated":"2019-02-18T13:28:08.101Z","comments":true,"path":"2018/01/12/Linux-MultiProcess-MultiThreadRel/","link":"","permalink":"http://avalonlz.github.io/2018/01/12/Linux-MultiProcess-MultiThreadRel/","excerpt":"Linux多进程与多线程之间的关系（包含用户态进程、用户态线程、轻量级进程以及内核线程）","text":"Linux多进程与多线程之间的关系（包含用户态进程、用户态线程、轻量级进程以及内核线程） 用户态进程、用户态线程、轻量级进程以及内核线程之间的关系 调度：在Linux中，只存在对进程进行调度这一种说法，因为从内核的角度来说，它并没有线程这个概念，Linux把所有线程都当做进程来实现（轻量级进程），内核并没有准备特别的调度算法或定义特别的数据结构来表征线程，线程仅仅被视为一个实用某些共享资源的进程。总结下上面说的调度结果若存在A、B两进程，且A进程中跑了a,b两线程，B进程中跑了c,d两线程。则A、B两进程启动时是继承了shell的调度策略（因为其本质是由shell进程fork出来的）（应该是普通的分时进程），A进程中的a,b两线程和B进程中的c，d两线程则可选择SCHED_FIFO先入先出的实时进程、SCHED_RR时间片轮转的实时进程，以及SCHED_OTHER普通的分时进程这三种方式来进行调度 Linux下进程的6种状态R(Running or Runnable):处于运行或能（可）运行状态 S(Interruptible Sleep):处于可中断的睡眠状态（等待某事件而被挂起） D(Uninterruptible Sleep):处于不可中断的睡眠状态（进程不响应异步信号，无法用kill命令杀死。一般由等待I/O引起） T(Stopped or Traced):处于暂停或跟踪状态 Z(Dead_Exit_Zombie):处于僵死状态， X(Dead_Exit_Dead):处于退出状态（一般极其短暂，可以忽略） Linux下线程的4种状态就绪态、运行态、阻塞态和终止 进程6种状态与线程4种状态的对应关系(自身理解)","categories":[],"tags":[{"name":"百科_Linux","slug":"百科-Linux","permalink":"http://avalonlz.github.io/tags/百科-Linux/"}]},{"title":"浅谈MCU软件架构","slug":"softframework-mcu","date":"2018-01-02T12:05:13.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/01/02/softframework-mcu/","link":"","permalink":"http://avalonlz.github.io/2018/01/02/softframework-mcu/","excerpt":"众所周知，软件架构对于一个项目，一个产品是至关重要的，它的影响贯穿产品一生。一个好的架构，必然是拥有良好模块化，真正做到高内聚、低耦合，可以随意添加或删除其中的任一功能，可以进行功能的快速扩展，同时在后期维护上也应该是及其方便的。下面就简单说下我目前所学习到的架构思想","text":"众所周知，软件架构对于一个项目，一个产品是至关重要的，它的影响贯穿产品一生。一个好的架构，必然是拥有良好模块化，真正做到高内聚、低耦合，可以随意添加或删除其中的任一功能，可以进行功能的快速扩展，同时在后期维护上也应该是及其方便的。下面就简单说下我目前所学习到的架构思想 在学校和毕业一年以来一直都是从事MCU方面的开发工作。虽说是底层开发，但只要是软件，就必然存在架构。下面就简单介绍下我所采用的软件架构模型（非阻塞式） 从图中可以看出最外层的状态机是控制了整个软件的功能，根据不同状态，而去跑不同的功能 最底层是负责接收传感器数据。在接收数据方面我将他们主要分为，主动接收和被动接收 主动接收就是指采用SPI或I2C这类数据传输时钟总线由MCU控制的数据传输方式。 而被动接收就是类似UART串口这样的数据传输方式 从图中可以看出无论是主动接收又或是被动接收，我都采用了一个软件BUFF作为数据接收缓冲区，并采用邮箱来通知上层应用。这样做的好处是，保证了一帧数据的完整性，也防止了硬件BUFF不足，而导致的数据丢失 接下来在“各功能任务”这一层中，若需要传感器传来的数据，则需要编写类似于RTOS中OSMboxAccept的方法，检测该应用模块的邮箱中，是否存在下层发来的数据，同时数据的处理工作也将在这一层中进行。 在这层中主要参考了Linux驱动模型，每个功能模块对外的接口统一（读写，控制等操作都拥有统一的接口），从而降低了模块间的耦合度，代码层次清晰可见，便于高内聚低耦合代码的编写。此外该驱动模型还可与RTOS结合使用，加强RTOS的模块化设计理念 当数据在“功能任务”层中被处理完成后，又会被放入一个数据结构中（可以是链表、Hash表或其他数据结构，这个主要由功能需求决定） 此后若通讯协议层（主要是内网协议和外网协议，私有协议或MQTT、HTTP等）需要数据则自行从相关任务模块的数据结构中取出数据，并进行封包等相关处理后即可发出 这样下来，也就实现了MCU应用开发的模块化设计。若后期想使用RTOS进行开发，也只需要进行RTOS外围逻辑框架的设计，再将“功能任务”层中各自的任务移植到框架中即可（与协议层的衔接部分可以用RTOS中自带的消息队列代替，也就不用自己实现了），大大加大了软件的复用性。 以上就是我所采用的MCU软件架构，主要的还是需要软件工程的思想（内功）。所以在以后的学习工作中也会加强这一方面的学习。还希望大家能多提出不同想法，相互交流学习","categories":[],"tags":[{"name":"软件工程_FrameWork","slug":"软件工程-FrameWork","permalink":"http://avalonlz.github.io/tags/软件工程-FrameWork/"}]},{"title":"LinuxIPC及进程间的锁机制","slug":"Linux-IPC","date":"2018-01-01T08:30:47.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2018/01/01/Linux-IPC/","link":"","permalink":"http://avalonlz.github.io/2018/01/01/Linux-IPC/","excerpt":"Linux下IPC(Posix)相关知识点，就把这个作为18年第一更吧。IPC的设计理念在很多地方都用的上(软件上几个模块需要数据交互，该如何选择交互方案，该如何去实现交互)，所以在系统的过一遍吧，顺便在做个导图，加深印象","text":"Linux下IPC(Posix)相关知识点，就把这个作为18年第一更吧。IPC的设计理念在很多地方都用的上(软件上几个模块需要数据交互，该如何选择交互方案，该如何去实现交互)，所以在系统的过一遍吧，顺便在做个导图，加深印象 IPC MindMap 进程间的锁机制 共享内存的实现：进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程 1、int shmget(key_t key, size_t size, int shmflg);//创建共享内存, 返回共享内存标识id(shmid)key：IPC_PRIVATE表示创建一个新的共享内存，一般固定一个key值，方便其他进程获取size：指定共享内存容量，以字节为单位shmflg:读写权限，例如0666代表root,user,other都具有读写的权限 2、void shmat(int shmid, const void shmaddr, int shmflg);//绑定共享内存区，共享内存区域的首地址shmid:先前分配到的共享内存标识idshmaddr：指定共享内存绑定到当前进程中的地址位置，通常为0，表示让系统来选择共享内存位置shmflg：通常为0 3、int shmdt(const void *shmaddr);//解绑共享内存shmaddr：shmat返回的shmaddr的地址","categories":[],"tags":[{"name":"Linux多进程编程","slug":"Linux多进程编程","permalink":"http://avalonlz.github.io/tags/Linux多进程编程/"}]},{"title":"下位机配置软件","slug":"BridgeProject","date":"2017-12-27T08:36:25.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/12/27/BridgeProject/","link":"","permalink":"http://avalonlz.github.io/2017/12/27/BridgeProject/","excerpt":"给手上这个即将完工的项目做个配置软件（下位机都全包了，上位机也自己写了，也方便测试和出厂配置）。玩QT最主要的就是信号和槽了，即使是多线程也是QT封装过的。写了几个软件后，积累了不少自己做的功能库，以后PC端的开发就很方便了","text":"给手上这个即将完工的项目做个配置软件（下位机都全包了，上位机也自己写了，也方便测试和出厂配置）。玩QT最主要的就是信号和槽了，即使是多线程也是QT封装过的。写了几个软件后，积累了不少自己做的功能库，以后PC端的开发就很方便了 打开界面： 菜单界面： 配置界面： 配置1主界面： 配置2主界面： 简单说下线程方面的设计： 首先单独开了一个线程给串口扫描，从UI初始化那一个线程就一直进行串口的扫描工作。若有某时刻串口列表与旧时不同。则发送新的串口列表信号到主线程，主线程操作UI更新串口列表 再来就是TextEdit控件负责显示下位机发来的数据，这里也单独开了一个线程专门进行串口数据的读取。当取到数据后，利用信号发送将数据发送给主线程，主线程操作UI将新数据更新到Text Edit控件上 之后是串口的写入方面，也开了一个线程。这个线程只负责串口的写入。主线程从UI中取到用户输入的数据后，利用信号将数据发送给负责串口写入的线程，由它来发送数据到下位机 总结一下这个应用一共就开了3个分线程，分别负责串口的扫描，串口的读取以及串口的写入这三个方面。而主线程主要负责的就是UI操作，以及利用槽对用户操作做出相关响应 补充：测试中发现点击“确认配置”时，若需要配置的参数过多（也就是发送了多次信号），会导致UI出现卡顿（说明PyQT的emit还是比较占时间的），体验感下降。又不打算修改下位机的代码。打算后期在点击“确认配置”时，在单独开一个线程，跑这些较多的emit，等emit发送完，该线程自动结束 代码已上传GitHub需要的请自行下载~~https://github.com/avalonLZ/PyQt_Bridge","categories":[],"tags":[{"name":"应用软件_PyQt","slug":"应用软件-PyQt","permalink":"http://avalonlz.github.io/tags/应用软件-PyQt/"}]},{"title":"UCOSII三大控制块","slug":"UCOS-Three-Control-Block","date":"2017-12-11T12:27:19.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/12/11/UCOS-Three-Control-Block/","link":"","permalink":"http://avalonlz.github.io/2017/12/11/UCOS-Three-Control-Block/","excerpt":"前面总结了UCOSII下的任务调度以及任务间的同步与通信机制，这篇文章简单总结下UCOSII下的三大控制块：TCB（任务控制块）、ECB（事件控制块）以及MCB（内存控制块）","text":"前面总结了UCOSII下的任务调度以及任务间的同步与通信机制，这篇文章简单总结下UCOSII下的三大控制块：TCB（任务控制块）、ECB（事件控制块）以及MCB（内存控制块） UCOSII初始化时建立的五大缓冲区（以单链表的形式存在）：若当使用相应控制块时则向缓冲区申请，不使用时释放回缓冲区，若缓冲区中的相应控制块使用完了，则不能再分配相应控制块。在初始化时可配置缓冲区大小 TCB(Task_Control_Block)任务控制块：/* ********************************************************************************************************* * TASK CONTROL BLOCK ********************************************************************************************************* */ typedef struct os_tcb { OS_STK *OSTCBStkPtr; /* 当前任务的栈顶地址（UCOSII中每个任务都有自己的栈）且容量任意 */ #if OS_TASK_CREATE_EXT_EN &gt; 0 void *OSTCBExtPtr; /*只在OstaskCreateExt()函数中使用，用于用户扩展任务控制*/ OS_STK *OSTCBStkBottom; /* 指向任务可以使用的栈空间的最高地址，一般在OSTaskStkChk()函数中使用 */ INT32U OSTCBStkSize; /*存有栈中可容纳的指针数目，在OSTaskStkChk()函数中使用*/ INT16U OSTCBOpt; /* 将选项传递给OstaskCreateExt()函数 */ INT16U OSTCBId; /* Task ID (0..65535)用于存储任务识别码，暂无用，留作扩展 */ #endif struct os_tcb *OSTCBNext; /* TCB链表下一个任务对应的TCB块，在OSTimeTick（）函数中被调用，用于刷新任务延迟变量OSTCBDly */ struct os_tcb *OSTCBPrev; /* 与上面类似（每个任务在创建时都将被加入TCB链表中） */ #if (OS_EVENT_EN) || (OS_FLAG_EN &gt; 0) OS_EVENT *OSTCBEventPtr; /* 指向事件控制块的指针 */ #endif #if (OS_EVENT_EN) &amp;&amp; (OS_EVENT_MULTI_EN &gt; 0) OS_EVENT **OSTCBEventMultiPtr; /* 指向多事件控制块的指针 */ #endif #if ((OS_Q_EN &gt; 0) &amp;&amp; (OS_MAX_QS &gt; 0)) || (OS_MBOX_EN &gt; 0) void *OSTCBMsg; /* Message received from OSMboxPost() or OSQPost()，指向消息地址 */ #endif #if (OS_FLAG_EN &gt; 0) &amp;&amp; (OS_MAX_FLAGS &gt; 0) #if OS_TASK_DEL_EN &gt; 0 OS_FLAG_NODE *OSTCBFlagNode; /* 指向 事件标志节点 */ #endif OS_FLAGS OSTCBFlagsRdy; /* 使得任务准备运行（进入就绪态的事件标志）的标志 */ #endif INT16U OSTCBDly; /* 任务等待（挂起）时限，对应各种pend函数 */ INT8U OSTCBStat; /* 任务状态，0：就绪，1：等待（挂起）信号量状态，2：等待（挂起）消息邮箱状态，3：等待（挂起）消息队列状态，4：Suspend(挂起)状态（此挂起只有Resume可解），5：等待（挂起）互斥信号量状态 */ INT8U OSTCBStatPend; /* 等状态的状态标志，0：等待状态OK，非等待状态或等待完成状态，1：等待超时状态，2：等待中止状态 */ INT8U OSTCBPrio; /* 储存任务优先级(0 == highest) */ INT8U OSTCBX; /* 任务优先级计算参数，优先级低3位对应的数值，即prio &amp; 0x07 */ INT8U OSTCBY; /* 任务优先级高3位对应的值，即prio &gt;&gt; 3（存有疑问？） */ #if OS_LOWEST_PRIO &lt;= 63 INT8U OSTCBBitX; /* 对应就绪表组的值，OSRdyTbl[OSTCBY] |= OSTCBBitX */ INT8U OSTCBBitY; /* 就绪表组OSRdyGrp |= OSTCBBitY 即上行所提到的对应组 */ #else INT16U OSTCBBitX; /* Bit mask to access bit position in ready table */ INT16U OSTCBBitY; /* Bit mask to access bit position in ready group */ #endif #if OS_TASK_DEL_EN &gt; 0 INT8U OSTCBDelReq; /* 标识该任务十分需要被删除 */ #endif #if OS_TASK_PROFILE_EN &gt; 0 INT32U OSTCBCtxSwCtr; /* 表示任务被调用的次数 */ INT32U OSTCBCyclesTot; /* 该任务运行的节拍总数 */ INT32U OSTCBCyclesStart; /* 该任务恢复开始时的节拍数 */ OS_STK *OSTCBStkBase; /* 该任务堆栈的开始位置 */ INT32U OSTCBStkUsed; /* 该任务堆栈已被使用的字节数 */ #endif #if OS_TASK_NAME_SIZE &gt; 1 INT8U OSTCBTaskName[OS_TASK_NAME_SIZE];/* 该任务的名称 */ #endif } OS_TCB; ECB(Event_Control_Block)事件控制块： /* ********************************************************************************************************* * EVENT CONTROL BLOCK ********************************************************************************************************* */ #if (OS_EVENT_EN) &amp;&amp; (OS_MAX_EVENTS &gt; 0) typedef struct os_event { INT8U OSEventType; /*事件控制块的类型(OS_EVENT_TYPE_UNUSED（未使用）、OS_EVENT_TYPE_MBOX、OS_EVENT_TYPE_Q、OS_EVENT_TYPE_SEM、OS_EVENT_TYPE_MUTEX和OS_EVENT_TYPE_FLAG) */ void *OSEventPtr; /* 指向消息或消息队列中消息结构体的指针，只在邮箱和消息队列事件中存在 */ INT16U OSEventCnt; /* 当事件类型为信号量时的计数器 */ #if OS_LOWEST_PRIO &lt;= 63 INT8U OSEventGrp; /* 等待某事件的任务表组 */ INT8U OSEventTbl[OS_EVENT_TBL_SIZE]; /* 等待某事件的任务表 */ #else INT16U OSEventGrp; /* Group corresponding to tasks waiting for event to occur */ INT16U OSEventTbl[OS_EVENT_TBL_SIZE]; /* List of tasks waiting for event to occur */ #endif #if OS_EVENT_NAME_SIZE &gt; 1 INT8U OSEventName[OS_EVENT_NAME_SIZE];/* 事件名 */ #endif } OS_EVENT; #endif MCB(Memory_Control_Block)事件控制块： /* ********************************************************************************************************* * MEMORY PARTITION DATA STRUCTURES ********************************************************************************************************* */ #if (OS_MEM_EN &gt; 0) &amp;&amp; (OS_MAX_MEM_PART &gt; 0) typedef struct os_mem { /* MEMORY CONTROL BLOCK */ void *OSMemAddr; /* 内存分区的首地址 */ void *OSMemFreeList; /* 内存控制块组成的链表头地址 */ INT32U OSMemBlkSize; /* 每个内存控制块的大小(字节) */ INT32U OSMemNBlks; /* 内存分区中内存控制块的数目 */ INT32U OSMemNFree; /* 内存分区中空闲内存控制块的数目 */ #if OS_MEM_NAME_SIZE &gt; 1 INT8U OSMemName[OS_MEM_NAME_SIZE]; /* 内存分区的名字 */ #endif } OS_MEM; typedef struct os_mem_data { void *OSAddr; /* Pointer to the beginning address of the memory partition */ void *OSFreeList; /* Pointer to the beginning of the free list of memory blocks */ INT32U OSBlkSize; /* Size (in bytes) of each memory block */ INT32U OSNBlks; /* Total number of blocks in the partition */ INT32U OSNFree; /* Number of memory blocks free */ INT32U OSNUsed; /* Number of memory blocks used */ } OS_MEM_DATA; #endif","categories":[],"tags":[{"name":"RTOS_UCOSII","slug":"RTOS-UCOSII","permalink":"http://avalonlz.github.io/tags/RTOS-UCOSII/"}]},{"title":"UCOSII任务调度与同步、通信机制","slug":"UCOS-TaskSynCommunication","date":"2017-11-23T01:05:33.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/11/23/UCOS-TaskSynCommunication/","link":"","permalink":"http://avalonlz.github.io/2017/11/23/UCOS-TaskSynCommunication/","excerpt":"前段时间总结了Linux下多线程同步机制。今天总结下，在实时操作系统UCOSII下是如何进行任务调度的，以及有哪些任务间的同步、通信机制。插两句闲话，个人感觉，RTOS只有在对实时性强要求(例如控制类)的产品上才需要使用。物联网相关的嵌入式产品大部分都只需要一个良好的系统架构（可以进行快速开发、利于后期维护修改），该类产品其实并不需要使用RTOS","text":"前段时间总结了Linux下多线程同步机制。今天总结下，在实时操作系统UCOSII下是如何进行任务调度的，以及有哪些任务间的同步、通信机制。插两句闲话，个人感觉，RTOS只有在对实时性强要求(例如控制类)的产品上才需要使用。物联网相关的嵌入式产品大部分都只需要一个良好的系统架构（可以进行快速开发、利于后期维护修改），该类产品其实并不需要使用RTOS UCOSII下的任务调度（可以使用OS_Enter_Critical()和OS_Exit_Critical()使能和失能中断，来控制是否进行任务调度）在Linux下(此处主要讨论pthread所创建的线程，也就是用户态线程)，用户态线程的调度需要自己实现，Linux内核无法对用户态线程进行调度。在UCOSII下，为了保证实时性，采用了高优先级抢占调度策略（注意：是高优先级抢占，而不是最高优先级抢占）。简单解释一下，也就是说高优先级任务无条件抢占CPU，如果高优先级任务一直未挂起，则低优先级任务将一直不会被执行，且在UCOSII中原则上不能创建两个同优先级的任务。UCOSII使用3种机制来保证高优先级任务(间接调用OS_Sched()进行任务调度)的执行 1、用户主动调用API函数。在用户任务中调用OSFlag_Pend()、OSMboxPend()、OSMutexPend()、OSQPend()、OSSemPend()、OSTaskSuspend()、OSTimeDly()以及OSTimeDlyHMSM()这几个API函数都将间接调用OS_Sched()函数，查找当前就绪表中优先级最高的任务（若当前任务优先级是最高的，且未阻塞挂起，则当前任务依然在就绪表中。若当前任务由于调用这些API阻塞挂起了，则当前任务会从就绪表中移除，再进行后续的查找工作），并调用OS_TASK_SW()函数，立马进行任务切换在使用OSFlagPOST()、OSMboxPost()、OSMutexPost()、OSQPost()、和OSSemPost()等API时，若存在对应的等待(阻塞挂起)任务，则会将对应的任务加入就绪表，并立马进行任务调度，切换到此时就绪表中优先级最高的任务去运行（这一点与Linux的多线程调度机制不同，Linux需要等待当前任务时间片使用完）上一张UCOSII下的任务状态图： 2、通过系统时钟(Systick)进行调度。每隔一个系统时钟间隔进行一次任务就绪状态检测，如果检测到有更高优先级的任务处于就绪态，则会进行任务切换。系统时钟间隔应当要适合，太长影响系统实时性，太短则会造成系统花费过多的资源处理定时器中断 3、通过触发外部中断程序进入系统调度。当发生了外部中断，造成系统任务就绪状态变化，在退出中断处理函数时，调用OSIntExit()函数。在这个函数中，如果检测到更高优先级任务处于就绪状态，则调用OSIntCtxSw()函数进行任务切换注：OSIntEnter()和OSIntExit()是在中断服务程序中应该被调用的，前者用来告诉OS进入中断了，中断嵌套层数加1。后者用来告诉OS退出中断了，中断嵌套层数减1，并进行任务调度 UCOSII下的任务通信、同步机制在Linux下因为线程间通信都是在应用层加之线程间共享内存空间，所以线程间一般都采用一段共享空间进行通讯，只要选择正确的同步方式保证共享空间操作的原子性即可。但在RTOS中由于涉及硬件和上层应用交互的需求，所以衍生出了更加丰富的通信手段，邮箱、消息队列等(当然这些手段也可以自己在Linux上实现)下面上一张图，先简单总结下UCOSII下的任务通讯与同步机制 1、信号量（整数型型号量sem。可能导致优先级翻转问题，因为API内部不会暂时提升任务优先级）：建立信号量的工作，必须在任务启动(start)之前完成 创建：OS_EVENT *OSSemCreate (INT16U cnt)cnt为初始值，可看做代表允许cnt个任务同时访问某资源。若没有可用的ECB则返回空指针 等待信号量：OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)若运行到此处，pevent中的cnt为0，该任务将挂起等待信号量，直到该信号量给到此任务一个信号。若运行到此处，cnt非0，则将cnt减一后继续执行该任务timeout为超时时间，表示该任务进入等待信号量后的挂起时间，时间一到该任务将进入就绪态，若设为0则表示永久等待 发送信号量：INT8U OSSemPost (OS_EVENT *pevent)调用此API首先会检测pevent信号量是否有被等待，若有被等待，则将等待列表中最高优先级的任务转变为就绪状态，接着会调用OSSched()函数进行任务调度，立即转到此时就绪态中系统优先级最高的任务去执行，若没有任务比当前任务优先级高，则继续执行该任务。若在调用此API时没有任务在等待该信号量，则该信号量的cnt加1 放弃信号量等待：INT8U OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)无任务等待pevent信号量则继续执行该任务。若存在任务等待该信号量，且opt为OS_PEND_OPT_BROADCASE，则表示广播方式，释放所有等待该信号量的任务，使其全部变为就绪态，并进行任务调度。若opt为OS_PEND_OPT_NONE则表示将等待该信号量的任务中优先级最高的任务变为就绪态（放弃等待该信号量）并进行任务调度 删除信号量：OS_EVENT *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)opt = OS_DEL_NO_PEND 若是没有等待信号量的任务，则删除该任务opt = OS_DEL_ALWAYS 不管有没有任务等待，始终删除。若有任务等待则会现将所有等待任务都更新为就绪态。此后再使用OS_Sched()进行任务调度，则会立即转到就绪态中更高优先级的任务去执行由于ECB控制块数量有限（默认为十个）,所以不用的信号量应该尽快删除 无等待的请求一个信号量：INT16U OSSemAccept (OS_EVENT *pevent) 查询一个信号量的当前状态：INT8U OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data) 重新设置信号量cnt值（一般不用）：void OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr) 2、互斥信号量（二值型型号量mutex。能解决任务优先级翻转问题，API内部暂时提升当然任务优先级）： 创建：OS_EVENT *OSMutexCreate (INT8U prio, INT8U *perr)prio：空闲的较高优先级（一般将最高优先级保留在此处使用），用于暂时提升任务优先级perr：存放出错的信息 等待互斥型信号量：void OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)pevent：等待的信号量timeout：等待超时时间，0值为永久等待perr：存放出错的信息 释放互斥型信号量：INT8U OSMutexPost (OS_EVENT *pevent)pevent：释放的信号量 无阻塞请求互斥型信号量：BOOLEAN OSMutexAccept (OS_EVENT *pevent, INT8U *perr)调用此API会立即返回，不会根据信号量的状态而阻塞。返回值0表示信号量不可用，返回1表示得到互斥型信号量pevent：请求的互斥型信号量perr：存放出错信息 查询互斥型信号量当前状态：INT8U OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)返回查询出错码pevent：需要查询的信号量p_mutex_data：存放查询到的信号量状态信息 3、事件标志组预先设定好N个事件，当N个事件都达成时，才进入下一步操作 创建：OS_FLAG_GRP *OSFlagCreate (OS_FLAGS flags, INT8U *perr)flags：创建事件标志中的初始值perr：存放出错信息创建完后才可使用此事件标志组 等待事件标志组信号：OS_FLAGS OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)pgrp：某个事件标志组地址flags：过滤器，用于表示哪几位有效条件才成立。例如：（OS_FLAGS）3，表示请求低2位的信号wait_type：如何算有效。OS_FLAG_WAIT_CLR_ALL（过滤器所有位为0），OS_FLAG_WAIT_SET_ALL（过滤器所有位为1），OS_FLAG_WAIT_CLR_ANY（过滤器任意位为0），OS_FLAG_WAIT_SET_ANY（过滤器任意位为1）。若再加上OS_FLAG_CONSUME则表示有效后清除过滤位的信号（一般配合SET使用，不加此，若任务只需要一次信号，则可以不加此）timeout：超时时间，0表示永久不超时perr：存放出错信息 向事件标志组发信号：OS_FLAGS OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)pgrp：某个事件标志组地址flags：选择需要发送的信号，例如：（OS_FLAGS）1给最低位发信号opt：选择发送置1还是置0信号，OS_FLAG_SET置1信号，flags位置1。OS_FLAG_CLR置0信号，flags位置0perr：存放出错信息 不等待事件标志组（若过滤器事件并不成立也不挂起当前任务）：OS_FLAGS OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)pgrp：某个事件标志组地址flags：过滤器，用于表示哪几位有效条件才成立。例如：（OS_FLAGS）3，表示请求低2位的信号wait_type：如何算有效。OS_FLAG_WAIT_CLR_ALL（过滤器所有位为0），OS_FLAG_WAIT_SET_ALL（过滤器所有位为1），OS_FLAG_WAIT_CLR_ANY（过滤器任意位为0），OS_FLAG_WAIT_SET_ANY（过滤器任意位为1）。若再加上OS_FLAG_CONSUME则表示有效后清除过滤位的信号（一般配合SET使用，不加此，若任务只需要一次信号，则可以不加此）perr：存放出错信息 删除事件标志组（）：OS_FLAG_GRP *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)pgrp：某个事件标志组地址opt：opt值为OS_DEL_NO_PEND表示当前若没有任务阻塞等待此标志组时，删除此标志组。若有任务等待则不做处理，继续运行当前任务。值为OS_DEL_ALWAYS表示不管当前标志组是否有任务等待，都删除该标志组。若有任务等待则会现将所有等待任务都更新为就绪态。此后再使用OS_Sched()进行任务调度，则会立即转到就绪态中更高优先级的任务去执行perr：存放出错信息 查询事件标志组的当前事件标志状态：OS_FLAGS OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)pgrp：某个事件标志组地址perr：存放出错信息 4、邮箱（可看做是信号量的升级版，可以实现一个任务向另一个任务发送一个指针变量） 创建：OS_EVENT *OSMboxCreate (void *pmsg)pmsg：传入需要传递的消息指针，在创建邮箱的同时将此消息放入邮箱中，不想在创建时候就传入消息，或者只想将邮箱当成信号量来使用可以填入NULL 等待邮件：void *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)此处需要强调，此API返回一个邮件指针，若指针非空则表示取出了邮箱中的消息若邮箱中没有邮件则此任务会被挂起，直到等待超时，或用了Post发出邮件（在post中会将等待列表中最高优先级的任务转为就绪态，并进行调度运行，但超时只会将任务转变为就绪态，并不进行调度）。pevent：邮箱地址timeout：等待超时时间，超时后任务将由挂起转为就绪态（但不立即进行调度），0值为永久等待perr：存放出错信息 无等待查询邮件：void *OSMboxAccept (OS_EVENT *pevent)pevent：待查询的邮箱地址若存在邮件则返回邮件地址，若不存在邮件则继续运行，不挂起当前任务 发送邮件：INT8U OSMboxPost (OS_EVENT *pevent, void *pmsg)pevent：邮箱地址pmsg：邮件地址（邮件地址，需要为一个固定地址，局部变量的地址可能导致BUG） 放弃等待邮件：INT8U OSMboxPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)pevent：邮箱地址opt：值为OS_ERR_NONE，表示将等待任务列表中优先级最高的置为就绪态，放弃此次等待。OS_ERR_PEND_ABORT，表示所有等待任务都变为就绪态。最后都将进行任务调度，调用就绪态中最高优先级的任务去运行perr：存放出错信息 查询一个邮箱的当前状态：INT8U OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)pevent：邮箱地址p_mbox_data：邮箱信息地址（邮箱信息将填入此地址中） 删除邮箱：OS_EVENT *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)pevent：邮箱地址opt：opt若为OS_DEL_NO_PEND表示若当前没有任务等待则删除此邮箱，若有任务等待则填写错误信息，当前任务继续运行。若为OS_DEL_ALWAYS则表示强制删除此邮箱，所有等待列表中的任务都将变为就绪态，并进行任务调度，运行就绪态中优先级最高的任务perr：存放出错信息 5、消息队列（可以看做是邮箱的升级版，可以实现从一个任务向另一个任务发送多个指针变量，也就是说用消息队列传递，在接收处可以用while全部接收完，而且每个指针所指向的数据结构变量也可以有所不同） 创建（返回队列地址）:OS_EVENT *OSQCreate (void **start, INT16U size)需要先定义一个存放消息指针的指针数组void *MyQueryMsg[SIZE]start：此处填入该指针数组的地址，用于存放消息指针size：填入队列所能存放数据的最大值例：myquery = OSQCreate(MyQueryMsg, SIZE); 等待消息队列中的消息：void *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)返回msg的地址（根据POST的方式（FIFO或LIFO）来获得msg）pevent：消息队列地址timeout：等待超时时间，时间到后任务进入就绪态（但不立即进行任务调度）perr：存放出错信息 无等待地从一个消息队列中取得消息：void *OSQAccept (OS_EVENT *pevent, INT8U *perr)pevent：消息队列地址perr：存放出错信息 向消息队列发送一个消息（FIFO）：INT8U OSQPost (OS_EVENT *pevent, void *pmsg)pevent：消息队列地址pmsg：需要发送的消息地址，注意不要使用临时变量的地址，极可能出现BUG 向消息队列发送一个消息（后进先出LIFO）：INT8U OSQPostFront (OS_EVENT *pevent, void *pmsg)同上 清空一个消息队列：INT8U OSQFlush (OS_EVENT *pevent)pevent：消息队列地址 查询一个消息队列状态：INT8U OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)pevent：消息队列地址p_q_data：存放消息队列信息的结构体变量 删除一个消息队列：OS_EVENT *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)pevent：消息队列地址opt：opt若为OS_DEL_NO_PEND表示若当前没有任务等待则删除此队列，若有任务等待则填写错误信息，当前任务继续运行。若为OS_DEL_ALWAYS则表示强制删除此队列，所有等待列表中的任务都将变为就绪态，并进行任务调度，运行就绪态中优先级最高的任务 利用闲暇时间封装的UCOSii事件库：https://github.com/avalonLZ/Libraries/tree/master/C/ucosii","categories":[],"tags":[{"name":"RTOS_UCOSII","slug":"RTOS-UCOSII","permalink":"http://avalonlz.github.io/tags/RTOS-UCOSII/"}]},{"title":"Linux多线程编程之线程同步","slug":"Linux-MultiThreadSyn","date":"2017-11-12T13:27:57.000Z","updated":"2018-11-29T12:48:33.326Z","comments":true,"path":"2017/11/12/Linux-MultiThreadSyn/","link":"","permalink":"http://avalonlz.github.io/2017/11/12/Linux-MultiThreadSyn/","excerpt":"Linux多线程(用户态线程)编程之线程同步相关知识点","text":"Linux多线程(用户态线程)编程之线程同步相关知识点 相关名词解析同步：同步就是指在一定时间内只允许一个线程访问某一资源。在该时间内其他线程不可访问该资源（实现方式：mutex互斥锁、condition variable条件变量、spin lock自旋锁（read/write lock读写锁是特殊自旋锁）、sem信号量等） 原子操作:某段代码在执行时不会被其他线程影响，则构成了一个原子操作 临界区（非内核对象时，只在Win下多线程中存在，此处只提及不做过多说明）：临界区是一种轻量级机制，在某一时间内只允许一个线程执行某个给定代码段（在RTOS下表示禁止总中断和开启总中断之间的代码段）。临界区只能用于对同一进程内的线程进行同步 多线程同步实现方式（mutex、cond、sem、rw重要） 互斥锁的实现主要实现函数： 1、pthread_mutex_t mutex_test = PTHREAD_MUTEX_INITIALIZER;//初始化静态定义的锁，一般用此即可pthread_mutex_init(&amp;mutex,NULL);//互斥锁被存放在参数mutex指向的内存中，第二个参数一般默认为NULL，使用缺省属性 2、pthread_mutex_lock(&amp;mutex_test);//上锁 3、pthread_mutex_unlock(&amp;mutex_test);//解锁 4、pthread_mutex_destroy (&amp;mutex_test); //销毁互斥锁 /************************************************************************* &gt; File Name: mutexlock.c &gt; Author:lizhong &gt; Mail: &gt; Created Time: 2017年11月12日 星期日 06时11分54秒 ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;pthread.h&gt; #include&lt;sys/syscall.h&gt; #include&lt;unistd.h&gt; pthread_mutex_t mutex_test = PTHREAD_MUTEX_INITIALIZER; pid_t gettid(void) { return syscall(__NR_gettid); } void *Thread_Test(void *main_i) { int *tem_i = main_i; while(1) { //创建互斥锁 pthread_mutex_lock(&amp;mutex_test); if(*tem_i &lt; 10) (*tem_i)++; else break; printf(&quot;New ThreadID is:%lu, Main_i value is:%d\\r\\n&quot;, (unsigned long int)gettid(),*tem_i); //解锁，从此可以看出，锁实现了一段代码的原子操作，而非只针对某变量的原子操作 pthread_mutex_unlock(&amp;mutex_test); sleep(1); } printf(&quot;New ThreadID is:%lu, Main_i value is:%d\\r\\n&quot;, (unsigned long int)gettid(),*tem_i); pthread_mutex_unlock(&amp;mutex_test); } int main(void) { int i = 0; int j = 0; pthread_t threadinfo[3]; for(j = 0; j &lt; 3; ++j) { pthread_create(&amp;threadinfo[j], NULL, Thread_Test, (void *)&amp;i); } for(j = 0; j &lt; 3; ++j) { pthread_join(threadinfo[j], NULL); } printf(&quot;All End\\r\\n&quot;); } 条件变量的实现（注意：条件变量总是和一个互斥锁搭配使用，当一个线程的行为依赖于另外一个线程对共享数据状态的改变时，这时候就可以使用条件变量）与互斥锁不同，条件变量是主动阻塞自身线程，直到某条件达成。但条件的检测需要在互斥锁的保护下进行。主要实现函数： 1、pthread_cond_t temcond = PTHREAD_COND_INITIALIZER;//初始化静态定义的条件变量，一般用此即可int pthread_cond_init(pthread_cond_t cv,const pthread_condattr_t cattr);//条件变量被存放在参数cv指向的内存中，cattr一般默认为NULL，使用缺省属性 2、int pthread_cond_signal(pthread_cond_t *cv);//通过条件变量cv发送消息，若多个线程等待，按入队顺序激活其中一个。调用后要立即释放本线程的互斥锁，因为在满足条件后pthread_cond_wait会在另一个线程立马上锁继续执行。pthread_cond_broadcast可以唤醒所有等待线程 3、int pthread_cond_wait(pthread_cond_t cv,pthread_mutex_t mutex);//函数执行时先自动释放指定的锁，然后等待条件变量的变化。在函数调用返回之前，自动将指定的互斥量重新锁住。解锁-&gt;阻塞等待条件成立-&gt;上锁，继续执行。所以需要注意在另一线程条件变量成立signal后需要立即解锁 4、int pthread_cond_destroy(pthread_cond_t *cv);//销毁条件变量 /************************************************************************* &gt; File Name: ConditionVariable.c &gt; Author: lizhong &gt; Mail: &gt; Created Time: 2017年11月16日 星期四 05时26分09秒 ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; #include&lt;pthread.h&gt; #include&lt;sys/syscall.h&gt; pthread_mutex_t mutex_test = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond_test = PTHREAD_COND_INITIALIZER; void *One_Thread(void * tparam) { printf(&quot;One_Thread Start!\\r\\n&quot;); pthread_mutex_lock(&amp;mutex_test); //解锁并等待条件变量信号，信号来后立即上锁继续执行该线程 pthread_cond_wait(&amp;cond_test, &amp;mutex_test); printf(&quot;One_Thread Receive Signal\\r\\n&quot;); pthread_mutex_unlock(&amp;mutex_test); } void *Two_Thread(void * tparam) { unsigned char j = 0; printf(&quot;Two_Thread Start!\\r\\n&quot;); for(j = 0; j &lt; 10; ++j) { if(j == 5) { printf(&quot;Two _Thread Ready Send Signal\\r\\n&quot;); //发送信号的线程可以不使用互斥锁，根据需求来设计 pthread_cond_signal(&amp;cond_test); printf(&quot;Two_Thread Send Signal OK\\r\\n&quot;); } printf(&quot;Two_Thread j Value is:%d\\r\\n&quot;, j); } } int main(void) { pthread_t one_thread; pthread_t two_thread; //可能会出现2号线程一直跑， //1号线程却还没开始跑的情况， //导致1号线程没能收到signal pthread_create(&amp;one_thread, NULL, One_Thread, (void *)0); sleep(1);//确保1号线程先跑,也可使用SCHED_FIFO或SCHED_RR实时调度算法初始化线程 pthread_create(&amp;two_thread, NULL, Two_Thread, (void *)0); pthread_join(one_thread, NULL); pthread_join(two_thread, NULL); printf(&quot;ALL END\\r\\n&quot;); } 信号量的实现(使用信号量，需要包含semaphore.h头文件)：POSIX信号量(linux中还有一种过时的System V信号量)分为有名信号量(值存在文件中)和无名信号量(值保持在内存中)，都可以用于线程的同步(有名信号量还可用于进程间同步，无名信号量还可用于有亲缘关系的进程间同步)无名信号量必须是共享变量，并且无名信号量要保护的变量也必须是共享变量。无名信号量主要实现函数(函数本身均属于原子操作，可以多线程同时执行)： 1、int sem_init(sem_t *sem, int pshared, unsigned int value);//初始化一个信号量，value参数指定信号量的初始值，pshared参数指明信号量是由进程内线程共享(0值)，还是进程间共享(非0值)，value指定了信号量的初始值 2、int sem_wait(sem_t *sem);//若sem值非零则立刻执行减1操作，线程继续执行。若sem值为0则线程睡眠，等待直到其他线程操作sem使其非零时才会唤醒该线程，减1后继续执行(同条件变量一样，收到信号后随机继续跑一个线程，有可能是发信号的线程也有可能是收信号的线程)。若有两个线程都在等待同一个信号量变成非零值，则第三个线程增加1时，等待线程中只有一个随机线程能对信号量做减法并继续执行，另一个仍处于等待状态 3、int sem_post(sem_t *sem);//将信号量值加1 4、int sem_destroy(sem_t *sem);//该函数用于清理信号量，在清理信号量时若还有线程在等待该信号量则会报错 /************************************************************************* &gt; File Name: Sem.c &gt; Author: &gt; Mail: &gt; Created Time: 2017年11月19日 星期日 00时44分58秒 ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; #include&lt;pthread.h&gt; #include&lt;sys/syscall.h&gt; #include&lt;semaphore.h&gt; sem_t sem_test; void *One_Thread(void *tparam) { printf(&quot;One_Thread is Start!\\r\\n&quot;); sem_wait(&amp;sem_test); printf(&quot;One_Thread received sem\\r\\n&quot;); printf(&quot;One_Thread End!\\r\\n&quot;); } void *Two_Thread(void *tparam) { unsigned char i = 0; printf(&quot;Two_Thread is Start!\\r\\n&quot;); for(i = 0; i &lt;= 5; ++i) { sleep(1); printf(&quot;Two_Thread i value is:%d\\r\\n&quot;, i); } sem_post(&amp;sem_test); printf(&quot;Two_Thread End!\\r\\n&quot;); } int main(void) { pthread_t one_thread; pthread_t two_thread; sem_init(&amp;sem_test, 0, 0); pthread_create(&amp;one_thread, NULL, One_Thread, (void *)0); pthread_create(&amp;two_thread, NULL, Two_Thread, (void *)0); pthread_join(one_thread, NULL); pthread_join(two_thread, NULL); printf(&quot;All End\\r\\n&quot;); } 读写锁的实现（适合一个线程写，多个线程读）：若一个线程用了读锁锁定临界区，则其他线程依然可以使用读锁来进入临界区(不加锁也可进入临界区)。若在此时一个线程想对临界区加写锁，则需要等待所有先前的读锁都解锁后才会锁上写锁（之后来的读上锁操作不会被写锁阻塞，依然可以上锁）(导致写锁饥饿的原因)，也就是说，默认属性总是读锁优先的，若想改成写优先，则需要将attr属性设置为PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP（即写锁优先，看看源码便知道为什么了），这样一来，后来的写锁将不会被阻塞，之后的读锁，需等待写锁解锁后，才能拿到写锁（看看源码就明白了）。若一个线程进行写锁加锁，则此后访问这个临界区的读锁或写锁都将进入阻塞。主要实现函数（1-5重要): 1、pthread_rwlock_t rwlock_test = PTHREAD_RWLOCK_INITIALIZER;//静态初始化读写锁int pthread_rwlock_init(pthread_rwlock_t rwptr, const pthread_rwlockattr_t attr);//初始化读写锁,attr为空指针，表示使用缺省属性 2、int pthread_rwlock_rdlock(pthread_rwlock_t *rwptr);//读锁上锁 3、int pthread_rwlock_wrlock(pthread_rwlock_t *rwptr);//写锁上锁 4、int pthread_rwlock_unlock(pthread_rwlock_t *rwptr);//解锁读写锁 5、int pthread_rwlock_destroy(pthread_rwlock_t *rwptr);//销毁读写锁 6、int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwptr);//尝试读锁上锁（非阻塞），成功返回0，失败返回错误码 7、int pthread_rwlock_trywrlock(pthread_rwlock_t *rwptr);//尝试写锁上锁(非阻塞)，成功返回0，失败返回错误码 /************************************************************************* &gt; File Name: RWlock.c &gt; Author:lizhong &gt; Mail: &gt; Created Time: 2017年11月19日 星期日 21时35分38秒 ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;unistd.h&gt; #include&lt;pthread.h&gt; #include&lt;sys/syscall.h&gt; #define MAXDATASIZE 1024 typedef struct { unsigned char flag_hasdata;//防止读者线程先运行时读数据 char data[MAXDATASIZE]; }Data_t; pthread_rwlock_t rwlock_test = PTHREAD_RWLOCK_INITIALIZER; //读者线程 void *One_Thread(void *tparam) { Data_t *pdata = tparam; printf(&quot;One_Thread Start!\\r\\n&quot;); while(1) { pthread_rwlock_rdlock(&amp;rwlock_test); if(pdata-&gt;flag_hasdata == 1) { printf(&quot;One_Thread has rev data:%s&quot;, pdata-&gt;data);//stdin中的数据自带换行 break; } pthread_rwlock_unlock(&amp;rwlock_test); } printf(&quot;One_Thread End!\\r\\n&quot;); } //写者线程 void *Two_Thread(void *tparam) { Data_t *pdata = tparam; printf(&quot;Two_Thread Start!,Please input data!\\r\\n&quot;); while(1) { pthread_rwlock_wrlock(&amp;rwlock_test); pdata-&gt;flag_hasdata = 0; fgets(pdata-&gt;data, MAXDATASIZE, stdin); printf(&quot;Two_Thread has rev Data!\\r\\n&quot;); pdata-&gt;flag_hasdata = 1; pthread_rwlock_unlock(&amp;rwlock_test); break; } printf(&quot;Two_Thread End!\\r\\n&quot;); } int main(void) { pthread_t one_thread; pthread_t two_thread; Data_t tdata = {0}; pthread_create(&amp;one_thread, NULL, One_Thread, (void *)&amp;tdata); sleep(1); pthread_create(&amp;two_thread, NULL, Two_Thread, (void *)&amp;tdata); pthread_join(one_thread, NULL); pthread_join(two_thread, NULL); printf(&quot;ALL END\\r\\n&quot;); } 自旋锁的实现(在用户态暂时当做mutex看待，在用户态好像没有意义)：自旋锁与互斥锁相似，唯一的区别是当一个线程试图获取一个被锁定的互斥锁时，该操作会失败然后该线程会进入睡眠，让其他线程运行。而当一个线程试图获取一个自旋锁却没成功时，该线程会不断重试，直到最终成功为止,所以在内核态的自旋锁中单核CPU就算关中断也会导致死锁（用户态的单核多线程自旋锁，及其容易产生死锁，因为自旋会占用该CPU大量的时间片，导致主业务无法正常处理，从而难以解锁）。主要实现函数(1-5重要): 1、pthread_spin_init(spinlock_t *lock, 0);//初始化自旋锁，将自旋锁设置为1(未上锁) 2、pthread_spin_lock(spinlock_t *lock);//循环等待，直到自旋锁解锁（被设置为1），然后再将自旋锁锁上(设置为0) 3、pthread_spin_unlock(spinlock_t *lock);//将自旋锁解锁(设置为1) 4、pthread_spin_lock_irq(spinlock_t *lock);//循环等待直到自旋锁解锁(被设置为1)，然后将自旋锁锁上(设置为0)，关中断 5、pthread_spin_unlock_irq(spinlock_t *lock);//将自旋锁解锁(设置为1)，开中断 6、pthread_spin_is_locked(spinlock_t *lock);//如果自旋锁未上锁(值为1)则返回0，否则返回1 7、pthread_spin_unlock_wait();//等待，直到自旋锁解锁(被设置为1) 8、pthread_spin_trylock(spinlock_t *lock);//尝试锁上自旋锁(设置为0) ，如果原来为未上锁状态，则返回1，否则返回0 9、pthread_spin_lock_irqsave(spinlock_t *lock);//循环等待直到自旋锁解锁(被设置为1)，随后将自旋锁上锁(设置为0)。关中断，将状态寄存器值存入flags 10、pthread_spin_unlock_irqsave(spinlock_t *lock);//解锁自旋锁(设置为1)。开中断，将状态寄存器值从flags存入状态寄存器 11、pthread_spin_lock_bh(spinlock_t *lock);//循环等待直到自旋锁解锁(被置为1),随后将自旋锁上锁(置为0)。阻止软中断底半部的执行 12、pthread_spin_unlock_bh(spinlock_t *lock);//将自旋锁解锁(设置为1)。开启底半部的执行 ************************************************************************* &gt; File Name: Spinlock.c &gt; Author:lizhong &gt; Mail: &gt; Created Time: 2017年11月18日 星期六 02时44分07秒 ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; #include&lt;pthread.h&gt; #include&lt;sys/syscall.h&gt; pthread_spinlock_t spinlock_test; void *One_Thread(void *tparam) { unsigned char i = 0; printf(&quot;One_Thread Start!\\r\\n&quot;); pthread_spin_lock(&amp;spinlock_test); for(i = 0; i &lt;= 5; ++i) { sleep(1); printf(&quot;One_Thread i value is:%d\\r\\n&quot;, i); } pthread_spin_unlock(&amp;spinlock_test); } void *Two_Thread(void *tparam) { unsigned char i = 0; printf(&quot;Two_Thread Start!\\r\\n&quot;); //pthread_spin_lock(&amp;spinlock_test); for(i = 0; i &lt;= 5; ++i) { sleep(1); //两线程依然同时输出，说明依然存在内核抢占，线程调度 printf(&quot;Two_Thread i value is:%d\\r\\n&quot;, i); } //pthread_spin_unlock(&amp;spinlock_test); } int main(void) { pthread_t one_thread; pthread_t two_thread; pthread_spin_init(&amp;spinlock_test, 0); pthread_create(&amp;one_thread, NULL, One_Thread, (void *)0); pthread_create(&amp;two_thread, NULL, Two_Thread, (void *)0); pthread_join(one_thread, NULL); pthread_join(two_thread, NULL); printf(&quot;ALL END\\r\\n&quot;); } 补充说明：在linux中大部分用户态API都是使用glibc库实现的，在我这台Centos7（内核版本为3.10.0）上对应的glibc版本是2.17（可通过rpm -qa | grep glibc命令进行查看），通过以下路径可以拿到源码http://git.savannah.gnu.org/cgit/hurd/glibc.git/refs/tags现在，对API的使用或实现，哪里有疑问的直接戳源码查看就好了，这样效率最高了","categories":[],"tags":[{"name":"Linux多线程编程","slug":"Linux多线程编程","permalink":"http://avalonlz.github.io/tags/Linux多线程编程/"}]},{"title":"久坐提醒小Tool","slug":"LongSitWarning","date":"2017-11-08T11:41:15.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/11/08/LongSitWarning/","link":"","permalink":"http://avalonlz.github.io/2017/11/08/LongSitWarning/","excerpt":"最近玩PyQt的兴致有点高，昨天把微信自动回复小tool的历史遗留BUG解决(网上一直没找到解决方案)，今天又小撸了个久坐提醒tool","text":"最近玩PyQt的兴致有点高，昨天把微信自动回复小tool的历史遗留BUG解决(网上一直没找到解决方案)，今天又小撸了个久坐提醒tool效果图： 源代码地址：https://github.com/avalonLZ/PyQT_LongSitWarn 逻辑部分Code如下： # -*- coding:utf-8 -*- import sys import time from lsw_form import * from PyQt4 import QtCore, QtGui class Thread_CountDown(QtCore.QThread): Thread_CountDownSin = QtCore.pyqtSignal() def __init__(self, parent=None): super(Thread_CountDown, self).__init__(parent) self.__oldtime = 0 self.__newtime = 0 self.__ss = &apos;stop&apos; def run(self): while 1: self.__oldtime = time.time() self.__newtime = time.time() while self.__ss == &apos;start&apos;: self.__newtime = time.time() if abs(self.__newtime - self.__oldtime) &gt;= 1: #发送信号到主线程 self.__oldtime = self.__newtime self.Thread_CountDownSin.emit() def start_stop(self, temstr): self.__ss = temstr class MainWindow(QtGui.QWidget): MW2CountDownSin = QtCore.pyqtSignal(str) def __init__(self,parent=None): QtGui.QWidget.__init__(self,parent) self.__ui = Ui_Warn() self.__ui.setupUi(self) self.__popwarncount = 0 self.__timecount = 0 #创建连接 self.connect(self.__ui.about, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_about) self.connect(self.__ui.start, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_start) self.connect(self.__ui.stop, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_stop) #tray不可以用槽直接连接 #self.connect(self.__ui.tray, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_tray) #self.__ui.tray.activated.connect(self.__click_tray)#直接点击弹出主界面 #创建体统托盘图标,可以看出也算是一个插件 self.__ui.tray = QtGui.QSystemTrayIcon(self) trayicon = QtGui.QIcon(QtCore.QString.fromUtf8(&quot;:/img/image2.png&quot;)) self.__ui.tray.setIcon(trayicon) self.__ui.tray.setToolTip(u&quot;Up~Down~请注意休息&quot;) self.__ui.tray.show() # 创建右击菜单 traymenu = QtGui.QMenu() traymenu_reply = traymenu.addAction(u&quot;恢复主界面&quot;) traymenu_exit = traymenu.addAction(u&quot;退出&quot;) traymenu_reply.triggered.connect(self.__click_show) traymenu_exit.triggered.connect(self.__click_end) self.__ui.tray.setContextMenu(traymenu) #创建线程 self.__thread_countdown = Thread_CountDown() self.__thread_countdown.Thread_CountDownSin.connect(self.__pop_warn) self.MW2CountDownSin.connect(self.__thread_countdown.start_stop) self.__thread_countdown.start() def __click_end(self): self.close() def __click_show(self): self.show() def __click_about(self): QtGui.QMessageBox.about(self, u&quot;关于&quot;, u&quot;Up~Down~：60分钟提醒一次\\r\\n&quot; u&quot; by:lz&quot;) def __click_stop(self): self.__timecount = 0 self.__ui.lcd.setProperty(&quot;intValue&quot;, 3600) self.__ui.start.setDisabled(False) self.MW2CountDownSin.emit(&apos;stop&apos;) def __click_start(self): self.__ui.start.setDisabled(True) self.MW2CountDownSin.emit(&apos;start&apos;) pass def __click_tray(self): self.show() def __pop_warn(self): self.__timecount += 1 timecount = 3600 - self.__timecount self.__ui.lcd.setProperty(&quot;intValue&quot;, timecount) if timecount == 0: self.__timecount = 0 self.show() self.__popwarncount += 1 self.__winsta = self.isHidden() self.__warnbox = QtGui.QMessageBox.warning(self, u&quot;休息&quot;, u&quot;请休息5分钟&quot;) if self.__warnbox == 1024 and self.__popwarncount &gt; 0: self.__popwarncount -= 1 if self.__popwarncount == 0 and self.__winsta: self.hide() def closeEvent(self, QCloseEvent): if self.isActiveWindow() == True:#是否是当前活动窗口 self.hide() QCloseEvent.ignore() if __name__ == &quot;__main__&quot;: app = QtGui.QApplication(sys.argv) myapp=MainWindow() #窗口最大化按键无效 myapp.setWindowFlags(QtCore.Qt.WindowMinimizeButtonHint) #锁定窗口大小 myapp.setFixedSize(myapp.width(), myapp.height()) myapp.show() app.exec_()","categories":[],"tags":[{"name":"应用软件_PyQt","slug":"应用软件-PyQt","permalink":"http://avalonlz.github.io/tags/应用软件-PyQt/"}]},{"title":"Design_Model","slug":"Design-Model","date":"2017-11-05T01:17:17.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/11/05/Design-Model/","link":"","permalink":"http://avalonlz.github.io/2017/11/05/Design-Model/","excerpt":"设计模式，虽然没具体学习过，但在项目中或多或少也都使用到了一些思想。","text":"设计模式，虽然没具体学习过，但在项目中或多或少也都使用到了一些思想。 创建型模式创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断对某个给定实例需要创建哪些对象时更加灵活 工厂模式：功能：主要用于创建对象，添加类时。用一个工厂来根据输入条件返回不同类的（基类指针），这些类中有相同功能的都单独被编写了一个基类，并且在基类和子类中都使用virtual来强调方法","categories":[],"tags":[{"name":"软件工程_DesignPatterns","slug":"软件工程-DesignPatterns","permalink":"http://avalonlz.github.io/tags/软件工程-DesignPatterns/"}]},{"title":"UML","slug":"UML","date":"2017-11-04T01:21:06.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/11/04/UML/","link":"","permalink":"http://avalonlz.github.io/2017/11/04/UML/","excerpt":"想学习设计模式，发现UML必不可少。我大自动化就没上过这么专业的专业课T T，先补补UML","text":"想学习设计模式，发现UML必不可少。我大自动化就没上过这么专业的专业课T T，先补补UMLUML（统一建模语言）分为三部分事物、关系和图，这三者关系简单表述就是图 = 事物 + 关系 事物：结构事物 类：具有相同属性/操作的一组集合，用矩形表示，通常矩形中写有类名称以及属性和方法 组件：描述了一些类/接口的包，由一个带小方块的矩形表示，可以将其看做是一个可带有自身属性和方法的库 接口：描述了一个类或组件的方法集。一个类可以实现一个或多个接口，接口用一个带有名称的圆表示。一般依附于实现接口的类或组件中 协作：协作是一组类、接口或其他元素组成的群体。与组件不同，协作不能拥有自身的事物，所以协作更像是一个库。协作一般用一个包含名称的虚线椭圆表示 用例：一组序列动作描述，系统执行这些动作，将对用例的参与者，产生可观察的结果。用实线的椭圆表示，参与者用一个人形的图案表示 节点：表示一个物理元素，它在运行时存在，代表一个可计算的资源，比如一台数据库服务器。节点用一个立方体来表示 主动类：主动类能够启动控制活动，它的对象至少拥有一个进程或线程。主动类的表示也是一个矩形，只是边框使用的是粗线 行为事物结构事物描述的是模型的静态部分，而行为事物描述的是模型的动态部分。 交互：对象都不是孤立存在的，他们之间通过传递消息进行交互。在图形上，交互的消息通常带箭头的直线表示 状态机：一个状态机是一个行为，它说明了对象在它的生命周期中响应时间所经历的状态序列以及它们对那些事件的响应。状态是指在对象的生命周期中，满足某些条件/执行某些活动或等待某些事件时的一个条件或状况。一个事件的到来，能够触发一个状态的转换 分组事物分组事物是UML模型中负责分组的部分，可以把它看做一个个盒子，每个盒子里面的对象关系相对复杂，而盒子与盒子之间的关系相对简单 包：可以将元素组织成组的机制。结构事物或行为事物甚至其他的分组事物都可以放入包内。在图形上，包用一个再左上角带有一个小矩形的大矩形表示 注释事物注释事物是UML模型的解释部分，这些注释事物用来描述、说明和标注模型的任何元素。 注释：一种主要的注释事物是注解。注解图形表示是右上角有折角的矩形 关系：关联描述两个或多个类之间的结构关系。比如企鹅和气候，这两个类就是关联关系，企鹅需要知道，需要了解气候规律，而当一个类“知道”另一个类时，可以用关联。关联用一条实线表示，可以有方向或标记 聚合强关联关系，它表示的是整体与个体之间的关系，即has-a模型。整体和个体之间是可分离的，他们具有各自的生命周期，比如大雁和大雁群之间就是聚合关系。聚合关系用空心的菱形加实线箭头表示 合成也是关联关系的特例， 它表示的是部分和整体的关系，即contations-a模型。这种关系比聚合强，整体和部分之间是不可分离的，他们具有相同的生命周期。比如说大雁和大雁翅膀之间就是合成关系。合成关系用实心菱形加实线箭头表示 依赖依赖是两个事物间的语义关系，其中一个事物（独立事物）发送变化，会影响到另一个事物（依赖事物）。比如人和氧气，人有新陈代谢的行为，而新陈代谢又需要氧气的参与，因此这两个类之间就是依赖关系。一个依赖关系画成一条可能有方向的虚线，偶尔在其上还有一个标记 泛化泛化是一种特殊/一般关系，是一般事物（父类）和该事物较为特殊的种类（子类）之间的关系。 实现实现是结构事物间的语义关系，实现关系就是将一种元素（如类）与另一种元素（如接口）连接起来，其中接口只是行为的定义，而行为的具体实现，则由类来给出。比如说麻雀类和飞翔接口，麻雀就可以实现飞翔的接口。两种表示方法，一是空心三角加虚线，二是实线加空心圆圈。一般在两处会用到实现，一是在接口和实现他们的类或组件之间，另一种是在用例和实现他们的协作之间 图：结构型UML（5种） 类图 构件图 部署图 包图 对象图 行为型UML（6种） 活动图 状态机图 顺序图 用例图 通信图 时序图 分析业务概念模式：类图 组织类图：包图 分析IT基础架构、软件架构：构件图、部署图 分析业务流程：活动图、状态机图、顺序图，其中大部分都使用活动图。若某流程围绕某个物品进行，且该物品在流程中转换多种状态，那么首选状态机图。若想清晰表达某过程中角色与角色之间的关系，各角色是如何进入过程的首选顺序图（顺序图更加强调角色先后顺序，通信图则更强调角色间相互关系） 系统的表达需求：用例图","categories":[],"tags":[{"name":"软件工程_UML","slug":"软件工程-UML","permalink":"http://avalonlz.github.io/tags/软件工程-UML/"}]},{"title":"0183协议生成器","slug":"0183Protocol_Produce","date":"2017-10-29T04:25:10.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/10/29/0183Protocol_Produce/","link":"","permalink":"http://avalonlz.github.io/2017/10/29/0183Protocol_Produce/","excerpt":"为模拟GPS数据给到AIS模块，随手写了这么个工具，顺便复习下快、准、狠，开发效率极高的pyqt（亲测稳定性也OK，QT本一家，所以关键的还是思路）","text":"为模拟GPS数据给到AIS模块，随手写了这么个工具，顺便复习下快、准、狠，开发效率极高的pyqt（亲测稳定性也OK，QT本一家，所以关键的还是思路）开发环境(IDE自然是pycharm)：python-2.7.9.amd64 + PyQt4-4.10.3-gpl-Py2.7-Qt4.8.5-x64 + pywin32-216.win-amd64-py2.7 + pyserial-3.4 + py2exe-0.6.9.win64-py2.7.amd64效果图： 源码地址：https://github.com/avalonLZ/PyQT_GIS 逻辑部分Code如下： # -*- coding: utf-8 -*- import sys import time from gis_form import * from PyQt4 import QtCore, QtGui import serial import serial.tools.list_ports #$GNGGA,033723.000,2308.9503,N,11325.9527,E,6,06,4.1,30.6,M,0.0,M,,*40 #$GNRMC,033723.000,A,2308.9503,N,11325.9527,E,999.00,103.94,261017,,,E*72 #GIS信息校验 def GIS_Check(temstr): checksum = 0 for i in temstr: checksum = checksum ^ ord(str(i))#注意需要一个str return checksum #串口扫描，返回存在的COM口 def serial_ports(open_com = None): ports = [] port_list = list(serial.tools.list_ports.comports()) for i in port_list: ports.append(str(i.device)) return ports class Thread_SendData(QtCore.QThread): def __init__(self, temstr = &apos;&apos;, parent=None, obj = None): super(Thread_SendData, self).__init__(parent) self.temstr = temstr self.serial = obj.ser self.interval = obj.return_interval() self.display = obj.return_ui_display() self.nostop = 1 def run(self): while self.nostop:#while结束线程也就退出了 self.serial.write(str(self.temstr)) self.display.append(str(self.temstr)) self.display.currentFont() time.sleep(int(self.interval)) def senddata_stop(self):#若写为私有函数则主线程中的sin无法绑定此函数（无法绑定到不同类的私有函数上） self.nostop = 0 old_port = []#保证不一致刷新com口数量 class Thread_ScanCom(QtCore.QThread): sinOut = QtCore.pyqtSignal(list) def __init__(self, parent=None): super(Thread_ScanCom, self).__init__(parent) self.new_port = [] def run(self): while 1: old_port = self.new_port self.new_port = serial_ports() if self.new_port != old_port: self.sinOut.emit(self.new_port)#发送信号到主线程 class MainWindow(QtGui.QWidget): sin2senddatastop = QtCore.pyqtSignal()#类变量，可由类名直接调用，也可由实例调用。一个线程只能绑定一个信号量 ser = serial.Serial() def __init__(self,parent=None): QtGui.QWidget.__init__(self,parent) self.__ui = Ui_Windows() self.__ui.setupUi(self) self.__param_init() self.__solt_init() # 创建线程扫描com变化 self.thread_scancom = Thread_ScanCom() self.thread_scancom.sinOut.connect(self.__scancom) self.thread_scancom.start() def __click_start(self): if self.__ui.comboBox.currentText() == &apos;&apos; or str(self.__ui.serial.currentText()) == &apos;&apos;: QtGui.QMessageBox.warning(self, u&quot;错误&quot; ,u&quot;串口或波特率错误，请检查&quot;) return self.__ui_disable(self.__ui.start) self.__ui_disable(self.__ui.clean) self.__serial_config(serial = self.ser, port = str(self.__ui.serial.currentText()), baudrate = int(self.__ui.comboBox.currentText())) #若已经打开，关闭前将无法再次打开，此后的程序不再执行 self.ser.open() self.__gis_fill() #创建线程按1秒间隔发送gis信息 self.__thread_senddata = Thread_SendData(temstr = self.gga + &apos;\\r\\n&apos; + self.rmc + &apos;\\r\\n&apos;, obj = self) self.sin2senddatastop.connect(self.__thread_senddata.senddata_stop) # 绑定信号 self.__thread_senddata.start() def __click_end(self): self.__ui_enable(self.__ui.start) self.__ui_enable(self.__ui.clean) self.sin2senddatastop.emit() self.ser.close() def __click_cleandisplay(self): self.__ui.display.clear() def __click_about(self): QtGui.QMessageBox.about(self, u&quot;关于&quot;, u&quot;0183协议生成器\\r\\n从指定串口输出0183协议数据\\r\\n&quot; u&quot; by:lz&quot;) def __scancom(self, com_list): self.__ui.serial.clear() self.__ui.serial.addItems(com_list) def __param_init(self): self.gga1 = &quot;$GNGGA,033723.000,&quot; self.latitudenum = &quot;2308.9503&quot; # 纬度 self.gga2 = &quot;,N,&quot; self.longitudenum = &quot;11325.9527&quot; # 经度 self.gga3 = &quot;,E,6,06,4.1,30.6,M,0.0,M,,*&quot; self.ggachecknum = &quot;0&quot; self.gga = &quot;&quot; self.rmc1 = &quot;$GNRMC,033723.000,A,&quot; self.rmc2 = &quot;,N,&quot; self.rmc3 = &quot;,E,&quot; self.speednum = &quot;999.00&quot; self.rmc4 = &quot;,103.94,261017,,,E*&quot; self.rmcchecknum = &quot;0&quot; self.rmc = &quot;&quot; self.interval = &quot;&quot; def __solt_init(self): self.connect(self.__ui.start, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_start) self.connect(self.__ui.end, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_end) self.connect(self.__ui.clean, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_cleandisplay) self.connect(self.__ui.about, QtCore.SIGNAL(&quot;clicked()&quot;), self.__click_about) def __serial_config(self, serial = None, port = None, baudrate = None, bytesize = 8, stopbits = 1, parity = &apos;N&apos;): serial.port = port serial.baudrate = baudrate serial.bytesize = bytesize serial.stopbits = stopbits serial.parity = parity def __gis_fill(self): self.longitudenum = self.__ui.longutide.text() self.latitudenum = self.__ui.latitude.text() self.speednum = self.__ui.speed.text() self.gga = self.gga1 + self.latitudenum + self.gga2 + self.longitudenum + self.gga3 self.ggachecknum = GIS_Check(self.gga) self.gga += hex(self.ggachecknum)[2:] self.rmc = self.rmc1 + self.latitudenum + self.rmc2 + self.longitudenum + self.rmc3 + self.speednum + self.rmc4 self.rmcchecknum = GIS_Check(self.rmc) self.rmc += hex(self.rmcchecknum)[2:] self.interval = self.__ui.interval.text() def __ui_disable(self, obj = None): obj.setDisabled(True) def __ui_enable(self, obj = None): obj.setDisabled(False) def return_ui_display(self): return self.__ui.display def return_interval(self): return self.interval if __name__ == &quot;__main__&quot;: app = QtGui.QApplication(sys.argv) myapp=MainWindow() #窗口最大化按键无效 myapp.setWindowFlags(QtCore.Qt.WindowMinimizeButtonHint) #锁定窗口大小 myapp.setFixedSize(myapp.width(), myapp.height()) myapp.show()","categories":[],"tags":[{"name":"应用软件_PyQt","slug":"应用软件-PyQt","permalink":"http://avalonlz.github.io/tags/应用软件-PyQt/"}]},{"title":"Linux多线程编程之线程初始化","slug":"Linux-MultiThreadInit","date":"2017-10-10T00:49:39.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/10/10/Linux-MultiThreadInit/","link":"","permalink":"http://avalonlz.github.io/2017/10/10/Linux-MultiThreadInit/","excerpt":"Linux多线程(用户态线程)编程之线程初始化相关知识点","text":"Linux多线程(用户态线程)编程之线程初始化相关知识点 调度策略在Linux中，创建一个用户进程的同时也必然创建了一个用户线程，同时在内核中也就创建了一个LWP和一个内核线程。若再创建一个用户线程，则同时在内核中又会创建一个LWP和一个内核线程。于是在这个进程执行时，Linux调度系统就会对这两个用户线程进行调度，调度的方式就是对这两个用户线程对应的内核线程进行调度（默认采用SCHED_OTHER方式进行调度）内核态线程调度（实时调度，即支持高优先级抢占运行）： SCHED_OTHER//分时调度,它的特点是即使是最低优先级，他也能获得一定的时间片. SCHED_FIFO//实时调度，先到先服务。高优先级会抢占低优先级，高优先级运行期间，低优先级没法抢占，只能等到高优先级挂起；对于同等优先级，先运行的进程会一直占据cpu, 只有等到先运行的线程挂起后，后续线程才能得到时间片。 SCHED_RR//实时调度，时间片轮转。高优先级会抢占低优先级，高优先级运行期间，低优先级没法抢占，只能等到高优先级挂起, ；对于同等优先级的线程，各个线程会轮流运行一定的时间片（Linux是100ms）。 可以使用以下API改变线程调度算法:int pthread_attr_init(pthread_attr_tattr);//初始化线程属性int pthread_attr_setschedpolicy(pthread_attr_t attr, int policy);//改变内核态线程的调度算法 Linux内核态线程调度算法中的SCHED_RR和大部分RTOS的线程调度算法类似。即具有高优先级抢占特性，也就是在多线程中，高优先级的线程是无条件抢占CPU的，如果高优先级线程未挂起，则低优先级线程将一直不会被执行。若多个线程处于相同优先级时则会对这几个同优先级的线程采用时间片轮转算法，但在一些RTOS(ucos)中并不支持时间片轮转算法，只支持优先级抢占任务调度，在这种RTOS中的任务必须有不同的优先级 未完…","categories":[],"tags":[{"name":"Linux多线程编程","slug":"Linux多线程编程","permalink":"http://avalonlz.github.io/tags/Linux多线程编程/"}]},{"title":"Lua_Notes","slug":"Lua-Notes","date":"2017-08-15T12:18:29.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/08/15/Lua-Notes/","link":"","permalink":"http://avalonlz.github.io/2017/08/15/Lua-Notes/","excerpt":"lua脚本语言学习记录","text":"lua脚本语言学习记录 Vim下Lua的补全（只能实现到支持Lua标准库）使用Vundle + vim-lua-ftplugin + vim-misc1、安装Vundle2、在命令行输入vim ~/.vimrc对.vimrc文件进行修改3、在My Bundles here：下加入，并保存退出： Bundle ‘xolox/vim-lua-ftplugin’ Bundle ‘xolox/vim-misc’4、开启vim，输入:BundleInstall，安装vim-lua-ftplugin和vim-misc插件，重启vim即可使用补全 C/C++中嵌入Lua脚本Lua文件： function test_print() print(&quot;test!&quot;) end CPP文件： #include&lt;iostream&gt; extern &quot;C&quot;{ #include&lt;lua.h&gt; #include&lt;lualib.h&gt; #include&lt;lauxlib.h&gt; } using namespace std; int main() { lua_State *L = luaL_newstate(); luaL_openlibs(L);//加载lua通用扩展库 if(L == NULL) cout &lt;&lt; &quot;Lua Error&quot; &lt;&lt; endl; if(luaL_loadfile(L, &quot;test.lua&quot;) != LUA_OK)//载入lua脚本 cout &lt;&lt; &quot;Load File Error!&quot; &lt;&lt; endl; if(lua_pcall(L, 0, 0, 0))//加载完lua文件后需要先运行一遍文件，此后才可以对文件内容操作 cout &lt;&lt; &quot;Load lua field error!&quot; &lt;&lt; endl; lua_getglobal(L, &quot;test_print&quot;);//将函数压入栈中 if(lua_pcall(L, 0, 0, 0))//执行函数 { cout &lt;&lt; &quot;Run lua Function Error!&quot; &lt;&lt; endl; const char *tempstr = lua_tostring(L, -1); cout &lt;&lt; tempstr &lt;&lt; endl; } lua_close(L); } 编译链接：g++ main.cpp -llua -ldl Lua中使用C/C++模块一般采用动态链接库的方式载入模块，所以首先要先编译C/C++文件，生成动态链接库 头文件： #ifndef _CPPLUALIB_H #define _CPPLUALIB_H #ifdef __cplusplus //以下内容按C的规则进行编译 extern &quot;C&quot;{ #endif /*必须在h文件中加入这几个头文件，否则认不到LUA_API*/ /*防止重复定义，可以自己宏定义个flag*/ #include&quot;lua.h&quot; #include&quot;lualib.h&quot; #include &quot;lauxlib.h&quot; LUA_API int luaopen_my_lib(lua_State *L); #ifdef __cplusplus } #endif #endif C++文件： #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string&gt; #include &quot;cpplualib.h&quot; using namespace std; static int SayHello(lua_State *L) { cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl; int num = lua_gettop(L); cout &lt;&lt; num &lt;&lt; endl; // cout &lt;&lt; temstr &lt;&lt; endl;//所有参数都被放入L栈中 //lua_pushstring(L, &quot;LZ&quot;); return num;//返回所有压栈数量 } static const struct luaL_Reg my_lib[] = { {&quot;SayHello&quot;, SayHello}, {NULL, NULL} }; int luaopen_my_lib(lua_State *L) //必须和上面的数组同名，并且生成的动态链接库也必须命名为my_lib.so { luaL_newlib(L, my_lib); return 1; } Lua文件： local mylib = require &quot;my_lib&quot;//导入模块 print (mylib.SayHello(&quot;mytest&quot;, 1,2,3)) 生成动态链接库：g++ -fPIC -shared -o my_lib.so xxx.cpp 执行Lua脚本：lua xxx.lua即可看到打印输出 语法糖1、 t_table = {} t_table[&quot;li&quot;] = &quot;lizhong&quot; --等价于t_table.li = &quot;lizhong&quot; 2、 t_table = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, key1 = &apos;cc&apos;, &apos;bb&apos;} for i = 1, #t_table do --#t获取table中key为数字的个数，key为nil的元素则不统计。table.maxn则以最大数字下角标为准，统计nil print(t_table[i]) --输出a, b, c, bb end 3、 必用脚本语法1、脚本开头可加#！/usr/local/bin/lua用于指定解释器路径，可不用显式使用lua。（实际测试结果：还是需要显式使用lua xxx.lua才能执行）2、单行注释：– //两个减号多行注释：–[[xxxxxxxxx –]]3、标识符（变量名）：不要使用下划线加大写字母的标识符，因为lua中的保留字一般这样写。约定下划线开头连接一串大写字母的名字（_VERSION）被保留用于lua内部全局变量。lua区分大小写4、全局变量：默认情况下，变量总是全局的，给一个变量赋值后即创建了这个全局变量，访问一个没初始化的全局变量会返回nil，若希望删除一个全局变量，只需要将变量赋值为nil（也就是说，当且仅当一个变量不等于nil时，这个变量即存在） 数据类型脚本语言无需定义变量类型，只需要对变量进行赋值nil：表示一个无效值（具有删除作用，给一个）boolean：false和truenumber：表示双精度类型的实浮点数（可以看出lua中的数值都按此类表示）string：字符串由一对双引号或单引号来表示 string1 = &apos;hello&apos; string2 = &quot;hello&quot; string3 = [[123, 456 78965413 ]] --[[]]可表示一块字符串 print(&apos;2&apos;+6) --return 8.0,lua会自动将数字字符串转换为一个10进制数字，直接丢弃其引号 print(#&apos;132123&apos;) --用#计算字符串长度 function：由C或lua编写的函数 function test(n) print(n) test1 = test test1(10) --lua中函数可以直接赋值给变量，通过变量调用此函数 function printf(n,fun) fun(n) printf(1, function(m) print(m) end) --function定义一个匿名函数 userdata：表示任意存储在变量中的C数据结构，可以将C/C++中的任意数据类型（通常是struct和指针）存储到lua变量中调用thread：表示执行的独立线路，用于执行协同程序table：一个关联数组，用{}来创建。（可以看出table类似于Python中的字典，只不过此处更适合看做是变量和其值的集合） key的几种类型： dir0 = {[&quot;key1&quot;] = 1, key2 = 2} --等价，key定义时若为数字或字符串则需加[] dir1 = {key1 = &apos;value1&apos;, key2 = &apos;value2&apos;} --需要使用dir1[&quot;key1&quot;]进行索引 dir2 = {&apos;value1&apos;, &apos;value2&apos;} --一维数组 --等价于：dir2 = {[1] = &apos;value1&apos;, [2] = &apos;value2&apos;} -需要使用dir2[1]和dir[2]进行索引，注意lua中下标是从1开始计数的，而非0 dir3 = {i = &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, ii = &apos;d&apos;, &apos;e&apos;} -- dir3[3]返回e 可以使用type函数查询类型：print(type(“123”)) –&gt;stringprint(type(123)) –&gt;number do end –相当于C++中的{}名称空间 lua变量局部变量的作用域仅限于声明他们的那个块。块可以是一个控制结构的执行体、一个函数的执行体或者是一个程序块（do end中间的部分）（所声明的局部变量的作用域从声明语句开始，直至所在块的结尾） x = 10 --没有local就默认为全局变量，在函数中也是如此 local i = 1 --程序块中的局部变量 while i &lt;= x do local x = i * 2 --while循环体中的局部变量 print(x) --while循环体中的局部变量，输出2,4,6,8... i = i +1 end if i &gt; 20 then local x --then中的局部变量 x = 20 --then中的局部变量 print(x + 2) --then中的局部变量，输出22 else print(x) --开头定义的全局变量x,输出10 end print(x) --开头定义的全局变量x，输出10 注意：交互模式下每输入一行语句都会成为一个程序块，所以想在交互模式下正确指定作用域，就需要显示的用do end来指定块 关系操作符只能对两个数字或两个字符串做大小比较，不同类的会返回false。字符串的比较是按照字母次序例如： &quot;bc&quot; &lt; &quot;ace&quot; --&gt;返回false &quot;2&quot; &lt; &quot;15&quot; --&gt;返回false &quot;a&quot; &gt; &quot;9&quot; --&gt;返回true，说明字母字符串总大于数字字符串 nil只与其自身相等 ~= –不等= –赋值，注意table的赋值是引用（不同于深浅拷贝） a = {&apos;a&apos;, &apos;b&apos;} c = a c[1] = &apos;z&apos; print(a[1]) --&gt;返回z，说明是引用 c = {&apos;v&apos;, &apos;r&apos;} print(a[1]) --&gt;返回z，说明c已经变为了另一个table的引用 逻辑运算符not 数字 –&gt;输出都为falsenot nil –&gt;输出truenot false –&gt;输出true(a &gt; b) and a or b –&gt;a若大于b则括号内成立，则true and a or b,根据短路法则直接返回true and a。（and对应&amp;&amp;，or对应||）,有nil参与的逻辑运算可将nil视为0 字符串连接符..（两个点），如果任意一边是数字则会将数字直接转换为字符串（直接加引号）再进行连接输出。 运算符优先级由高到低（高优先级先执行）： ^（右结合:x^y^z &lt;--&gt; x^(y^z)） not # - * / % + - ..（右结合） &lt; &gt; &lt;= &gt;= -= == and or 多重赋值交换：x, y = y, x –x与y互换右边值多于左边变量，值会被丢弃。右边值少于左边变量，多出的变量被置为nil 控制结构注意：在控制结构中所有不是false和nil的值都会被视为真（数字0也是真） if ... then ... else ... end if ... then ... elseif ... then ... else ... end whie ... do ... end repeat --重复执行循环体，直到条件为真 ... until ...（条件） --数值for循环 --var从exp1变化到exp2，每次变化以exp3为步长递增，并执行一次循环体，若不存在exp3，则默认步长为1。for的三个表达式在循环开始前进行一次性求值，之后不再求值 for var = exp1, exp2, exp3 do &lt;执行体&gt; end --泛型for循环（注意pairs是无序的，ipairs是有序的） dir3 = {i = &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, ii = &apos;d&apos;, &apos;e&apos;} --pairs(dir3)方法可以用于遍历table,可以遍历表中所有的key。 --ipairs(dir3)只能遍历到表中出现第一个不是整数的key。也就是说ipairs(dir3)只可以遍历出b,c,e dir3 = {[2] = &apos;b&apos;, &apos;c&apos;, &apos;e&apos;}--这样ipairs将遍历出c,e。因为[2]的值再e定义时被改写了 dir3 = {key1 = &apos;a&apos;, key2 = &apos;b&apos;}--这样ipairs将无法遍历，直接跳出循环，因为dir3[1]=nil --pairs和ipairs只能遍历一维数据，多维数据还是要依赖for循环 多重返回函数function foo() return &apos;a&apos;, &apos;b&apos; end function goo(i, j, k) return i, j, k end --若foo()被调用，并且不是一系列表达式的最后一个元素，那么Lua会将其返回值数量调整为1 x, y = foo(), 10 --x = &apos;a&apos;, y = 10 print(foo(), 2) --输出a, 2 goo(foo()) --输出a, b, nil goo(foo(), 1) --foo将只返回一个值,输出a, 1, nil goo((foo())) --foo()放入括号内将迫使它只返回一个值a, nil, nil --泛型调用，unpack(),接受一个数组table作为参数，并从下标1开始返回该数组的所有元素,与ipairs相似，只不过这个可以直接返回值 list1 = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;} print(table.unpack(list1)) --变长参数 function add(...) local s = 0 for i, v in ipairs(...) do s = s + v end return s end print(add({10, 20, 30, 40})) --返回100,注意...处需要传入的是一个table function foo(...) local a, b, c, e, f =... end function goo(a, ...) -- 在变长参数...前可以加入固定参数 print(a, ...) --注意...处需要传入table，零散的参数不可以 end","categories":[],"tags":[{"name":"计算机语言_Lua","slug":"计算机语言-Lua","permalink":"http://avalonlz.github.io/tags/计算机语言-Lua/"}]},{"title":"自写Terminal服务器Web部分","slug":"Django-Terminal","date":"2017-06-18T14:52:14.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/06/18/Django-Terminal/","link":"","permalink":"http://avalonlz.github.io/2017/06/18/Django-Terminal/","excerpt":"之前自己用Python写了一个Terminal服务器的后台入库程序，但是由于协议解析部分涉及公司内的私有协议所以不便放出，现在继续这一工程，进一步学习Django、Bootstrap和JS。简单实现下手上定位终端的服务器Web部分(基本上就是简单的Web数据显示)，此文章记录了此次实现的全过程","text":"之前自己用Python写了一个Terminal服务器的后台入库程序，但是由于协议解析部分涉及公司内的私有协议所以不便放出，现在继续这一工程，进一步学习Django、Bootstrap和JS。简单实现下手上定位终端的服务器Web部分(基本上就是简单的Web数据显示)，此文章记录了此次实现的全过程 目前实现效果如下(咯简陋的点,前端只学了一丢丢)：Login：Index：Admin： 项目地址https://github.com/avalonLZ/Django_Terminal 数据库设计对于这类Web应用，数据库的设计在写后台单独的入库程序的时候大部分就应该要设计好了，下图为我的数据库设计框图（哈哈，也比较简单，就用了外键的形式连接各表）：","categories":[],"tags":[{"name":"服务器_Django","slug":"服务器-Django","permalink":"http://avalonlz.github.io/tags/服务器-Django/"}]},{"title":"Tinyhttpd（C语言实现的Http1.0 Server）笔记","slug":"Notes-Tinyhttpd","date":"2017-05-29T12:24:27.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/05/29/Notes-Tinyhttpd/","link":"","permalink":"http://avalonlz.github.io/2017/05/29/Notes-Tinyhttpd/","excerpt":"Tinyhttpd是一款超轻量级的C语言http服务器实现，整体框架十分简单，即使用多线程对多个Client发来的Http请求作出解析，并以多进程的方式实现CGI交互。下面将对源码进行解读","text":"Tinyhttpd是一款超轻量级的C语言http服务器实现，整体框架十分简单，即使用多线程对多个Client发来的Http请求作出解析，并以多进程的方式实现CGI交互。下面将对源码进行解读配图：Http协议请求数据格式 /* J. David&apos;s webserver */ /* This is a simple webserver. * Created November 1999 by J. David Blackstone. * CSE 4344 (Network concepts), Prof. Zeigler * University of Texas at Arlington */ /* This program compiles for Sparc Solaris 2.6. * To compile for Linux: * 1) Comment out the #include &lt;pthread.h&gt; line. * 2) Comment out the line that defines the variable newthread. * 3) Comment out the two lines that run pthread_create(). * 4) Uncomment the line that runs accept_request(). * 5) Remove -lsocket from the Makefile. */ /*此程序只适用于Http1.0的协议，对于Http1.1的TCP长连接协议并不支持*/ #include &lt;stdio.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/types.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;ctype.h&gt; #include &lt;strings.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;pthread.h&gt; #include &lt;sys/wait.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; /*用于检测x是否为空格字符(空格(&apos; &apos;)、水平定位字符 (&apos;\\t&apos;)、归位键(&apos;\\r&apos;)、换行(&apos;\\n&apos;)、垂直定位字符(&apos;\\v&apos;)或翻页(&apos;\\f&apos;)都是空格字符)*/ #define ISspace(x) isspace((int)(x)) #define SERVER_STRING &quot;Server: jdbhttpd/0.1.0\\r\\n&quot; #define STDIN 0 #define STDOUT 1 #define STDERR 2 void accept_request(void *); void bad_request(int); void cat(int, FILE *); void cannot_execute(int); void error_die(const char *); void execute_cgi(int, const char *, const char *, const char *); int get_line(int, char *, int); void headers(int, const char *); void not_found(int); void serve_file(int, const char *); int startup(u_short *); void unimplemented(int); /**********************************************************************/ /* A request has caused a call to accept() on the server port to * return. Process the request appropriately. * Parameters: the socket connected to the client */ /**********************************************************************/ void accept_request(void *arg) { int client = (intptr_t)arg; char buf[1024]; size_t numchars; char method[255]; char url[255]; char path[512]; size_t i, j; struct stat st; int cgi = 0; /* becomes true if server decides this is a CGI * program */ char *query_string = NULL; /*获取Http协议第一行(请求行)数据*/ numchars = get_line(client, buf, sizeof(buf)); i = 0; j = 0; while (!ISspace(buf[i]) &amp;&amp; (i &lt; sizeof(method) - 1)) { method[i] = buf[i]; i++; } j=i; method[i] = &apos;\\0&apos;; /*不区分大小写判断是GET方式还是POST方式*/ if (strcasecmp(method, &quot;GET&quot;) &amp;&amp; strcasecmp(method, &quot;POST&quot;)) { unimplemented(client); return; } if (strcasecmp(method, &quot;POST&quot;) == 0) cgi = 1; i = 0; while (ISspace(buf[j]) &amp;&amp; (j &lt; numchars)) j++; /*获取Http协议中的URL字节段*/ while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; numchars)) { url[i] = buf[j]; i++; j++; } url[i] = &apos;\\0&apos;; /*如果是GET方法则先遍历一遍URL判断是否带有参数，并将问号后的部分截断*/ if (strcasecmp(method, &quot;GET&quot;) == 0) { query_string = url; while ((*query_string != &apos;?&apos;) &amp;&amp; (*query_string != &apos;\\0&apos;)) query_string++; if (*query_string == &apos;?&apos;) { cgi = 1; *query_string = &apos;\\0&apos;; query_string++; } } /*index.html放在htdocs文件夹中*/ sprintf(path, &quot;htdocs%s&quot;, url); /*默认路径即访问index.html*/ if (path[strlen(path) - 1] == &apos;/&apos;) strcat(path, &quot;index.html&quot;);//拼接两字符串 /*在系统中寻找Client访问的页面*/ if (stat(path, &amp;st) == -1) { while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); not_found(client); } else { /*若访问的文件是目录*/ if ((st.st_mode &amp; S_IFMT) == S_IFDIR) strcat(path, &quot;/index.html&quot;); /*若访问的可执行文件(并判断了是否有权限)*/ if ((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH) ) cgi = 1; if (!cgi) /*不需要调用CGI程序，返回一个html文件*/ serve_file(client, path); else /*若为POST方式则query_string为NULL，GET方式query_string为传入CGI的参数*/ execute_cgi(client, path, method, query_string); } close(client); } /**********************************************************************/ /* Inform the client that a request it has made has a problem. * Parameters: client socket */ /**********************************************************************/ void bad_request(int client) { char buf[1024]; sprintf(buf, &quot;HTTP/1.0 400 BAD REQUEST\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;Content-type: text/html\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;&lt;P&gt;Your browser sent a bad request, &quot;); send(client, buf, sizeof(buf), 0); sprintf(buf, &quot;such as a POST without a Content-Length.\\r\\n&quot;); send(client, buf, sizeof(buf), 0); } /**********************************************************************/ /* Put the entire contents of a file out on a socket. This function * is named after the UNIX &quot;cat&quot; command, because it might have been * easier just to do something like pipe, fork, and exec(&quot;cat&quot;). * Parameters: the client socket descriptor * FILE pointer for the file to cat */ /**********************************************************************/ void cat(int client, FILE *resource) { char buf[1024]; fgets(buf, sizeof(buf), resource); while (!feof(resource)) { send(client, buf, strlen(buf), 0); fgets(buf, sizeof(buf), resource); } } /**********************************************************************/ /* Inform the client that a CGI script could not be executed. * Parameter: the client socket descriptor. */ /**********************************************************************/ void cannot_execute(int client) { char buf[1024]; sprintf(buf, &quot;HTTP/1.0 500 Internal Server Error\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;P&gt;Error prohibited CGI execution.\\r\\n&quot;); send(client, buf, strlen(buf), 0); } /**********************************************************************/ /* Print out an error message with perror() (for system errors; based * on value of errno, which indicates system call errors) and exit the * program indicating an error. */ /**********************************************************************/ void error_die(const char *sc) { perror(sc); exit(1); } /**********************************************************************/ /* Execute a CGI script. Will need to set environment variables as * appropriate. * Parameters: client socket descriptor * path to the CGI script */ /**********************************************************************/ void execute_cgi(int client, const char *path, const char *method, const char *query_string) { char buf[1024]; int cgi_output[2]; int cgi_input[2]; pid_t pid; int status; int i; char c; int numchars = 1; int content_length = -1; buf[0] = &apos;A&apos;; buf[1] = &apos;\\0&apos;; if (strcasecmp(method, &quot;GET&quot;) == 0) while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); else if (strcasecmp(method, &quot;POST&quot;) == 0) /*POST*/ { numchars = get_line(client, buf, sizeof(buf)); while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) { /*将Content-Length:截断出来单独作为一段字符串，用来获取content_length*/ buf[15] = &apos;\\0&apos;; if (strcasecmp(buf, &quot;Content-Length:&quot;) == 0) content_length = atoi(&amp;(buf[16])); numchars = get_line(client, buf, sizeof(buf)); } if (content_length == -1) { bad_request(client); return; } } else/*HEAD or other*/ { } if (pipe(cgi_output) &lt; 0) { cannot_execute(client); return; } if (pipe(cgi_input) &lt; 0) { cannot_execute(client); return; } if ( (pid = fork()) &lt; 0 ) { cannot_execute(client); return; } /*将响应头HTTP/1.0 200 OK\\r\\n写入buf中*/ sprintf(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); /*发送响应头*/ send(client, buf, strlen(buf), 0); /*子进程执行CGI程序*/ if (pid == 0) /* child: CGI script */ { char meth_env[255]; char query_env[255]; char length_env[255]; dup2(cgi_output[1], STDOUT); dup2(cgi_input[0], STDIN); close(cgi_output[0]); close(cgi_input[1]); sprintf(meth_env, &quot;REQUEST_METHOD=%s&quot;, method); putenv(meth_env); if (strcasecmp(method, &quot;GET&quot;) == 0) { sprintf(query_env, &quot;QUERY_STRING=%s&quot;, query_string); putenv(query_env); } else { /* POST */ sprintf(length_env, &quot;CONTENT_LENGTH=%d&quot;, content_length); putenv(length_env); } /*执行CGI*/ execl(path, NULL); exit(0); } else { /* parent */ close(cgi_output[1]); close(cgi_input[0]); if (strcasecmp(method, &quot;POST&quot;) == 0) for (i = 0; i &lt; content_length; i++) { /*并非重头开始读取，因为经过先前的读取操作，文件偏移量已经指向了content*/ recv(client, &amp;c, 1, 0); write(cgi_input[1], &amp;c, 1); } //waitpid(pid, &amp;status, 0);//我认为应该放在此处 while (read(cgi_output[0], &amp;c, 1) &gt; 0) send(client, &amp;c, 1, 0); close(cgi_output[0]); close(cgi_input[1]); /*此处存在疑问，不应该将waitpid放在前面吗?以确保子进程先运行*/ waitpid(pid, &amp;status, 0); } } /**********************************************************************/ /* Get a line from a socket, whether the line ends in a newline, * carriage return, or a CRLF combination. Terminates the string read * with a null character. If no newline indicator is found before the * end of the buffer, the string is terminated with a null. If any of * the above three line terminators is read, the last character of the * string will be a linefeed and the string will be terminated with a * null character. * Parameters: the socket descriptor * the buffer to save the data in * the size of the buffer * Returns: the number of bytes stored (excluding null) */ /**********************************************************************/ int get_line(int sock, char *buf, int size) { int i = 0; char c = &apos;\\0&apos;; int n; while ((i &lt; size - 1) &amp;&amp; (c != &apos;\\n&apos;)) { /*读取一个字节数据到c中flags为0时和read()函数效果相同，返回实际读取的字节数*/ n = recv(sock, &amp;c, 1, 0); /* DEBUG printf(&quot;%02X\\n&quot;, c); */ if (n &gt; 0) { /*读取到一个回车符后，再用MSG_PEEK方式读取一个字节数据判断是否是换行符*/ /*MSG_PEEK和read()的不同在于:用MSG_PEEK时文件的偏移量并未改变， 下次再read()出的值和此时MSG_PEEK得出的值相同*/ if (c == &apos;\\r&apos;) { n = recv(sock, &amp;c, 1, MSG_PEEK); /* DEBUG printf(&quot;%02X\\n&quot;, c); */ if ((n &gt; 0) &amp;&amp; (c == &apos;\\n&apos;)) recv(sock, &amp;c, 1, 0); else c = &apos;\\n&apos;; } buf[i] = c; i++; } else c = &apos;\\n&apos;; } /*使读出的一行作为一串字符串*/ buf[i] = &apos;\\0&apos;; return(i); } /**********************************************************************/ /* Return the informational HTTP headers about a file. */ /* Parameters: the socket to print the headers on * the name of the file */ /**********************************************************************/ void headers(int client, const char *filename) { char buf[1024]; (void)filename; /* could use filename to determine file type */ strcpy(buf, &quot;HTTP/1.0 200 OK\\r\\n&quot;); send(client, buf, strlen(buf), 0); strcpy(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); strcpy(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); } /**********************************************************************/ /* Give a client a 404 not found status message. */ /**********************************************************************/ void not_found(int client) { char buf[1024]; sprintf(buf, &quot;HTTP/1.0 404 NOT FOUND\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;The server could not fulfill\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;your request because the resource specified\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;is unavailable or nonexistent.\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); } /**********************************************************************/ /* Send a regular file to the client. Use headers, and report * errors to client if they occur. * Parameters: a pointer to a file structure produced from the socket * file descriptor * the name of the file to serve */ /**********************************************************************/ void serve_file(int client, const char *filename) { FILE *resource = NULL; int numchars = 1; char buf[1024]; buf[0] = &apos;A&apos;; buf[1] = &apos;\\0&apos;; while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\\n&quot;, buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); /*以只读方式打开文件*/ resource = fopen(filename, &quot;r&quot;); if (resource == NULL) not_found(client); else { /*将文件context封装为Http协议*/ headers(client, filename); /*发送*/ cat(client, resource); } fclose(resource); } /**********************************************************************/ /* This function starts the process of listening for web connections * on a specified port. If the port is 0, then dynamically allocate a * port and modify the original port variable to reflect the actual * port. * Parameters: pointer to variable containing the port to connect on * Returns: the socket */ /**********************************************************************/ int startup(u_short *port) { int httpd = 0; int on = 1; struct sockaddr_in name; httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die(&quot;socket&quot;); memset(&amp;name, 0, sizeof(name)); name.sin_family = AF_INET; name.sin_port = htons(*port); name.sin_addr.s_addr = htonl(INADDR_ANY); if ((setsockopt(httpd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on))) &lt; 0) { error_die(&quot;setsockopt failed&quot;); } if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0) error_die(&quot;bind&quot;); if (*port == 0) /* if dynamically allocating a port */ { socklen_t namelen = sizeof(name); if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1) error_die(&quot;getsockname&quot;); *port = ntohs(name.sin_port); } if (listen(httpd, 5) &lt; 0) error_die(&quot;listen&quot;); return(httpd); } /**********************************************************************/ /* Inform the client that the requested web method has not been * implemented. * Parameter: the client socket */ /**********************************************************************/ void unimplemented(int client) { char buf[1024]; sprintf(buf, &quot;HTTP/1.0 501 Method Not Implemented\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;Content-Type: text/html\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/TITLE&gt;&lt;/HEAD&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\\r\\n&quot;); send(client, buf, strlen(buf), 0); sprintf(buf, &quot;&lt;/BODY&gt;&lt;/HTML&gt;\\r\\n&quot;); send(client, buf, strlen(buf), 0); } /**********************************************************************/ int main(void) { int server_sock = -1; u_short port = 4000; int client_sock = -1; struct sockaddr_in client_name; socklen_t client_name_len = sizeof(client_name); pthread_t newthread; server_sock = startup(&amp;port); printf(&quot;httpd running on port %d\\n&quot;, port); while (1) { /*阻塞等待Client接入*/ client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len); if (client_sock == -1) error_die(&quot;accept&quot;); /* accept_request(&amp;client_sock); */ /*Client接入后创建一个新线程处理该Client发来的Http请求，利用多线程实现同时多个Client的Http请求*/ if (pthread_create(&amp;newthread , NULL, (void *)accept_request, (void *)(intptr_t)client_sock) != 0) perror(&quot;pthread_create&quot;); } close(server_sock); return(0); }","categories":[],"tags":[{"name":"服务器_Tinyhttpd","slug":"服务器-Tinyhttpd","permalink":"http://avalonlz.github.io/tags/服务器-Tinyhttpd/"}]},{"title":"TCP_Assistant","slug":"TCP-Assistant","date":"2017-05-04T15:11:14.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/05/04/TCP-Assistant/","link":"","permalink":"http://avalonlz.github.io/2017/05/04/TCP-Assistant/","excerpt":"用QT写的TCP_Assistant，一开始架构挺清晰的，但感觉写着写着好像写乱了T T（设计文档还是要做的…）","text":"用QT写的TCP_Assistant，一开始架构挺清晰的，但感觉写着写着好像写乱了T T（设计文档还是要做的…） 项目地址：https://github.com/avalonLZ/Qt_TCPAssistant","categories":[],"tags":[{"name":"应用软件_Qt","slug":"应用软件-Qt","permalink":"http://avalonlz.github.io/tags/应用软件-Qt/"}]},{"title":"排序算法","slug":"SortCaculate","date":"2017-04-06T09:28:46.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/04/06/SortCaculate/","link":"","permalink":"http://avalonlz.github.io/2017/04/06/SortCaculate/","excerpt":"常见的排序算法练习","text":"常见的排序算法练习 冒泡排序：从小到大：取数据A[0]将其与其后面的数据A[1]、A[2]、A[3]…等数据比较，遇到比A[0]更小的数就交换数值，再继续用A[0]和后面的数据比较，这样下来A[0]一定是这组数中最小的了。之后再取A[1]、A[2]、A[3]…等数据比较，和A[0]一样，A[1]最后成为剩下数据中最小的那一个…如此往复，直到排序结束。 Code:template&lt;typename T, unsigned char SIZE&gt; void Data&lt;T, SIZE&gt;::bubble_smalltobig() { cout &lt;&lt; &quot;**********************Bubble:small to big*******************************&quot; &lt;&lt; endl; unsigned char i, j; /*遇到小的马上交换，交换后，用小的继续和下面的数比较，边比较（轮询）边换位*/ for(i = 0; i &lt; SIZE; i++) { for(j = i + 1; j &lt; SIZE; j++) { if(data[i] &gt; data[j]) { /*i、j互换也可以实现交换*/ data[j] ^= data[i]; data[i] = data[j] ^ data[i]; data[j] ^= data[i]; } } } for(i = 0; i &lt; SIZE; i++) { cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;; } if(i == SIZE) { cout &lt;&lt; endl; } } 选择排序：从大到小：取数据A[0]，记录其下角标‘0’，并将其与后面的数据A[1]、A[2]、A[3]…等数据进行比较，遇到比A[0]更小的数则将A[0]的下角标记录并替换掉，继续用新的A[新下角标值]和后面的A[5]、A[6]、A[7]等数据比较，有更小的数则同样记录并替换，最后得到一个最小数据对应的下角标，如果这个下角标和‘0’不同，则进行交换，至此A[0]中将是这组数据中最小的一个。接着对A[1]也进行新一轮的判别，记录下角标‘1’…..如此循环往复，直到排序完成。 Code:template&lt;typename T, unsigned char SIZE&gt; void Data&lt;T, SIZE&gt;::select_bigtosmall() { cout &lt;&lt; &quot;****************************Select:big to small**********************************&quot; &lt;&lt; endl; unsigned char i,j; unsigned char note = 0;//记录最大数的下角标 /*先轮询一边，记录最大的数的下角标，之后在换位*/ for(i = 0; i &lt; SIZE ; i++) { note = i; for(j = i + 1; j &lt; SIZE; j++) { if(data[note] &lt; data[j]) note = j; } if(note != i) { data[i] ^= data[note]; data[note] = data[i] ^ data[note]; data[i] ^= data[note]; } } for(i = 0; i &lt; SIZE; i++) { cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;; } if(i == SIZE) { cout &lt;&lt; endl; } } 插入排序：从大到小：数据A：45 35 84 1 36首先假设45是已经排好序的，则取35，和A[0]比较，比45小则不动作，此时45和35也已经可以看做是一个从大到小的小的排序序列了45 35 84 1 36然后再取84先和A[0]比较，发现84比A[0]大，则进行移位排序，排序后序列为84 45 35 1 36再取1和A[0]比较，比84小，不触发排序，和A[1]比较，同样也不触发排序，和A[2]比较，依然没有触发排序，所以1原地不动84 45 35 1 36再取36，和A[0]比较，比84小，不触发排序，和A[1]比，还是小，不触发排序，和A[2]比，比35大，触发排序移位，注意此时已经没有必要再和35后面的数比较了，因为35已经是之后的一段数中最大的了，所以要用break,最后84 45 36 35 1至此完成排序 Code:template&lt;typename T, unsigned char SIZE&gt; void Data&lt;T, SIZE&gt;::insert_bigtosmall() { cout &lt;&lt; &quot;*************************Insert:big to small*************************&quot; &lt;&lt; endl; int i,j,k = 0; T temp; /*取一个数去和可能插入的左方的数比较，如果该数大于左方的被比较数则移位，因为保证了之前就是大到小排列，所以排完一次就break*/ for(i = 1; i &lt; SIZE; i++) { temp = data[i]; for(j = 0; j &lt; i ; j++) { if(data[i] &gt; data[j]) { for(k = i - 1; k &gt;= j; k--) { data[k+1] = data[k]; } data[j] = temp; break; } } } for(i = 0; i &lt; SIZE; i++) { cout &lt;&lt; data[i] &lt;&lt; &quot; &quot;; } if(i == SIZE) { cout &lt;&lt; endl; } } 快速排序：1、定中轴（一般取第一个数）2、从后往前：找出后面更小的数放前面（第一个数处），同时前面的下角标自加3、从前往后：找出前面更大的数放后面（最后一个数处），同时后面下角标自减4、递归调用：利用中轴，分别进行前后两边的排序，递归结束条件 high&lt;=low Code:unsigned char quick(int *a, unsigned char low, unsigned char high) { int temp = 0; temp = a[low]; while(low &lt; high) { /*从后面开始找出小的放前面*/ while(low &lt; high &amp;&amp; a[high] &gt;= temp) { high--; } if(low &lt; high) { a[low] = a[high]; low++; } /*从前面开始找出大的放后面*/ while(low &lt; high &amp;&amp; a[low] &lt; temp) { low++; } if(low &lt; high) { a[high] = a[low]; high--; } a[low] = temp; } return low; } void quicksort(int a[], unsigned char low, unsigned char high) { unsigned char temp = 0; if(low &lt; high) { temp = quick(a, low, high);//先分两半 quicksort(a, temp+1, high);//对后半部分排序 quicksort(a, low, temp-1);//对前半部分排序 } }","categories":[],"tags":[{"name":"算法_Sort","slug":"算法-Sort","permalink":"http://avalonlz.github.io/tags/算法-Sort/"}]},{"title":"Linux网络编程之UDP广播、组播与简单Socket","slug":"Linux_UDP&Socket","date":"2017-03-27T14:54:05.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/03/27/Linux_UDP&Socket/","link":"","permalink":"http://avalonlz.github.io/2017/03/27/Linux_UDP&Socket/","excerpt":"本篇文章主要介绍下UDP广播、组播以及简单Socket的实现（顺带在说下CGI）","text":"本篇文章主要介绍下UDP广播、组播以及简单Socket的实现（顺带在说下CGI） UDP广播和UDP组播（组播可实现跨网段通讯）UDP广播只能在同一网段（严格意义上的网段）内进行广播，不可跨网段广播，而UDP组播可以实现跨网段广播，组播地址只能作为目的地址（组播地址也就是组播组），另外组播也被称为多播组播架构：点对点两台主机，或者多台主机连接配置了支持组播的路由器（路由一般默认关闭组播功能）。这些主机IP地址都可不在同一网段 IGMP协议：IGMP是IP组播的基础，在IP协议出现以后为了加入对组播的支持，IGMP产生了。IGMP所做的时间上就是告诉路由，在这个路由所在的子网内有人对发送到某一个组播组（组播IP）的数据感兴趣，这样当这个组播组的数据到达后，路由就不会抛弃它，而是把它转送给所有感兴趣的客户。假如不同子网内的A和B要进行组播通讯，那么位于AB直接的所有路由器必须都支持IGMP协议，否则AB之间不能进行通讯 组播的原理：组播首先有一个用户申请一个组播组，这个组播组被维护在路由中，其他用户申请加入，这样当一个用户向组内发送消息时，路由器将消息转发给组内的所有成员。如果申请加入的组不在本级路由中，且路由和交换机允许组播协议通过，路由则将申请加入的操作箱上级路由提交。广域网通讯要经过多级路由器和交换机，几乎所有的网络设备都默认阻止组播协议通过（只允许本网段内的广播，不向上级提交），这使得广域网组播实现有一定局限 UDP组播基本步骤：1、建立socket2、socket和端口绑定（最初的Receive方需要bind 0.0.0.0端口）3、加入一个组播组4、通过sendto/recvfrom进行数据收发5、关闭socket所有终端必须都要加入相同的主播地址 Python组播实现：Terminal_One: #-*- coding:utf-8 -*- import time import struct from socket import * SENDERIP = &apos;192.168.8.11&apos; # 本地ip SENDERPORT = 1501 # 本地接口 MYPORT = 1234 # 发送数据到该端口 MYGROUP = &apos;225.0.0.77&apos; # 组播组 MYTTL = 255 # 发送数据的TTL def sender(): s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP) s.bind((SENDERIP, SENDERPORT)) # Set Time-to-live (optional) ttl_bin = struct.pack(&apos;@i&apos;, MYTTL) s.setsockopt(IPPROTO_IP, IP_MULTICAST_TTL, ttl_bin) status = s.setsockopt(IPPROTO_IP, IP_ADD_MEMBERSHIP, inet_aton(MYGROUP) + inet_aton(SENDERIP)) # 加入到组播组 i = 0 while True: data = &apos;cisco&apos; s.sendto(data + &apos;\\0&apos;, (MYGROUP, MYPORT)) i = i + 1 print &quot;%d send data ok !&quot; % i time.sleep(10) if __name__ == &quot;__main__&quot;: sender() Terminal_Two: # -*- coding:utf-8 -*- import time import socket SENDERIP = &apos;169.254.51.246&apos; MYPORT = 1234 #监听组播组端口 MYGROUP = &apos;225.0.0.77&apos; def receiver(): # create a UDP socket sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) # allow multiple sockets to use the same PORT number sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Bind to the port that we know will receive multicast data #bind一般用于服务器绑定、监听本地IP和端口，只可以可以绑定本机所具有的IP和端口 #但在组播中bind应该设置为监听组播IP和其端口，但bind无法设置为绑定、监听非本机的IP（保留IP也不可以被设置为监听对象） #所以在组播中必须bind所有ip，和对应组播的端口号 sock.bind((&apos;0.0.0.0&apos;, MYPORT))#留空也可以 # tell the kernel that we are a multicast socket # sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 255) # Tell the kernel that we want to add ourselves to a multicast group # The address for the multicast group is the third param #加入组播组 status = sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(MYGROUP) + socket.inet_aton(SENDERIP)); sock.setblocking(0) # ts = time.time() while 1: try: data, addr = sock.recvfrom(1024) except socket.error, e: pass else: print &quot;Receive data!&quot; print &quot;TIME:&quot;, time.time() print &quot;FROM: &quot;, addr print &quot;DATA: &quot;, data if __name__ == &quot;__main__&quot;: receiver() CGI程序：CGI程序一般指运行于HTTP服务器上的后台交互程序Web后台架构可分为：1、服务端（HTTP协议解析）2、中间件（WSGI才有）3、应用端（CGI/WSGI程序）一个HTTP请求到达一台服务器的80端口后，需要有一个程序来响应该请求。所谓HTTP Response，其实只是运行一个程序，它的输入是HTTP Request Header,它的返回是HTTP Response。HTTP Request Header传递方式就分为CGI、WSGI以及其他各种GI的区别如果是CGI，通常来说是一个Web Server（例如Apache、Nginx）接收到请求后，将请求中的HTTP Request Header按照一定规则设置成环境变量，然后启动一个程序，将stdout的输出（其中HTTP Response Header）封装成HTTP Response返回给客户的例如：Django跑在uWSGI、unicorn之类的容器里，那么程序是一个常驻进程，Web Server和Python进程用WSGI协议传递HTTP Request Header信息，然后返回给用户。如果是Django的dev server,它使用Python自带的wsgiref模块实现了一个简单的HTTP Server响应HTTP请求。从以上可以知道服务端Server对利用Apache等软件对HTTP协议解析后还会将其解析的信息加入另一协议中，此协议根据服务器的后台逻辑框架而定（Django用WSGI协议），利用此进行服务端HTTP请求和后台逻辑框架的交互 SocketSocket是应用层与TCP/IP协议族通信的中间软件抽象层。注意，UDP则不具备这一软件抽象层Socket在网络通信中所处的位置： Socket网络编程常用结构体（struct sockaddr, struct in_addr, struct sockaddr_in）定义: struct sockaddr { unsigned short sa_family;//协议族(定义使用哪种底层网络协议),AF_INET(TCP/IPv4),AF_INET6(TCP/IPv6),AF_LOCAL或AF_UNIX(本地通信，用于本地进程间的socket通讯) char sa_data[14];//14字节的协议地址 } //str 2 in_addr变量赋值需使用inet_addr函数:in_addr addr = inet_addr(&quot;192.168.0.2&quot;); //in_addr变量 2 str需使用inet_ntoa函数:char *str = inet_ntoa(addr); typedef struct in_addr { union{ struct{unsigned char s_b1, s_b2, s_b3, s_b4;}S_un_b; struct{unsigned short s_w1, s_w2;}S_un_w; unsigned long S_addr; }S_un; }IN_ADDR; struct sockaddr_in { short int sin_family;//协议族，在网络编程中一般就是用AF_INET unsigned short int sin_port;//存放端口号(需转为大端模式再存放) struct in_addr sin_addr;//存储IP地址 unsigned char sin_zero[8];//留空字节，保证sockaddr和sockaddr_in可以相互转换 } Socket网络通讯编程流程：Server端：1、创建套接字（Socket）2、将套接字绑定到一个本地地址和端口上（Bind）3、将套接字设置为监听模式，准备接收客户端请求（Listen）4、等待客户端请求到来，当请求到来后接受连接请求，返回一个新的对应于此次连接请求的套接字（accept）5、用返回的套接字和客户端进行通信（Send/Recv）6、返回，等待新请求7、关闭套接字一个简单的Server端Socket实现(C语言): /************************************************************************* &gt; File Name: simplesocket.c &gt; Author:lizhong &gt; Mail: &gt; Created Time: Thu 09 Mar 2017 11:02:12 PM PST ************************************************************************/ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;errno.h&gt;//路径:/usr/include/ #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;netinet/in.h&gt; #define DPORT 33333 #define SIZE 1000 int Select(int confd) { fd_set fd; struct timeval time; int ts = 0; time.tv_sec = 0;//0秒 time.tv_usec = 500;//500毫秒 FD_ZERO(&amp;fd); FD_SET(confd, &amp;fd); /*最后一个time参数设置为空意味着阻塞，直到有收到东西*/ ts = select(confd + 1, &amp;fd, NULL, NULL, NULL); printf(&quot;Select Return:%d\\n&quot;, ts); if(ts) return 1; else return 0; } int main() { int sfd,confd; struct sockaddr_in serveradd; char *rebuff; char *sebuff;//= &quot;I received the message!&quot;; int relen = 0,j = 0,k = 0, sel = 0; /*初始化Socket,返回socket的文件描述符*/ sfd = socket(AF_INET, SOCK_STREAM, 0); if( sfd == -1 ) { printf(&quot;Created Socket Error:%s\\n&quot;, strerror(errno)); exit(0); } /*配置本服务器地址参数*/ memset(&amp;serveradd, 0, sizeof(struct sockaddr_in)); serveradd.sin_family = AF_INET; /*系统自动获取本机IP*/ serveradd.sin_addr.s_addr = htonl(INADDR_ANY); /*设置监听端口为DPORT*/ serveradd.sin_port = htons(DPORT); /*Socket和端口绑定*/ j = bind(sfd, (struct sockaddr*)&amp;serveradd, sizeof(struct sockaddr_in)); if(j == -1) { printf(&quot;Bind Error :%s\\n&quot;, strerror(errno)); exit(0); } j = 0; /*开启监听客户端请求，（开闸）*/ j = listen(sfd, 10); if(j == -1) { printf(&quot;Listen Error:%s\\n&quot;, strerror(errno)); exit(0); } j= 0; printf(&quot;***********************Wait Request**********************\\n&quot;); /*接受客户端连接,此条语句有阻塞效果*/ confd = accept(sfd, (struct sockaddr*)NULL, NULL); if(confd == -1) { printf(&quot;Accept Error:%s\\n&quot;, strerror(errno)); /*出错则结束*/ return 0; } while(1) { /*接收客户端传来的数据*/ rebuff = malloc(SIZE); memset(rebuff, 0, SIZE); /*注意传入confd，而不是sfd。阻塞，直到有收到东西,收到东西之后用recv函数接收下数据*/ /*将select函数放到recv函数后将一直返回0，因为recv后缓冲区没有数据了*/ sel = Select(confd); /*flags设置为0值则是阻塞的(默认阻塞)，并且接受完一次数据后接收缓冲区的数据会被清除*/ /*因为先前socket设置了socket stream(使用面向连接的TCP协议)所以没有数据被丢失,具体表现为：*/ /*SIZE过小会触发多次接收,每次relen的值最大为SIZE*/ relen = recv(confd, rebuff, SIZE, 0); if(relen != -1 || relen != 0) { /*可以接收数据，但是数据长度却为0说明客户端断开了TCP连接*/ if(sel == 1 &amp;&amp; relen == 0) { printf(&quot;Socket is close!\\n&quot;); free(rebuff); break; } else { printf(&quot;Receive Data is :\\n********%d:%s****relen:%d********\\n&quot;, ++k, rebuff, relen); sebuff = malloc(strlen(&quot;I received the message:&quot;) + relen); strcpy(sebuff, &quot;I received the message:&quot;);//&apos;\\0&apos;也会被copy(MSDN上有说明) strcat(sebuff, rebuff); send(confd, sebuff, strlen(sebuff), 0); free(rebuff); free(sebuff); } } else { printf(&quot;Receive Error is :%s\\n&quot;, strerror(errno)); free(rebuff); break; } } return 0; } Client端：1、创建套接字（Socket）2、向服务端发出连接请求（Connect）3、和服务端进行通信（Send/Recv）4、关闭套接字Client与Server流程图： Socket编程中的一些坑：","categories":[],"tags":[{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"}]},{"title":"俄罗斯方块","slug":"Tetris","date":"2017-03-26T06:46:15.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/03/26/Tetris/","link":"","permalink":"http://avalonlz.github.io/2017/03/26/Tetris/","excerpt":"复习C++，写了个俄罗斯方块。参考了网上某些大神写的俄罗斯方块","text":"复习C++，写了个俄罗斯方块。参考了网上某些大神写的俄罗斯方块自己写的如下图：源代码请见：https://github.com/avalonLZ/CPP_Tetris","categories":[],"tags":[{"name":"游戏编程","slug":"游戏编程","permalink":"http://avalonlz.github.io/tags/游戏编程/"}]},{"title":"飞思卡尔与PID","slug":"Freescale_PID","date":"2017-02-19T14:00:14.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/02/19/Freescale_PID/","link":"","permalink":"http://avalonlz.github.io/2017/02/19/Freescale_PID/","excerpt":"回忆大学时光，最感慨的还是两年飞卡（两次都是玩直立车）。现在想来更应该抽一年时间去接触ACM，打好自己的算法、数据结构和STL基础。唉，只能说是Too Young， Too Simple。选择比努力重要太多。","text":"回忆大学时光，最感慨的还是两年飞卡（两次都是玩直立车）。现在想来更应该抽一年时间去接触ACM，打好自己的算法、数据结构和STL基础。唉，只能说是Too Young， Too Simple。选择比努力重要太多。 第九届摄像头组程序：https://github.com/avalonLZ/C_Freescale9 第十届光电组程序：https://github.com/avalonLZ/C_Freescale10 第十届的代码主要是自己和队友写的，当时时序控制其实很头疼，但是又没人指点，最后也只能硬着头皮上（现在想来应该上RTOS的，已保证采集和控制任务的优先级）。这一次，使我明白了软件架构、设计思想的重要性，也让我在今后的软件设计上,注意这方面知识的学习 直立PD控制 速度PI控制 转向PD控制","categories":[],"tags":[{"name":"飞思卡尔","slug":"飞思卡尔","permalink":"http://avalonlz.github.io/tags/飞思卡尔/"}]},{"title":"B/S模式家庭监控系统","slug":"Flask-HomeMonitorSystem","date":"2017-02-08T11:40:03.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/02/08/Flask-HomeMonitorSystem/","link":"","permalink":"http://avalonlz.github.io/2017/02/08/Flask-HomeMonitorSystem/","excerpt":"本科毕业设计，当时利用Raspberry Pi做的家庭监控系统，其中用了Python中的Flask框架。当时只是想把底层到Web的一条技术栈打通，就做了这么个东东，写个简单的小教程吧","text":"本科毕业设计，当时利用Raspberry Pi做的家庭监控系统，其中用了Python中的Flask框架。当时只是想把底层到Web的一条技术栈打通，就做了这么个东东，写个简单的小教程吧 项目地址：https://github.com/avalonLZ/Flash_HomeMonitorSys 实物图： 登录界面及控制界面： 硬件开发环境：Raspberry Pi + usb免驱摄像头 + usb免驱无线网卡（Pi 3中集成了无线网卡） + 两个LED灯 + DHT11温湿度传感器 + ULN2003步进电机驱动板 + 一个步进电机 + USB-TTL串口调试工具（非必须） 软件开发环境：Debain系统 + motion开源库 + fswebcam抓图软件 + Flask框架 硬件连接示意图按照以上硬件连接示意图将硬件设备接入树莓派，接下来就可以进行软件开发平台的搭建工作。 软件开发平台的搭建1、首先是Debain系统的安装：Raspberry Pi的Bootloader首先访问的是GPU内的Flash区域，Raspberry Pi出厂时将挂载TF卡的程序烧写进GPU的Flash中，所以想要让Raspberry Pi运行Debian Linux操作系统就需先将Debian烧写入TF卡中。此处建议使用Class10 TF卡，因为Class10相对读写速度较快，有利于程序在Raspberry Pi上的运行。本次开发使用Win32diskimager对从Raspberry Pi官网下在的Debian系统进行TF卡烧写，本设计使用的是内核版本为4.1.13的Debian系统。烧写完成后将TF卡插入Raspberry Pi底部的MicroSD卡槽，启动Raspberry Pi。 2、利用USB-TTL串口调试工具进行开发（可以用SSH通讯代替，第三版的树莓串口和蓝牙的固件有冲突，所以不可用串口调试工具）USB-TTL CH340串口调试工具和树莓连接图：在开发计算机上下载Putty软件。将CH340模块插入电脑USB口，安装驱动程序。打开Putty软件，在Connection type选项中选择Serial（串口模式），在Serial line文本框中修改COM口，修改为设备管理器中所显示COM口。在Speed文本框中输入通讯波特率115200。点击Putty右下角的Open开始通讯并将Raspberry Pi上电。等待树莓启动后，在Raspberrypi login：的光标后输入默认用户名pi并回车输入密码raspberry。之后便成功登入了系统。 3、WiFi模块的配置接下来配置Raspberry Pi的WiFi模块。将WiFi模块插入USB口，在CLI界面输入命令：lsusb，出现所有采用USB协议通讯的设备。找到RTL8188CUS 802.11n WLAN Adapter设备，说明此时WiFi模块已被正确识别。接下来输入sudo iwlist wlan0 scan命令，将会列出附近所有WiFi信号的详细信息。在各个信号的SSID中找到家庭网络所命名的SSID，本次开发使用SSID为lz1。在确定可以检测到家庭网络后输入wpa_passphrase lz1(SSID用户名) 581218147（密码）并回车。出现下回显信息： network={ ssid=&quot;lz1&quot; #psk=&quot;581218147&quot; psk=4690a5c5b75c028fc5e3ba2eed03c0b93a06121b27bda85ff510a308e03ce5ea } 将此段信息复制并保存到/etc/wpa_supplicant/wpa_supplicant.conf文件内即在CLI界面输入sudo nano /etc/wpa_supplicant/wpa_supplicant.conf命令。保存退出后再输入sudo nano /etc/network/interfaces命令，进入interfaces文件内进行WiFi配置。在文件内用“#”注释其他配置信息并输入以下配置命令：auto loiface lo inet loopbackiface eth0 inet dhcpauto wlan0allow-hotplug wlan0iface wlan0 inet staticwpa-ssid “lz1”wpa-psk “581218147”address 192.168.191.2保存退出后，在CLI界面先后分别输入sudo ifdown wlan0和sudo ifup wlan0命令重启wlan0，之后在输入ifconfig命令，出现wlan0 WiFi连接的详细信息： wlan0 Link encap:Ethernet HWaddr e8:4e:06:26:e2:15 inet addr:192.168.191.2 Bcast:192.168.191.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:25 errors:0 dropped:11 overruns:0 frame:0 TX packets:8 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:3883 (3.7 KiB) TX bytes:872 (872.0 B) 可以看到此时设备已经正确获取了设置IP，至此WiFi模块配置完成。 4、Flask框架的安装WiFi配置完成便可以访问到互联网。可以开始Flask平台的搭建，首先需要安装Python2.7版本，因为此Raspberry Pi下的Debian Linux操作系统自带了Python2.7版本，所以直接进行pip命令的安装。使用sudo apt-get install python-pip命令直接下载安装pip即可。安装完成后可以使用pip –help命令查看是否成功安装，若成功安装便会在窗口显示“Usage: pip COMMAND [OPTIONS]”等说明帮助。之后使用pip对flask进行安装。执行sudo pip install flask命令。窗口出现“Successfully installed flask Werkzeug Jinja2 itsdangerous MarkupSafe”字样说明已经成功安装Flask，可以写一个.py文件进行简单测试。执行cd /home/pi/Desktop命令进入桌面，使用mkdir test命令新建一个test文件夹并进入。使用sudo nano test.py命令并在其中输入以下代码： from flask import Flask app = Flask(__name__) @app.route(&apos;/&apos;) def hello_world(): return &apos;Hello World!&apos; if __name__ == &apos;__main__&apos;: app.run(&quot;192.168.191.2&quot;) 如此创建一个简单的Flask工程，测试Flask环境是否已经搭建完成。在同一网段终端设备的浏览器地址栏输入http://192.168.191.2:5000/并回车，出现下图所示画面则说明Flask应用框架开发平台搭建完成。接下来开始使用摄像头部分的环境搭建。首先将USB摄像头接入Raspberry Pi的USB口，输入lsusb命令，回显出现Z-Star Microelectronics Corp. Venus USB2.0 Camera字样，则说明系统可以识别出该USB摄像头。再输入ls /dev/vid*查看是否有对应驱动程序，当回显/dev/video0时说明Linux已经有了USB摄像头的驱动程序。接下来便可以开始开源软件Motion的安装以及配置工作。 5、Motion的安装及其配置在CLI中输入sudo apt-get install motion安装Motion，安装完成后输入sudo nano /etc/default/motion在该文件内，将start_motion_daemon=no，改为start_motion_daemon=yes表示允许后台运行，保存并退出。之后进入sudo nano /etc/motion/motion.conf 进行Motion的详细配置。在此次开发中配置如下： daemon off #关闭Motion的守护进程（后台运行）功能。 videodevice /dev/video0 #使用video0库驱动摄像头。 # Values : # V4L2_PIX_FMT_SN9C10X : 0 &apos;S910&apos; # V4L2_PIX_FMT_SBGGR8 : 1 &apos;BA81&apos; # V4L2_PIX_FMT_MJPEG : 2 &apos;MJPEG&apos; # V4L2_PIX_FMT_JPEG : 3 &apos;JPEG&apos; # V4L2_PIX_FMT_RGB24 : 4 &apos;RGB3&apos; # V4L2_PIX_FMT_UYVY : 5 &apos;UYVY&apos; # V4L2_PIX_FMT_YUYV : 6 &apos;YUYV&apos; # V4L2_PIX_FMT_YUV422P : 7 &apos;422P&apos; # V4L2_PIX_FMT_YUV420 : 8 &apos;YU12&apos; v4l2_palette 5 #选择摄像头的采样模式，这个选项是根据摄像头自身所支持的采样模式来选择的，此次开发使用的USB摄像头支持UYVY模式所以选择5。 width 176 #图像宽度，受带宽影响为了图像传输顺畅暂时设置为176。 height 144 #图像高度，受带宽影响为了图像传输顺畅暂时设置为144。 framerate 10 # framerate为1秒帧率默认为2，最高100也就是一秒拍摄传输2张图像，经过比较测试发现此参数设置为10可以基本符合要求。 output_all off #不保存拍摄到的图像。 output_normal on #保存检测到运动物体时的图像。 ffmpeg_cap_new off #检测到运动物体时不进行摄像。 locate off #关闭本地查看功能。 target_dir /home/lz/motion-images #设置照片存放路径，需要将此路径设置成最低权限。 ; thread /usr/local/etc/thread1.conf #; thread /usr/local/etc/thread2.conf #; thread /usr/local/etc/thread3.conf #; thread /usr/local/etc/thread4.conf #以上四条设置是否开启多个摄像头采集画面，由于本次设计只采用一个摄像头，所以只启用了一条配置线程。其他的配置选项都可以按Motion的默认参数来配置。最后保存并退出配置文件，执行update-rc.d -f motion remove命令删除Motion开启启动项。 以上所配置的只是Motion众多配置中的冰山一角，Motion还支持很多强大的功能，如有需要还可以随时进行更改。至此，完成了Motion的配置，下面进行简单测试。退出配置文件后在终端窗口中输入sudo service motion start命令启动Motion，之后通过同一网段终端浏览器访问Raspberry Pi的8081端口，出现下图所示画面则说明配置成功，可以进行下一步开发。 6、外围模块设计-DHT11根据DHT11的DataSheet编写相应的Python程序对模块进行驱动，具体实现函数见：https://github.com/avalonLZ/Project/tree/master/Python/Python_Flask/Flask_HomeMonitorSystem-master/dht11.py 7、外围模块设计-驱动步进电机在步进电机的驱动方面，是采用UNL2003高耐压、大电流复合晶体管阵列对28BYJ-48五线四相步进电机进行驱动。06号GPIO口作为INT1口的输入，13号GPIO口作为INT2的输入，19号GPIO口作为INT3的输入26号GPIO口作为INT4的输入。暂时使用了单四拍设计。具体实现函数见：https://github.com/avalonLZ/Project/tree/master/Python/Python_Flask/Flask_HomeMonitorSystem-master/motor.py 8、Web前端设计Web界面当时做的比较随意，并没有花很多时间去深入学习各种前端技术，简单的做了几个界面，Html及CSS见：https://github.com/avalonLZ/Project/tree/master/Python/Python_Flask/Flask_HomeMonitorSystem-master/templates 9、用Flask框架实现后台逻辑后台逻辑主要使用了Flask框架来实现，在HTTP协议中浏览器请求主要分为GET和POST请求两种类型。简单来说GET方式是从服务器中获取数据，而POST方式则是提交数据到服务器。本次后台设计也就主要以这两种请求方式分别设计实现函数。具体Python代码见：https://github.com/avalonLZ/Project/tree/master/Python/Python_Flask/Flask_HomeMonitorSystem-master/app.py 至此整个家庭监控系统就搭建完成了，在Flask项目所在文件夹下使用sudo python app.py命令即可运行查看效果了，最后还可以将这个命令添加到Linux下的自启动脚本中，这样每当树莓派启动就会启动这个监控系统，同一网段的终端就可以通过浏览器对设备所处环境进行视频监控了（不过这视频流走的是MJPEG格式，如果是WiFi建立的局域网还是会存在1-2秒的延迟）。","categories":[],"tags":[{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"http://avalonlz.github.io/tags/Raspberry-Pi/"}]},{"title":"微信自动回复小插件","slug":"Wechat-Autoreply","date":"2017-02-07T00:50:50.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/02/07/Wechat-Autoreply/","link":"","permalink":"http://avalonlz.github.io/2017/02/07/Wechat-Autoreply/","excerpt":"无意间发现python有个微信库啊，刚好微信没有QQ一样的不同状态下自动回复功能，所以就做了这么个小插件","text":"无意间发现python有个微信库啊，刚好微信没有QQ一样的不同状态下自动回复功能，所以就做了这么个小插件 开发环境：win7_64 + python2.7.9_64 + PyQt4_641.将python2.7加入系统环境变量中2.用cmd进入python2.7所在的安装文件夹，进入Script文件夹，运行easy_install.exe pip(pip安装完成)3.用cmd进入python中，运行pip install itchat（安装itchat库）4.安装pyqt4 接下来就可以编写PyQt程序了： #coding: UTF-8 import sys import itchat from itchat.content import * from PyQt4 import QtGui, QtCore ###################################回复内容####################################### @itchat.msg_register(TEXT, isGroupChat = True)#group into this def text_reply(msg): print &apos;intoone&apos; if msg[&apos;isAt&apos;]: if busy: return &apos;Sorry,I\\&apos;m busy at the moment&apos; elif sleep: return &apos;Sorry,I\\&apos;m sleeping now&apos; elif leave:# return &apos;Sorry,I\\&apos;m not at home now&apos; @itchat.msg_register([TEXT, MAP, CARD, SHARING, PICTURE, RECORDING, ATTACHMENT, VIDEO])#single chat into this def text_reply(msg): print (&apos;leave = %d&apos;%leave) if busy: return &apos;Sorry,I\\&apos;m busy at the moment&apos; elif sleep: return &apos;Sorry,I\\&apos;m sleeping now&apos; elif leave:# return &apos;Sorry,I\\&apos;m not at home now&apos; ##################################回复API########################################## class Reply(QtCore.QThread): def __init__(self, parent=None): super(Reply, self).__init__(parent) def run(self): global busy global sleep global leave if self.busy == 1: busy = 1 sleep = 0 leave = 0 if self.sleep == 1: busy = 0 sleep = 1 leave = 0 if self.leave == 1: busy = 0 sleep = 0 leave = 1 itchat.run() def busy_status(self): self.busy = 1 self.sleep = 0 self.leave = 0 def sleep_status(self): self.busy = 0 self.sleep = 1 self.leave = 0 def leave_status(self): self.busy = 0 self.sleep = 0 self.leave = 1 print &apos;leave&apos; class Login(QtCore.QThread): def __init__(self, parent=None): super(Login, self).__init__(parent) def run(self): itchat.auto_login() ###################################new一个主窗口######################################### class Createwindow(QtGui.QWidget): def __init__(self): super(Createwindow, self).__init__() self.init() def init(self): ###################################按键######################################### bt_set = QtGui.QPushButton(&apos;设置&apos;.decode(&apos;utf8&apos;), self) bt_set.resize(bt_set.sizeHint()) bt_set.move(5, 120) #需要建立新线程 self.connect(bt_set, QtCore.SIGNAL(&quot;clicked()&quot;), self.bt_setfunction) bt_login = QtGui.QPushButton(&apos;登录&apos;.decode(&apos;utf8&apos;), self) bt_login.resize(bt_login.sizeHint()) bt_login.move(89, 120) self.loginthread = Login() self.connect(bt_login, QtCore.SIGNAL(&quot;clicked()&quot;), self.loginthread.start) bt_exit = QtGui.QPushButton(&apos;退出&apos;.decode(&apos;utf8&apos;), self) bt_exit.resize(bt_exit.sizeHint()) bt_exit.move(171, 120) #退出 bt_exit.clicked.connect(QtCore.QCoreApplication.instance().quit) ##################################单选框########################################## self.ck_leave = QtGui.QRadioButton(&apos;离开&apos;.decode(&apos;utf8&apos;), self)#将‘忙碌’解码为utf8 self.ck_leave.resize(self.ck_leave.sizeHint()) self.ck_leave.move(5, 10) self.ck_busy = QtGui.QRadioButton(&apos;忙碌&apos;.decode(&apos;utf8&apos;), self) self.ck_busy.resize(self.ck_busy.sizeHint()) self.ck_busy.move(5, 50) self.ck_sleep = QtGui.QRadioButton(&apos;睡觉&apos;.decode(&apos;utf8&apos;),self) self.ck_sleep.resize(self.ck_sleep.sizeHint()) self.ck_sleep.move(5,90) ##################################主窗口显示########################################## self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&apos;WeChat AutoReply&apos;) self.show() def bt_setfunction(self): self.replythread = Reply() if(self.ck_leave.isChecked()): self.replythread.leave_status() if(self.ck_busy.isChecked()): self.replythread.busy_status() if(self.ck_sleep.isChecked()): self.replythread.sleep_status() self.replythread.start() def appstart(): app = QtGui.QApplication(sys.argv) win = Createwindow() sys.exit(app.exec_()) if __name__==&apos;__main__&apos;: appstart() 程序运行效果如下图： 源码下载地址：https://github.com/avalonLZ/PyQt_AutoWeChat 注意，若SSL报错则需要回滚CA证书： pip uninstall -y certifi pip install certifi==2015.04.28 至此debug完成！接下来进入打包环节在这里我使用的打包工具是py2exe，在主py文件所在文件夹建立一个mysetup.py文件，文件内容如下： # -*- coding: utf-8 -*- from distutils.core import setup import py2exe import sys #this allows to run it with a simple double click. sys.argv.append(&apos;py2exe&apos;) py2exe_options = { &quot;includes&quot;: [&quot;sip&quot;], &quot;dll_excludes&quot;: [&quot;MSVCP90.dll&quot;,], &quot;compressed&quot;: 1, &quot;optimize&quot;: 2, &quot;ascii&quot;: 0, #&quot;bundle_files&quot;: 1, } setup( name = &apos;WeChat_AutoReply&apos;, version = &apos;1.0&apos;, #windows = [&apos;gis_serial.py&apos;,], zipfile = None, options = {&apos;py2exe&apos;: py2exe_options}, windows = [{&quot;script&quot;: &quot;wechatgui.py&quot;, &quot;icon_resources&quot;: [(1, u&quot;./img/image1.ico&quot;)] }] ) 注意，因为itchat用到了微信SSL认证，需要提供CA证书，但一般打包后并不会将证书进行打包。并且，DEFAULT_CA_BUNDLE_PATH = certs.where()所指定的CA证书地址是一个较深入的相对地址，这样会导致打包后始终无法找到CA证书。在这里我们可以按以下步骤解决该问题: 1、首先更改DEFAULT_CA_BUNDLE_PATH为项目所在地的根目录地址，修改Python27\\Lib\\site-packages\\requests目录下的utils.py文件 NETRC_FILES = (&apos;.netrc&apos;, &apos;_netrc&apos;) DEFAULT_CA_BUNDLE_PATH = certs.where() #加入以下两行，对DEFAULT_CA_BUNDLE_PATH进行更改 from os.path import join, abspath DEFAULT_CA_BUNDLE_PATH = join(abspath(&apos;.&apos;), &apos;cacert.pem&apos;) 2、打开python解释器运行 &gt;&gt;&gt; import certifi &gt;&gt;&gt; certifi.where() &apos;C:\\\\Python27\\\\lib\\\\site-packages\\\\certifi\\\\cacert.pem&apos; 可以看出我们需要的CA文件就在该目录下，进入该目录，复制cacert.pem到项目所在根目录（保证了在更改了utils.py后依然可以debug成功） 3、现在我们可以用cmd进入项目所在根目录执行python mysetup.py py2exe对项目进行打包 4、最后将cacert.pem再次拷贝到项目根目录下的dist文件夹中。至此，执行exe文件发现可以正常进行微信登录等操作 （在项目彻底结束后最好把utils.py改回来，以免以后每次使用CA都要拷贝cacert.pem到项目根目录）","categories":[],"tags":[{"name":"应用软件_PyQt","slug":"应用软件-PyQt","permalink":"http://avalonlz.github.io/tags/应用软件-PyQt/"}]},{"title":"Django","slug":"Django-Note","date":"2017-01-08T03:44:43.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/01/08/Django-Note/","link":"","permalink":"http://avalonlz.github.io/2017/01/08/Django-Note/","excerpt":"记录Django框架的学习","text":"记录Django框架的学习 Django框架结构图 安装Djangosudo apt-get install python-django -y Django的简单配置1.在根目录下创建一个项目：django-admin startproject django1 startproject创建的目录结构如下： django1/&#160; &#160; &#160; &#160;manage.py&#160; &#160; &#160; &#160;django1/&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;__init__.py&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;settings.py&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;urls.py&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;wsgi.py 外层django1目录只是项目的一个容器，对于Django来说该目录名并不重要，可以重命名该文件夹 manage.py：它是一个实用的命令行工具，使用它可以与该Django项目进行交互，可以在django-admin.py and manage.py中查看manage.py所有细节。 内层django1目录是项目中的实际Python包，该目录名就是Python包名，通过它可以导入里面的任何东西。（例如：import django1.settings） django1/__init__.py：一个空文件，告诉Python该目录是一个Python包 django1/setting.py :该Django项目的设置、配置。 django1/urls.py：该Django项目的URL声明，一份由Django驱动的网站“目录” django1/wsgi.py：一个WSGI兼容的Web服务器的入口，用于项目的运行 2.进入项目文件夹，创建一个应用：python manage.py startapp one3.在项目的settings.py文件中添加刚刚建立的应用（为了使用render函数渲染模板，）： INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;one&apos;, ) 模板的使用1.url配置（更改url.py文件）：在url.py的patterns中添加类似 url(r&apos;^one/&apos;,&apos;one.views.index&apos;) 的语句，引用界面在one文件夹下的views.py中的index视图函数2.编写views.py文件的index函数，实现加载html文件（第一种写法）： from django.shortcuts import render from django.http import HttpResponse from django.template import loader,Context def index(req): test_html = loader.get_template(&apos;test.html&apos;)#搜索app中templates文件夹下的test.html文件，并生成模板对象 text = Context({})#生成模板参数对象 return HttpResponse(test_html.render(text))#模板对象通过render方法加入模板参数用HttpResponse返回浏览器 加载html文件（第二种写法）： from django.shortcuts import render,render_to_response def index(req): return render_to_response(&apos;test.html&apos;,{})#第一个为模板文件，第二个为模板参数 3.views变量（后台变量传递到前端显示），修改views.py： class person(): def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def say(self): return self.name def index(req): user = {&apos;name&apos;:&apos;lizhong&apos;,&apos;age&apos;:&apos;22&apos;,&apos;sex&apos;:&apos;man&apos;} user2 = person(&apos;lz&apos;,&apos;23&apos;,&apos;man&apos;) user3 = [&apos;c&apos;,&apos;c++&apos;,&apos;python&apos;] direc = {&apos;title&apos;:&apos;test&apos;,&apos;hone&apos;:&apos;Test&apos;,&apos;li&apos;:user,&apos;zhong&apos;:user2,&apos;web&apos;:user3} return render_to_response(&apos;test.html&apos;,direc)#template and parameter Html文件中可以接收title这样的普通变量、字典、以及对象（函数返回值和属性）和列表，但最外层都需要被一个字典所包围，前后端通过该字典的key值做出匹配（优先级关系：变量&gt;字典&gt;对象属性&gt;对象方法&gt;列表），html代码如下： &lt;title&gt;{{title}}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h&gt;Hello World!!!&lt;/h&gt; &lt;h1&gt;{{hone}}&lt;/h1&gt; &lt;h2&gt;user:&lt;/h2&gt; &lt;li&gt;name:{{li.name}}&lt;/li&gt; &lt;li&gt;age:{{li.age}}&lt;/li&gt; &lt;li&gt;sex:{{li.sex}}&lt;/li&gt; &lt;h2&gt;user2:&lt;/h2&gt; &lt;li&gt;name:{{zhong.name}}&lt;/li&gt; &lt;li&gt;age:{{zhong.age}}&lt;/li&gt; &lt;li&gt;sex:{{zhong.sex}}&lt;/li&gt; &lt;li&gt;{{zhong.name}} say :I am {{zhong.say}}&lt;/li&gt; &lt;h2&gt;user3:&lt;/h2&gt; &lt;li&gt;lanuageone:{{web.0}}&lt;/li&gt; &lt;li&gt;lanuagetwo:{{web.1}}&lt;/li&gt; &lt;li&gt;lanuagethree:{{web.2}}&lt;/li&gt; &lt;/body&gt; 4.标签（if else endif ,for endfor）的使用,views.py文件： class person(): def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex self.value = 1 def say(self): return self.name def index(req): user = person(&apos;lizhong&apos;,22,&apos;man&apos;) direc = {&apos;user2&apos;:user,&apos;web&apos;:[&apos;python&apos;,&apos;c&apos;,&apos;c++&apos;]} return render_to_response(&apos;tagtest.html&apos;,direc) Html文件： &lt;body&gt; &lt;h&gt;Hello World!!!&lt;/h&gt; &lt;h1&gt;{{hone}}&lt;/h1&gt; &lt;h2&gt;user:&lt;/h2&gt; &lt;li&gt;name:{{li.name}}&lt;/li&gt; &lt;li&gt;age:{{li.age}}&lt;/li&gt; &lt;li&gt;sex:{{li.sex}}&lt;/li&gt; {% if user2.value == 1%} user2: name:{{user2.name}} age:{{user2.age}} sex:{{user2.sex}} {{user2.name}} say :I am {{user2.say}} {% else %} {% endif %} &lt;h2&gt;user3:&lt;/h2&gt; {% for i in web %} {{forloop.counter}}.lanuage:{{i}}#（forloop.counter有好几种for方法，此方法可以输出序列） {% endfor %} &lt;/body&gt; 在Django中操作MySQL数据库1.在MySQL中创建DataBase2.配置settings.py：添加应用(INSTALLED_APPS)，添加数据库(DataBases)，安装south管理数据库 安装South： sudo pip install South 把south加入到settings.py中的INSTALL_APPS中 INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;one&apos;, &apos;south&apos;, ) 修改好后运行一次python manage.py syncdb 将之前建好的应用由South管理了,运行： python manage.py convert_to_south one(app_name) 若该应用之前创建过相关的表，可以采用以下方法来“假装”用South创建的： python manage.py migrate one(app_name) –fake 这个意思是，表我之前就建好了，现在只是用South记录下创建记录 之后当对one(aap_name).models做修改后，执行 python manage.py schemamigration one(app_name) --auto 再执行 python manage.py migrate 即可3.编写app应用文件夹下的models.py文件 #models.py from django.db import models class Employ(models.Model):#Databases set in setting.py Employ is table, name is list, name = models.CharField(max_length = 10, null = False ,blank = False) age = models.PositiveSmallIntegerField(blank = False, null = False) sex = models.CharField(max_length = 10, null = False, blank = False) tel = models.CharField(max_length = 13, blank = False, null = False) def __unicode__(self): return self.name 最后附上Field常用字段及其选项 4.在Django上操作数据库 python manage.py shell#进入Django-shell中 from one.models import Employ #创建 first_var = Employ.objects.create(name = &apos;cc&apos;, age = 24) #查询 print Employ.objects.get(id = 1).name或first_var.name print Employ.objects.get(id = 1).age或first_var.age #创建 first_var = Employ() first_var.name = &quot;cc&quot; first_var.age = 23 first_var.save() #查询 search_var = Employ.objects.all() print search_var[0].name print search_var[0].age 5.数据库到前端显示 search_var = Employ.objects.all() return render_to_response(&apos;index.html&apos;,{&apos;name&apos;:search_var[0].name,&apos;age&apos;:search_var[0].age}) 或者直接将数据库传递到前端，再通过前端模板标签进行处理 return render_to_response(&apos;index&apos;,{&apos;person&apos;:search_var})","categories":[],"tags":[{"name":"服务器_Django","slug":"服务器-Django","permalink":"http://avalonlz.github.io/tags/服务器-Django/"}]},{"title":"MySQL","slug":"MySQL-Note","date":"2017-01-08T02:59:11.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2017/01/08/MySQL-Note/","link":"","permalink":"http://avalonlz.github.io/2017/01/08/MySQL-Note/","excerpt":"MySQL数据库学习笔记","text":"MySQL数据库学习笔记 ubuntu下安装MySQL1.sudo apt-get install mysql-server2.sudo apt-get install mysql-client3.sudo apt-get install libmysqlclient-dev 查看MySQL版本mysql -V MySQL常用命令登录数据库： mysql -uroot -p 显示所有数据库： show databases; 创建数据库： create databases database_name 选定数据库： use database_name 查看所有表： show tables; 创建表： create table table_name ( id int unsigned not null auto_increment primary key, name char(8) not null, sex char(2) not null, age tinyint unsigned not null, tel char(13) null default &quot;-&quot; ); 删除表： drop table tabe_name; 添加内容到表table_name中： insert into table_name values(1,&quot;lizhong&quot;,&quot;man&quot;,22,&quot;18040109422&quot;) 查看表中内容： select * from table_name; 查看表结构： desc table_name; 修改表某列的类型： alter table 表名 modify 列名 类型; 修改表的列名和类型： alter table 表名 change 原列名 新列名 类型; 删除表的某一列： alter table 表名 drop 列名; 添加某一列： alter table 表名 add 列名 类型; 修改表名： alter table 表名 rename 新表名; 修改表中数据： updata 表名 set 列名 = 需要改成的值 where 条件;（条件是用来指定修改哪个数据，例如条件写为id = 1） Python操作MySQL安装MySQLdb sudo apt-get install python-mysqldb 导入MySQLdb import MySQLdb 连接数据库 db = MySQLdb.connect(&quot;localhost&quot;,&quot;user(root)&quot;,&quot;password&quot;,&quot;DataBase_name(lizhong)&quot;) 使用cursor()方法获取操作游标 cu = db.cursor() 利用execute()方法操作数据库 cu.execute(&quot;数据库操作语句&quot;) 除了使用create table table_name(…)创建表语句不需要提交数据库执行外，其他添加、修改、删除都需要提交修改 db.commit()#提交修改 查询 cu.execute(&quot;select * from table_name&quot;) results = cu.fetchall()#获取所有记录列表 for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] print &quot;fname:%s&quot;,lname:%s,age:%d,sex:%s,income:%d % (fname, lanme, age, sex, income) 关闭数据库连接 db.close()","categories":[],"tags":[{"name":"服务器_MySQL","slug":"服务器-MySQL","permalink":"http://avalonlz.github.io/tags/服务器-MySQL/"}]},{"title":"LinkIt Assist2502 and LinkIt One","slug":"LinkIt-Assist2502-and-LinkIt-One","date":"2016-12-17T03:22:54.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/12/17/LinkIt-Assist2502-and-LinkIt-One/","link":"","permalink":"http://avalonlz.github.io/2016/12/17/LinkIt-Assist2502-and-LinkIt-One/","excerpt":"最近在玩LinkIt Assist2502和LinkIt One这两款MT2502可穿戴方案的板子，下面介绍下开发环境的搭建、固件更新方法以及已经实现的部分功能","text":"最近在玩LinkIt Assist2502和LinkIt One这两款MT2502可穿戴方案的板子，下面介绍下开发环境的搭建、固件更新方法以及已经实现的部分功能 开发环境的搭建：LinkIt One:&#160; &#160; &#160; &#160;LinkIt One固件版本出厂时默认是1.1.23也就是支持Arduino编程的固件版本，该版固件需要安装Arduino IDE 1.5.6-r2 BETA 或者1.5.7 BETA（推荐）版本的Arduino软件（可以在Arduino官方网站上下载），之后再安装LinkIt One的SDK（mediatek_linkitsdk(for_arduino)-1.1.23），至此完成LinkIt One 1.1.23固件版本的开发环境。&#160; &#160; &#160; &#160;LinkIt One W15.19.p2版本的固件开发环境和LinkIt Assist2502相同，下面将做简单介绍。 LinkIt Assist2502：Assist2502是在Eclipse中进行编译烧写的，所以要搭建Java的开发环境以及CDT(C/C++支持包)，我使用的是jre-8u91-windows-i586 + cdt-8.8.1 + eclipse-jee-mars-R-win32的组合，64位机可以完美运行，具体安装步骤可参照Assist2502中文指南。 固件更新：&#160; &#160; &#160; &#160;在这里主要介绍LinkIt One的固件更新方法：&#160; &#160; &#160; &#160;下载MediaTek_LinkIt_Assist_2502_SDK_2_0_46解压后进入MediaTek_LinkIt_Assist_2502_SDK_2_0_46\\LINKIT_ASSIST_SDK\\tools\\FirmwareUpdater该目录下运行FirmwareUpdater选择LinkIt One按照要求即可将LinkIt One刷成W15.19.p2版本，之后便可以和Assist2502一样使用Eclipse进行固件编写。&#160; &#160; &#160; &#160;若需要将LinkIt One刷回1.1.23则需要找到安装有LinkIt One的Arduino SDK的Arduino目录如：D:\\Arduino（当初安装LinkIt One的Arduino SDK的路径），进入目录\\Arduino\\hardware\\tools\\mtk中，运行FirmwareUpdater，按照指示，即可将LinkIt One刷回支持Arduino编程的固件版本。 已实现的功能：1、电子石英表：在240*240的LCD屏幕上绘制出了石英表效果，时针和分针两个表针，可以通过TCP上位机或者串口设置时间。2、通话功能：在程序中使用vm_gsm_tel_call_actions完成相关参数的设置，实现了接打功能3、GPS定位：串口输出GPS定位数据4、WiFi连接：通过WiFi模块接入指定AP网上关于MTK开发的资料较少，还望大家可以多多交流","categories":[],"tags":[{"name":"嵌入式_MTK","slug":"嵌入式-MTK","permalink":"http://avalonlz.github.io/tags/嵌入式-MTK/"}]},{"title":"MQTT协议","slug":"mqtt-notes","date":"2016-10-19T16:10:30.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/10/20/mqtt-notes/","link":"","permalink":"http://avalonlz.github.io/2016/10/20/mqtt-notes/","excerpt":"之前弄的MQTT协议，主要做的是QoS0和QoS1的发布者（也做了subscibe），移植了paho-mqtt中的代码，下面是具体的部分协议解析以及抓到的LOG分析。","text":"之前弄的MQTT协议，主要做的是QoS0和QoS1的发布者（也做了subscibe），移植了paho-mqtt中的代码，下面是具体的部分协议解析以及抓到的LOG分析。 mosquitto&#160; &#160; &#160; &#160;mosquitto是一款开源的mqtt服务端软件，可以部署在服务器上用于接收、下发消息，在这里我用它来调试终端的MQTT协议（需要注意mosquitto使用的mqtt协议版本为V3.1和目前最新的V3.1.1也就是第四版协议有些许出入，这在调试客户端协议时需要注意）。 在Windows下安装mosquitto：在windows下搭建MQTT服务器，使用Cygwin64+mosquitto64（Cygwin64可以不用安装） 在Linux下安装mosquitto:wget http://mosquitto.org/files/source/mosquitto-1.3.4.tar.gz//下载源代码包tar zxfv mosquitto-1.3.4.tar.gzcd mosquitto-1.3.4makesudo make install 安装注意点：【1】编译找不到openssl/ssl.h【解决方法】——安装opensslsudo apt-get install libssl-dev【2】编译过程找不到ares.h【解决方法】——修改config.mk中的WITH_SRV:=yes，改为WITH_SRV:=yes【3】使用过程中找不到libmosquitto.so.1error while loading shared libraries: libmosquitto.so.1: cannot open shared object file: No such file or directory【解决方法】——修改libmosquitto.so位置：创建链接sudo ln -s /usr/local/lib/libmosquitto.so.1 /usr/lib/libmosquitto.so.1更新动态链接库sudo ldconfig【4】make: g++：命令未找到【解决方法】安装g++编译器：sudo apt-get install g++ 建立MQTT连接&#160; &#160; &#160; &#160;建立MQTT连接主要有两部分：1、发送CONNECT报文。2、收到确认连接的CONNACK报文。以下分别作出解析，并在最后附上LOG分析。 CONNECT报文：在MQTT中CONNECT报文由固定报头、可变报头、有效载荷三部分组成。如下图所示，为CONNECT连接报文的固定报头：由图中可以看出此固定报头只有两个字节，第一个字节为固定的0x10，第二个字节为此条报文的剩余长度。如下图所示，为CONNECT连接报文中的可变报头：从图中可以看出该可变报头由10个字节组成，前6个字节为固定值，分别是协议名字符数的最高有效位、协议名字符数的最低有效位以及协议名字。第7个字节为协议的版本，此处由于后期测试开源软件所使用的MQTT协议版本为第三版所以这里需要将其改为3。接下来第8个字节中包含了CONNECT报文的诸多信息，下面分别作出解释：&#160; &#160; &#160; &#160;首先是第一位CleanSession（清理会话），该标志位用于控制会话状态的生存时间。如果该标志被设置为0，则服务端必须基于当前会话的状态恢复与终端的通讯。当连接断开之后，终端和服务端必须保存会话消息。如果该标志被置为1，若网络断开，终端和服务端必须丢弃之前的任何会话，待连接上后开始一个新的会话。也就是说会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据不能被任何之后的会话重用。由于此终端并不需要保存之前会话，所以将该位置为1。&#160; &#160; &#160; &#160;第二位Will Flag（遗嘱标志），该标志被置1，则表示如果连接请求被接受了那么有效载荷中的遗嘱（Will Message）消息必须被存储在服务端，并且与这个网络连接关联，若网络连接被服务器关闭时，服务端必须发布这个遗嘱消息，若终端发送DISCONNECT报文请求主动断开连接，则服务端需要删除这个遗嘱消息，不进行发布。由于本设计对数据的实时性要求较高，所以并不需要使用遗嘱消息机制，所以将该位置0。&#160; &#160; &#160; &#160;第三、四位为遗嘱的QoS等级标志，如果遗嘱标志被置为0，那么这两位也必须置0。若遗嘱标志被设置为1，则遗嘱的QoS值可设置为0、1、2。在设计中由于并不使用遗嘱所以这两位被写为0。&#160; &#160; &#160; &#160;第五位为遗嘱保留位，若遗嘱标志为0，则此位也需要被设置为0。若遗嘱标志位为1，此位为0则遗嘱消息作为非保留消息发布，若此位为1则遗嘱消息需要作为保留消息发布。由于并未使用遗嘱，所以该位被置为0。&#160; &#160; &#160; &#160;第六位为密码标志，若此位为0，则之后的有效载荷中不能包含密码字段。若此位为1，则之后的有效载荷中必须包含密码字段。&#160; &#160; &#160; &#160;第七位是用户名标志，当此标志被置为1时，有效载荷中必须包含用户名字段，若为0则有效载荷中不能含用户名字段。在本次设计中还未设计到数据安全性问题，所以暂不使用用户名和密码服务。&#160; &#160; &#160; &#160;对于CONNECT连接可变报头的最后两个字节即第9和第10个字节，是作为配置连接保持的时间来使用，第九字节为保持连接的最高有效位，第十字节为保持连接的最低有效位，它指的是在终端传输完成一个控制报文到发送下一个报文时，二者之间允许的最大空闲时间间隔。终端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其他的控制报文发送，终端必须发送一个心跳报文。如果保持连接值非0，并且服务端在1.5倍的保持连接时间内没有收到终端的控制报文，服务端就必须断开和终端的网络连接。若保持连接值为0，则表示关闭保持连接功能，此时服务端不需要因为终端不活跃而断开连接。此处由于GPRS模块可以在无数据交互的情况下保持12分钟的网络连接，所以将这两个字节写为0x02和0x58（10分钟）。&#160; &#160; &#160; &#160;下面说明CONNECT可变报文中的有效载荷。从以上分析、说明中可知可变报头中的标志决定了是否包含这些字段。如果包含的话必须按照以下顺序出现：终端标识符，遗嘱主题，遗嘱消息，用户名和密码。其中终端标识符必须存在，且必须是CONNECT报文有效载荷的第一个字段，需要被定义为UTF-8编码的字符串。它是作为和服务端连接的终端ID，每个终端都唯一的客户标识符。由于之前可变报头中并没有设置遗嘱、用户名及密码，所以目前有效载荷内就只有定义的终端标识符。 CONNACK报文：&#160; &#160; &#160; &#160;当终端按照上述格式发送了CONNECT报文后，服务端必须回复一个CONNACK报文作为确认连接请求。CONNACK报文格式如图2.9所示。&#160; &#160; &#160; &#160;从图中可以看出，CONNACK报文由固定报头和可变报头组成，其中固定报头为两字节的固定值0x20，0x02。可变报头则包含了连接确认标志和连接返回码，其中，连接确认标志的1至7位都必须设置为0，第0位为当前会话标志，它的作用主要是用于检测服务端和终端是否在已存储的会话状态上保持一致。具体返回码报文格式及其含义如下图所示： &#160; &#160; &#160; &#160;从上图可以看出只有当连接返回码为0x00时，连接才被正确建立。至此，完成了MQTT协议中建立连接部分的内容分析。 QoS0消息:&#160; &#160; &#160; &#160;接下来分析MQTT的PUBLISH报文，终端通过发送PUBLISH报文向服务器发送消息，若此消息为QoS0则不要求服务端做出响应，若此消息的服务质量等级大于0则需要服务端做出相应响应。&#160; &#160; &#160; &#160;从MQTT的文档中可以知道PUBLISH报文也是由固定报头、可变报头和有效载荷三部分组成。PUBLISH报文的固定报头格式如下图所示：&#160; &#160; &#160; &#160;从图中可知在PUBLISH固定报头中，第1个字节的第0位为消息保留标志，若此标志被置1，则服务端必须存储该条消息以及它的QoS，当有一个订阅者订阅同主题的消息时，服务端需要将这条消息发送给那个订阅者。第1和第2位可设置此消息的质量服务等级。第3位DUP为重发标志，该位置0，表示这是终端第一次发送这个PUBLISH报文，若该位置1，则说明这条消息是一条重发消息，若要发送QoS0的消息，则该位必须为0。&#160; &#160; &#160; &#160;下图为PUBLISH报文的可变报头格式：&#160; &#160; &#160; &#160;该可变报头主要分为两部分，即主题名和报文标识符。第1和第2个字节为主题名所占字符数的最高有效位和最低有效位。之后的一个字段便是主题名，主题名是用于识别PUBLISH报文有效载荷即消息，所对应的信息通道的。在主题名之后的两个字节分别作为报文标识符的最高和最低有效位，它是用于在QoS1和QoS2的消息传递中区分各条消息，也就是消息ID，若需要重发该PUBLISH消息，则需要使用相同的报文标识符，并且需要将DUP置一。当终端处理完这个消息所对应的响应后，该报文标识符可重用。&#160; &#160; &#160; &#160;紧跟在可变报文之后的是PUBLISH报文的有效载荷，即该主题名所对应的消息，所以QoS0的消息只需要发布一条PUBLISH报文便可以将消息上传到平台，大大节约了网络开销，降低了功耗。 QOS1消息:&#160; &#160; &#160; &#160;对于终端所发出的QoS1报文，若通讯链路正常情况下服务端还将发送一个PUBACK报文，作为终端PUBLISH报文的一个响应（PUBACK报文格式如下图所示）：&#160; &#160; &#160; &#160;从图中可知，PUBACK报文没有有效载荷，它和CONNACK相似，都由固定报头和可变报头组成，且固定报头都为一定值。唯一不同的便是PUBACK报文的可变报头变为报文标识符的最高有效位和最低有效位，此报文标识符对应着终端发送的PUBLISH报文中的报文标识符。即终端采用QoS1质量等级发送PUBLISH后，服务端将此PUBLISH报文中的报文标识符取出，加入到PUBACK报文中发出，若终端收到了带相同标识符的PUBACK报文，则代表一次QoS1通讯成功，终端可以在下一个PUBLISH报文里继续使用该标识符。若终端没能收到相对应的PUBACK报文，则说明消息未能成功发送。可能需要重新发送该条消息。下面是相应的通讯Sequence以及部分log分析：Sequence: 部分LOG分析：","categories":[],"tags":[{"name":"协议解析_MQTT","slug":"协议解析-MQTT","permalink":"http://avalonlz.github.io/tags/协议解析-MQTT/"}]},{"title":"定位","slug":"about-position","date":"2016-10-19T14:41:58.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/10/19/about-position/","link":"","permalink":"http://avalonlz.github.io/2016/10/19/about-position/","excerpt":"罗列一些LBS、GNSS、WiFi的定位方法，以及对应的三种模块的数据解析","text":"罗列一些LBS、GNSS、WiFi的定位方法，以及对应的三种模块的数据解析 定位方法：LBS: COO、Cell——ID定位（单基站） 七号信令定位（单基站） AOA（到达角度）定位（两基站） TOA（到达时间）/TDOA（到达时间差）定位（三基站） 基于场强的定位（三基站） AGPS混合定位 GNSS: GPS 北斗 伽利略 Glonass WiFi: 获取附近WiFi信号源的MAC地址上传到相应的定位服务器上，定位服务器搜索数据库，找到MAC地址所对应的经纬度坐标，并返回。 数据解析：WiFi(ESP8266模块):WifiInfo,1（wifi数量），c4…b3（mac地址），-90（wifi信号，信号最好-100），1a(校验和$…到之间所有字符ASCII码的校验和，各字节做异或运算，得到校验和后，再转换16进制格式的ASCII字符) GPS模块： 打开此GNSS模块就会有数据输出，应该也是封装好指令的GNSS模块。数据格式符合NMEA-0183协议，返回数据如下： ① GPGGA（GPS定位信息）：重要，主要用来取水平精度衰减因子（HDOP）和高度$GPGGA,,,,,,,,,,,,,,hh$GPGGA（GGA协议头）,235949.317（定位点的UTC时间，协调世界时）,（纬度）,（纬度方向）,（经度）,（经度方向）,0（GPS定位指示状态）,（使用卫星数量）,（水平精度衰减因子）,（海平面高度）,M（高度单位）,（大地椭球面相对于海平面的高度）,M（高度单位）,（差分修订时间）,(差分参考基站ID号)4D（校验和） ②GPGLL（地理定位信息）：重要$GPGLL（GLL协议头）,（纬度）,（纬度方向）,（经度）,（经度方向）,235949.317（定位点的UTC时间）,V（状态 标志）,N（未知）*7F（校验和） ③GPGSA（当前卫星信息）：$GPGSA,,,,,,,,,,,,,,,,,hh$GPGSA（GSA协议头）,A,1,,,,,,,,,,,,,,,1E ④GPGSV（可见卫星信息）：$GPGSV,,,,,,,,…,,,,hh$GPGSV,1,1,0079（以上信息说明没有搜到卫星） ⑤GPRMC(最简定位信息)：重要，主要取了磁偏角以上的数据$GPRMC,,,,,,,,,,,hh$GPRMC（协议头）,235955.800（定位点UTC时间）,V（定位状态）,（纬度）,（纬度方向）,（经度）,（经度方向）,0.00（对地航速）,0.00（对地航向）,050180（定位点UTC日期）,（磁偏角）,（磁偏角方向）,N（未知）44（校验和） ⑥GPVTG（地面速度信息）：$GPVTG,,,,,,,,hh$GPVTG,0.00,T,,M,0.00,N,0.00,K,N32","categories":[],"tags":[{"name":"协议解析_定位","slug":"协议解析-定位","permalink":"http://avalonlz.github.io/tags/协议解析-定位/"}]},{"title":"Raspberry Pi-Commands","slug":"raspberry-pi-commands","date":"2016-04-01T03:58:34.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/04/01/raspberry-pi-commands/","link":"","permalink":"http://avalonlz.github.io/2016/04/01/raspberry-pi-commands/","excerpt":"玩Raspberry Pi常用的Linux命令","text":"玩Raspberry Pi常用的Linux命令 目录相关cd [文件夹路径] ：进入文件夹（如cd /home/pi，进入pi文件夹）cd .. :返回该目录下的上级目录cd - ：返回进入该目录前所在目录 列出文件夹内容命令ls ：列出该目录下文件和文件夹（不包括隐含文件）ls -l ：列出该目录下文件、文件夹详细信息（包括隐含文件） 移动命令mv -i [需要移动的文件路径，需要选择文件本身] [文件新路径，不需要选择文件本身] ：移动文件到新目录，若有同名文件则询问是否需要覆盖。（例如，mv -i /home/pi/Desktop/test/testone.c /home/pi/ 将testone.c文件移动到pi文件夹下）可以使用mv命令进行重命名 ：例如，mv /home/pi/Desktop/test/testone.c /home/pi/Desktop/test/testtwo.c 复制文件cp -i [要复制的文件所在路径，包括文件本身] [文件新路径，不包括文件本身] ：复制文件到新目录，若新目录有同名文件则询问是否需要覆盖。(例如，cp -i /home/pi/Desktop/test/testone.c /home/pi/)个人喜欢使用cp -Rf，不提示直接覆盖同名文件 删除rm -r [目录路径]：删除整个目录（目录路径换为文件路径即可删除文件） 权限在Debain中主要使用是chmod命令chmod [who] [+或-或=] [mode] [文件名]：who是指需要指定的用户，包括：u文件所有者。g同组用户。o其他用户。a所有用户（系统默认是a）+是指添加某个权限，-是取消某权限，=是给指定的权限mode表示权限，包括：r可读。w可写。x可执行（这几个常用）等其他一般使用chmod 777 [文件名]：所有用户拥有可读可写可执行权限 压缩和解压tar [主选项+辅选项] 文件或者目录 压缩例：tar -cf xxx.tar xxx U盘挂（卸）载mount -t vfat /dev/sdb1/ /mnt//dev/sdb1/ ：是在dev文件下显示的驱动，需要自己查找，可以进入dev中查看，也可以用fdisk -l命令查看/mnt/ ：挂载点，即需要将U盘挂载在何处 umount /mnt/ ：卸载U盘 查看所有进程ps -A 查看当前路径下的所有文件ls –all （未完）","categories":[],"tags":[{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"http://avalonlz.github.io/tags/Raspberry-Pi/"}]},{"title":"stm32-SPI","slug":"stm32-spi","date":"2016-03-30T04:36:39.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/03/30/stm32-spi/","link":"","permalink":"http://avalonlz.github.io/2016/03/30/stm32-spi/","excerpt":"记录STM32硬件SPI和W25Q64通讯关键处，及模拟SPI和硬件SPI的不同之处。若有不同见解，还望留言一同交流学习。","text":"记录STM32硬件SPI和W25Q64通讯关键处，及模拟SPI和硬件SPI的不同之处。若有不同见解，还望留言一同交流学习。 STM32主机初始化对于硬件SPI来说主机初始化需要配置较多东西，而且其中有些配置存在争议，所以在此做一个详细记录。 void spi_init(void) { SPI_InitTypeDef SPI2_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE); /////////scl,mosi GPIO_InitStructure.GPIO_Pin=GPIO_Pin_13|GPIO_Pin_15; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /////////miso，最好根据手册设置为上拉，有些程序设置成复用推挽输出，因为芯片结构的原因所以也可行 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); ///////////////NSS，选择为soft模式后需要人工进行片选操作 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_12; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); GPIO_SetBits(GPIOB,GPIO_Pin_12);//操作前先不选择从器件 SPI2_InitStructure.SPI_Mode=SPI_Mode_Master; SPI2_InitStructure.SPI_Direction=SPI_Direction_2Lines_FullDuplex; SPI2_InitStructure.SPI_DataSize=SPI_DataSize_8b; //以下两个配置关系到芯片何时进行数据采集（采样），后做详解 SPI2_InitStructure.SPI_CPOL=SPI_CPOL_Low; SPI2_InitStructure.SPI_CPHA=SPI_CPHA_1Edge; //该处设置必须为软件模式，也就是人为操作CS引脚进行片选，而不是芯片根据自己时序操作，NSS引脚作为普通GPIO口置低电平进行片选 SPI2_InitStructure.SPI_NSS=SPI_NSS_Soft; SPI2_InitStructure.SPI_BaudRatePrescaler=SPI_BaudRatePrescaler_2; SPI2_InitStructure.SPI_FirstBit=SPI_FirstBit_MSB; //CRC校验，这一个参数在整个操作中并没用使用上，对CRC校验该处的设置持默认态度 SPI2_InitStructure.SPI_CRCPolynomial=7; SPI_Init(SPI2, &amp;SPI2_InitStructure); SPI_Cmd(SPI2, ENABLE); } SPI2_InitStructure.SPI_CPOL=SPI_CPOL_Low;和SPI2_InitStructure.SPI_CPHA=SPI_CPHA_1Edge;是分别对SPI的时钟极性和时钟相位进行配置，主要有4种模式（0，0），（0，1），（1，0），（1，1）这四种模式要根据从器件的采集时序（时钟）来配置，需要和从设备相同（例如从设备只支持(0,0)模式那这里就需要配置为（0，0））。下图对这四种模式做详细介绍： 写入数据根据STM32参考手册SPI部分可以知道硬件SPI需要检测的标志位相对于硬件I2C来说少了很多，所以以32作为主机做硬件SPI的编码会更需要从器件的事件发生时序入手，下面是一个写入操作，配DATESHEET事件图： void SPI_Flash_Write_Page(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite) { u16 i; SPI_FLASH_Write_Enable(); SPI_FLASH_CS_CLR; SPI2_ReadWriteByte(0x02); SPI2_ReadWriteByte((u8)((WriteAddr)&gt;&gt;16)); SPI2_ReadWriteByte((u8)((WriteAddr)&gt;&gt;8)); SPI2_ReadWriteByte((u8)WriteAddr); for(i=0;i&lt;NumByteToWrite;i++)SPI2_ReadWriteByte(pBuffer[i]); SPI_FLASH_CS_SET; SPI_Flash_Wait_Busy(); } 因为nor flash写入前必须擦除，根据DATESHEET描述在擦除操作前需要先写使能，所以先执行写使能函数，再发送一个0x02擦除4K存储地址命令，接下来发送由三个8位数据组成的地址，最后发送写入的数据，关片选，忙检测。基本写入函数（可以看出根据32的手册分别做了标志位检测）： u8 SPI2_ReadWriteByte(u8 TxData) { u8 retry=0; while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET) { retry++; if(retry&gt;200)return 0; } SPI_I2S_SendData(SPI2, TxData); retry=0; while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET) { retry++; if(retry&gt;200)return 0; } return SPI_I2S_ReceiveData(SPI2); } 写使能函数： void SPI_FLASH_Write_Enable(void) { SPI_FLASH_CS_CLR; SPI2_ReadWriteByte(0x06); SPI_FLASH_CS_SET; } 忙检测，需要特殊强调下。这里的忙检测并不是对32来说的所以不可以用32库中的SPI_I2S_FLAG_BSY标志来判别，此处是对从设备的忙检测，检测从设备是否操作完成，这一步需要通过读取W25Q64的状态寄存器实现 void SPI_Flash_Wait_Busy(void) { while ((SPI_Flash_ReadSR()&amp;0x01)==0x01); } u8 SPI_Flash_ReadSR(void) { u8 byte=0; SPI_FLASH_CS_CLR; SPI2_ReadWriteByte(0x05);//读取状态标志位寄存器命令 byte=SPI2_ReadWriteByte(0Xff); SPI_FLASH_CS_SET; return byte; } 这里有个发送0XFF数据，这里必须的。必须向从器件发送一个无关的数据，以便产生SCLK时钟。硬件SPI发送时才会产生SCLK时钟，所以在读取时要同时发送一个数据。这也是硬件SPI和模拟SPI差别最大的地方。 读取数据数据的读取也是依据DATESHEET上的事件产生时间来操作，需要注意的依然是读取数据时还需要写入无关数据 void SPI_Flash_Read(u8* pBuffer,u32 ReadAddr,u16 NumByteToRead) { u16 i; SPI_FLASH_CS_CLR;//将NSS引脚置低电平，选择从设备 SPI2_ReadWriteByte(0x03); SPI2_ReadWriteByte((u8)((ReadAddr)&gt;&gt;16)); SPI2_ReadWriteByte((u8)((ReadAddr)&gt;&gt;8)); SPI2_ReadWriteByte((u8)ReadAddr); for(i=0;i&lt;NumByteToRead;i++) { pBuffer[i]=SPI2_ReadWriteByte(0XFF); } SPI_FLASH_CS_SET;//将NSS引脚置高电平，不选择该从设备 } 由于SPI是高速通讯协议，所以能用硬件SPI就尽量采用硬件解决，此处就不贴出模拟SPI的程序了。","categories":[],"tags":[{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"}]},{"title":"Linux文件系统Mindmap","slug":"Linux-FileSysmind-map","date":"2016-03-26T06:17:50.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/03/26/Linux-FileSysmind-map/","link":"","permalink":"http://avalonlz.github.io/2016/03/26/Linux-FileSysmind-map/","excerpt":"昨晚发现的一个不错的Linux系统思维导图，很早就想总结了，在此感谢下此图作者","text":"昨晚发现的一个不错的Linux系统思维导图，很早就想总结了，在此感谢下此图作者有需要的少年可以扒走","categories":[],"tags":[{"name":"百科_Linux","slug":"百科-Linux","permalink":"http://avalonlz.github.io/tags/百科-Linux/"}]},{"title":"stm32-I2C","slug":"stm32-I2C","date":"2016-03-26T06:16:32.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/03/26/stm32-I2C/","link":"","permalink":"http://avalonlz.github.io/2016/03/26/stm32-I2C/","excerpt":"看寄存器文档写了一天硬件I2C，写了好几遍都不对，最后还是用库了。。。。。。。。","text":"看寄存器文档写了一天硬件I2C，写了好几遍都不对，最后还是用库了。。。。。。。。看了下火哥的代码，发现其实stm32固件库已经把每一步需要检测的标志位封装好了，我们要做的只是根据文档来检测这些标志，并采取下一步动作。下面是STM32和AT24C02的硬件I2C分析 硬件I2C主发送下图是stm32主发送时序图和AT24C02的写字节操作流程图，其中EV5、EV6、EV8_1、EV8、EV8_2、EV9这些事件标志在stm32的官方固件库都有详细编写出来（stm32f10x_i2c.h），我们只需调用检测即可。野火的硬件I2C也就是在这两个图和官方固件库的基础上编写的。有详细的英文注释，很好理解 void I2C_EE_ByteWrite(u8* pBuffer, u8 WriteAddr)//将pBuffer地址内的数据写入AT24C02的指定地址中 { /* Send STRAT condition */ I2C_GenerateSTART(I2C2, ENABLE); /* Test on EV5 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT)); /* Send EEPROM address for write */ I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Transmitter); /* Test on EV6 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); /* Send the EEPROM&apos;s internal address to write to */ I2C_SendData(I2C2, WriteAddr); /* Test on EV8 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); /* Send the byte to be written */ I2C_SendData(I2C2, *pBuffer); /* Test on EV8 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); /* Send STOP condition */ I2C_GenerateSTOP(I2C2, ENABLE); } 硬件I2C主接收和发送一样，这些事件标志在官方库中都有写出，但是需要注意由于是操作AT24C02所以根据它的要求在读之前会需要先写入需要读出的数据所在地址，所以接收数据前还需要先写数据。以下是野火的AT2402读操作函数： void I2C_EE_BufferRead(u8* pBuffer, u8 ReadAddr, u16 NumByteToRead)//从ReadAddr处读出 { //*((u8 *)0x4001080c) |=0x80; while(I2C_GetFlagStatus(I2C2, I2C_FLAG_BUSY)); // Added by Najoua 27/08/2008 /* Send START condition */ I2C_GenerateSTART(I2C2, ENABLE); //*((u8 *)0x4001080c) &amp;=~0x80; /* Test on EV5 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT)); /* Send EEPROM address for write */ I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Transmitter); /* Test on EV6 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); /* Clear EV6 by setting again the PE bit */ I2C_Cmd(I2C2, ENABLE); /* Send the EEPROM&apos;s internal address to write to */ I2C_SendData(I2C2, ReadAddr); /* Test on EV8 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); /*以上都还为写操作阶段，接下来准备读*/ /* Send STRAT condition a second time */ I2C_GenerateSTART(I2C2, ENABLE); /* Test on EV5 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT)); /* Send EEPROM address for read */ I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Receiver); /* Test on EV6 and clear it */ while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)); /* While there is data to be read */ while(NumByteToRead) { if(NumByteToRead == 1) { /* Disable Acknowledgement */ I2C_AcknowledgeConfig(I2C2, DISABLE); /* Send STOP Condition */ I2C_GenerateSTOP(I2C2, ENABLE); } /* Test on EV7 and clear it */ if(I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED)) { /* Read a byte from the EEPROM */ *pBuffer = I2C_ReceiveData(I2C2); /* Point to the next location where the byte read will be saved */ pBuffer++; /* Decrement the read bytes counter */ NumByteToRead--; } } /* Enable Acknowledgement to be ready for another reception */ I2C_AcknowledgeConfig(I2C2, ENABLE); } 硬件I2C主发送操作后的检测函数火哥他对寄存器文档把握很准，需要什么不需要什么都很了解，当然也很熟悉官方固件库的内容，绝逼是老手了。下面一个函数是再次写入设备地址，用于检测从设备是否有响应，判断是否从设备已完成了以上数据写入操作。 void I2C_EE_WaitEepromStandbyState(void) { vu16 SR1_Tmp = 0; do { /* Send START condition */ I2C_GenerateSTART(I2C2, ENABLE); /* Read I2C2 SR1 register */ SR1_Tmp = I2C_ReadRegister(I2C2, I2C_Register_SR1); /* Send EEPROM address for write */ I2C_Send7bitAddress(I2C2, EEPROM_ADDRESS, I2C_Direction_Transmitter); }while(!(I2C_ReadRegister(I2C2, I2C_Register_SR1) &amp; 0x0002)); /* Clear AF flag */ I2C_ClearFlag(I2C2, I2C_FLAG_AF); /* STOP condition */ I2C_GenerateSTOP(I2C2, ENABLE); } 模拟I2C对于模拟I2C这里只记录几点重要的地方，代码就不贴出来了。 开始信号：SDA、SCL都为高的前提下，SDA跳为低电平。 停止信号：SCL为高时，SDA由低电平跳为高电平。 数据变化：只有当SCL为低电平的时候SDA线上的数据（高低电平）才可以变化。 等待ACK时，需要将SDA的GPIO引脚变为浮空输入。","categories":[],"tags":[{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"}]},{"title":"stm32-flash","slug":"stm32-flash","date":"2016-03-24T14:11:06.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/03/24/stm32-flash/","link":"","permalink":"http://avalonlz.github.io/2016/03/24/stm32-flash/","excerpt":"关于stm32写片内Flash操作的记录","text":"关于stm32写片内Flash操作的记录 标准编程在对Flash进行写入操作前，都必须先解锁Flash再擦除操作目的地址所在页。之后再写入 对FLASH_KEYR寄存器分别依次写入0x45670123和0xCDEF89AB 检查FLASH_SR寄存器的BSY位，为0才可操作 将FLASH_CR的第2位置一，配置为页擦除 将需要擦除的地址填入FLASH_AR寄存器 FLASH_CR寄存器第6位置一，开始擦除 检测FLASH_SR的EOP位，完成后硬件会置1，再将其写入1清零 将FLASH_CR的第2位置零 检测BSY位，判断是否繁忙准备写入数据 将FLASH_CR第一位写1 将数据写入地址 检测FLASH_SR的EOP位判断是否完成 寄存器和库函数版本： ////////////////////////////////////寄存器 FLASH-&gt;KEYR=(uint32_t)0x45670123; FLASH-&gt;KEYR=(uint32_t)0xCDEF89AB; while((FLASH-&gt;SR &amp; 0x00000001)!=0); FLASH-&gt;CR|=0x00000002; FLASH-&gt;AR=0x0807FFFe; FLASH-&gt;CR|=0x00000040; while(0==(FLASH-&gt;SR &amp; 0x00000020)); FLASH-&gt;SR |= 0x00000020; FLASH-&gt;CR&amp;=0x00001FFD; while(0!=(FLASH-&gt;SR &amp; 0x00000001)); FLASH-&gt;CR|=0x00000001; *(__IO uint16_t*)writeone=(uint16_t)0x8765; while(0==(FLASH-&gt;SR &amp; 0x00000020)); FLASH-&gt;SR |= 0x00000020; ////////////////////////////////////库函数 FLASH_Unlock(); status1=FLASH_ErasePage(writeone); status2=FLASH_ProgramHalfWord(writeone, 0x1234);","categories":[],"tags":[{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"}]},{"title":"关于存储设备","slug":"storage","date":"2016-03-23T06:29:34.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/03/23/storage/","link":"","permalink":"http://avalonlz.github.io/2016/03/23/storage/","excerpt":"简要说明内存：RAM、PROM、OTP ROM，以及外存：nor flash、nand flash、硬盘、EEPROM等存储类设备。","text":"简要说明内存：RAM、PROM、OTP ROM，以及外存：nor flash、nand flash、硬盘、EEPROM等存储类设备。查阅很多资料都不知道该把以上两种flash归到内存还是外存中……好吧，它就是闪存，姑且先归为外存吧，如果有people知道还请告知一二。 1.内存 RAMRAM分为两种，SDRAM（同步动态随机存储器）以及SRAM(静态随机存储器).SDRAM：存储阵列会不断刷新数据。一般来说电脑内存、手机的运行内存这类存储器都是SDRAM 。SRAM：存储阵列不会一直刷新数据，读写速度飞快，价格昂贵。一般只用作电脑CPU的一二级缓存和单片机存放数据的片上内存（RAM） 。 PROMPROM只读存储器，ROM的一种，具有一次写入，不可更改的特性，一般在生产小东西（生日贺卡）时将代码固化到PROM中。 OTP ROM和PROM一样，一次写入，不可更改。区别在于OTP ROM是生产完后再写入程序。 2.外存 nor flashnar flash闪存的一种，一般单片机中的flash就是指nor flash。用于存储程序，掉电保存。并行口的nor flash可不经过RAM直接运行程序，也有SPI、I2C等串行口的nor flash，单片机内集成一般是并行口的。 nand flashnand flash也是闪存的一种，只能以块为单位进行读取，但写入速度比nor flash快很多，所以一般nand flash做mp3、U盘、固态硬盘、SD卡、数码相机等产品的集成存储设备。 nor flash和nand flash的主要区别可以看作： nor flash每次写入前都需要将目标块的所有位都写0 并行口的nor flash可以不需要驱动程序，而nand flash一定需要驱动程序 硬盘很常见的直观的存储设备 EEPROMROM的一种，可以进行多次读写，一般用在机器锁这方面，需要利用电压来擦除程序。","categories":[],"tags":[{"name":"百科_存储","slug":"百科-存储","permalink":"http://avalonlz.github.io/tags/百科-存储/"}]},{"title":"使用DNSpod做域名解析问题","slug":"use-dnspod","date":"2016-03-20T07:28:27.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/03/20/use-dnspod/","link":"","permalink":"http://avalonlz.github.io/2016/03/20/use-dnspod/","excerpt":"上GoDaddy买的域名，使用DNSpod做解析，按网上教程配置DNSpod出错，SO在此记录。","text":"上GoDaddy买的域名，使用DNSpod做解析，按网上教程配置DNSpod出错，SO在此记录。 首先在GoDaddy上买完域名，进入域名管理（域名详细信息），部分显示信息如下图GoDaddy上的配置主要是更改域名服务器，即借用DNSpod的免费域名解析服务器。 进入DNSpod开启域名解析服务，添加需要解析的域名。之后点击刚才添加的域名进入域名解析配置，复制灰色的“记录值”即免费的域名解析服务器（F1G1NS1.DNSPOD.NET和F1G1NS2.DNSPOD.NET），填入GoDaddy上域名管理的“域名服务器处”，GoDaddy配置完成。 回到DNSpod的域名解析配置，此处添加两个A记录即可，无需再添加CNAME（别名记录），两个A记录都指向需要访问的主机IP 配置完成。如果按网上某些教程添加CNAME记录，依然是可以Ping通，但是正常访问时可能会报unknow domain错误。 2017.12.27在GoDaddy又更换了域名（继续续费原域名贵啊），发现GoDaddy已经支持解析了，就直接在GoDaddy上做了解析","categories":[],"tags":[{"name":"百科_DNSpod","slug":"百科-DNSpod","permalink":"http://avalonlz.github.io/tags/百科-DNSpod/"}]},{"title":"stm32-SysTick嘀嗒定时器","slug":"stm32-SysTick","date":"2016-02-29T13:48:54.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/02/29/stm32-SysTick/","link":"","permalink":"http://avalonlz.github.io/2016/02/29/stm32-SysTick/","excerpt":"由stm32F103zet6嘀嗒定时器引申出的系统中断和外设中断问题。","text":"由stm32F103zet6嘀嗒定时器引申出的系统中断和外设中断问题。 嘀嗒定时器（SysTick）在外部中断里使用滴答定时器延时（理论上中断里不可以延时，此处只做研究嘀嗒的工作方式用）,直接调用void SysTick_Init(void)函数后在中断中使用延时发现不起作用。（中断配置为只有抢占优先级模式，并且外部中断优先级设为1）后找到SysTick_Init、SysTick_Config、NVIC_SetPriority函数，最后在NVIC_SetPriority函数中发现写了SCB系统控制寄存器组中SHP系统操作优先级寄存器的第11位（SHP[11]），默认SysTick初始化后是7。之后将该位写0（SCB-&gt;SHP[11]=0;），即把嘀嗒的优先级调到了0（最高）。开启后可行。通过查看NVIC_SetPriority函数发现，配置32的中断优先级有两个寄存器，分别是配置配置系统中断和外设中断的，这二者的中断关系通过查看M3的权威手册发现是同级的关系，SO在有理论依据的基础上就可以大胆配置了。 外部中断的IO口映像图：","categories":[],"tags":[{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"}]},{"title":"stm32-总线结构、引脚功能及其配置","slug":"stm32-gpio-function-configure","date":"2016-02-29T13:29:23.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/02/29/stm32-gpio-function-configure/","link":"","permalink":"http://avalonlz.github.io/2016/02/29/stm32-gpio-function-configure/","excerpt":"stm32F103zet6的总线结构、引脚功能，以及使用各个功能该如何配置GPIO引脚。","text":"stm32F103zet6的总线结构、引脚功能，以及使用各个功能该如何配置GPIO引脚。 总线结构在配置stm32的事件输出/外部中断/重映射端口复用时，必须开启AFIO时钟。使用管脚的Default(默认)功能并不需要开AFIO时钟，只需要配置相应的功能时钟。 引脚定义（功能）位于stm32f103zet6 datasheet中 不同功能的引脚配置位于stm32f103zet6参考守则中","categories":[],"tags":[{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"}]},{"title":"stm32-USART+DMA配置","slug":"stm32-USART_DMA","date":"2016-02-29T03:16:51.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/02/29/stm32-USART_DMA/","link":"","permalink":"http://avalonlz.github.io/2016/02/29/stm32-USART_DMA/","excerpt":"介绍stm32F103zet6各功能可以请求的DMA通道，以及对USART2+DMA进行配置。","text":"介绍stm32F103zet6各功能可以请求的DMA通道，以及对USART2+DMA进行配置。 DMA通道各功能可以请求的DMA通道 USART+DMA配置main函数，采用寄存器方式配置DMA： int main(void) { uint8_t tx[10]={0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10}; SysTick_Init(); UART_Initone(); //////////////////////////////////////////DMA RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); DMA1_Channel7-&gt;CNDTR=sizeof(tx); DMA1_Channel7-&gt;CPAR=(uint32_t)(&amp;USART2-&gt;DR);//目的地址 DMA1_Channel7-&gt;CMAR=(uint32_t)tx; DMA1_Channel7-&gt;CCR=(uint32_t)0x1090;//对CCR寄存器配置为非存储器到存储器模式等其他 DMA1_Channel7-&gt;CCR|=(uint32_t)0x0001; ////////////////////////////////////////// LED2_ON; LED3_ON; while(1) { } } USART2初始化函数UART_Initone: void UART_Initone(void) { GPIO_InitTypeDef GPIO_InitStructureuart; USART_InitTypeDef usartone; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); //TX_GPIO GPIO_InitStructureuart.GPIO_Pin = GPIO_Pin_2; GPIO_InitStructureuart.GPIO_Mode=GPIO_Mode_AF_PP; GPIO_InitStructureuart.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructureuart); //RX_GPIO GPIO_InitStructureuart.GPIO_Pin = GPIO_Pin_3; GPIO_InitStructureuart.GPIO_Mode=GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA, &amp;GPIO_InitStructureuart); usartone.USART_BaudRate=9600; usartone.USART_WordLength=USART_WordLength_8b; usartone.USART_StopBits=USART_StopBits_1; usartone.USART_Parity=USART_Parity_No; usartone.USART_HardwareFlowControl=USART_HardwareFlowControl_None; usartone.USART_Mode=USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART2, &amp;usartone); USART_DMACmd( USART2, USART_DMAReq_Tx, ENABLE);/////使能USART2的DMA请求 USART_Cmd(USART2, ENABLE);//使能USART } 不开中断就不需要配置NVIC。","categories":[],"tags":[{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"}]},{"title":"Win7下安装Linux双系统","slug":"two-system","date":"2016-01-31T15:14:50.000Z","updated":"2018-11-24T04:18:03.724Z","comments":true,"path":"2016/01/31/two-system/","link":"","permalink":"http://avalonlz.github.io/2016/01/31/two-system/","excerpt":"Win7系统下安装Fedora/Centos。","text":"Win7系统下安装Fedora/Centos。 一、用磁碟通将Linux镜像写入U盘，使用USB-HDD+即可： 二、U盘引导启动，按e进入路径编辑界面，修改：hd:/dev/sdc4(U盘路径，根据硬盘数和gurb中cat命令的自动补全获得hd号和mosed号)quiet(redhat类的Linux的都是在:后进行修改，修改到or前为止) 三、之后会引导入安装界面： 语言选择可汉语，可以选择多种语言支持。 软件选择可以选择需要安装的桌面，常见有GNOME和KDE。 分区使用标准分区，分/swap（2G）和/（剩余空间）两个区，并且选择无需添加引导。（一定要记下/分区获得的sdb9此类设备名称，稍后配置引导要用） 四、进入windows使用easyBCD添加GRUB2启动项重启进入GRUB2中输入命令cat（hd1（第二块硬盘），按次tab找到/分区所在位置并记入。再输入： kernel (hd1,8) （hd1,8 cat命令查出的路径）/boot/vm …….按tab查找…… root=/dev/sdb9 (boot所在处因为此处未单独创建/boot分区所以使用/分区的路径) quiet vga=791//引导启动Linux内核 initrd (hd1,8)/boot/ini…..按tab……. .img //引导启动图像界面 boot //开始引导之后进入Linux，可在linux中再次找到两个引导文件的所在路径并记录下来稍后要用（因为有tab可以补全路径） 五、再次进入windows使用easyBCD添加新条目，创建NeoGrub引导并做如下配置： default 0//默认第一个引导启动，也可不写 timeout 3//等待3秒 title fedora kernel (hd1,8)/boot/vmlinuz-4.2.3-300.fc23.x86_64 root=/dev/sdb9 quiet （vga=791可以不加） initrd (hd1,8)/boot/initramfs-4.2.3-300.fc23.x86_64.imgboot第五步和第四步中的kernel和initrd命令之后的路径都相同 完成双系统安装","categories":[],"tags":[{"name":"百科_双系统安装","slug":"百科-双系统安装","permalink":"http://avalonlz.github.io/tags/百科-双系统安装/"}]},{"title":"C++notes","slug":"C-notes-0","date":"2016-01-27T04:38:49.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2016/01/27/C-notes-0/","link":"","permalink":"http://avalonlz.github.io/2016/01/27/C-notes-0/","excerpt":"C++知识点，不定期更新","text":"C++知识点，不定期更新 面向对象设计思想一个需要做的东西A，先一层一层的找出最底层需要做的东西B，然后定义一个B类（允许只有方法），再将需要做的东西上升一个层次C再定一个C类（可以继承B,或者定义一个B类的变量，这样就可以包括B类的方法等），然后再上一层定义一个D类（同样继承C,或者定义一个C）…..如此直到到达A层 类的声明和定义class A;//声明 class A{ ... };//定义,若在类中有实例化其他类的对象，需要在此类定义前，加入其他类的声明 类继承相关：默认private继承 子类继承模板类的时候，记得加与该子类相同的模板参数： template &lt;typename P&gt; class Child:public Father&lt;P&gt;{//注意父模板类也需要传入P，否则报错 ... } 子类在调用父类的成员函数时，最好使用 父类class名::父类成员函数名()，防止子类中有同名函数而引起的歧义（若子类中存在，不加的话，默认是采用就近调用原则的） 名称空间相关 名称空间一般放入的东西:类声明、定义（不含类方法的具体实现）以及一些全局性的东西 运算符重载 格式：返回类型 operator 符号(A(类名) &amp;x){具体实现}//同类型参数可以访问私有成员（同一类的成员函数可以访问同一类的私有成员） bool operator *(double j);//作为类成员函数时的声明 bool operator *(A i, doublej) { ... }//作为非类成员函数时的定义，非类成员函数重载运算符时，需要传递两个参数，且分别对应了运算符的左右两边 友元函数：使用非成员函数，也可以直接访问类的私有成员，非类成员函数所以具体实现时不用加:: 友元函数不是类的成员函数！但友元函数可作为类的扩展接口 friend void function(A &amp;i);//在A类中声明，则function为友元函数，可以调用A类中的私有成员，外部实现时不必再加friend void function (A &amp;i) { ... }//外部实现 类类型的自动转换和强制类型转换(两种格式，对应不同方法) 自动转换利用一个参数的构造函数实现(如：int-&gt;类类型)，取消自动隐式转换在构造函数前加入explicit operator 类型() Stonewt mycat; mycat = 19.2;//此处自动调用了Stonewt中的构造函数，生成了一个临时对象，再赋值给mycat,若在构造函数前加explicit则会报错 mycat = Stonewt(19.2)；//以下两种用了operator 类型() 的转换函数(转换函数必须是类方法，不能指定返回类型，不能有参数)，如：operator int(); mycat = (Stonewt)19.2; 虚函数 构造函数不可以为虚函数或纯虚函数，析构函数可以为虚函数或纯虚函数 virtual void function();//function为虚函数，需要在类中或类外对其进行实现，子类（派生类）可以重写它：void function() 纯虚函数（只在类中声明了函数体，并未在类中或类外定义该函数）：virtual void function() = 0;//function为纯虚函数纯虚函数相当于一接口，想要使用它就必须要派生类来具体实现其定义，这有利于编码的分工合作 浅拷贝和深拷贝 浅拷贝：只对对象的数据成员进行简单复制，涉及到动态分配时，如果按浅拷贝进行复制，不做特殊处理，复制完成后，两个对象中涉及动态分配的变量，会指向同一内存区域，导致析构释放内存时出现错误 深拷贝：对新产生的指针变量进行动态内存分配再赋值给新的指针变量，并拷贝整个内存区域 默认复制构造函数、=运算符，所进行的都是浅拷贝 浅拷贝可能引发的问题：1、析构时，同一个内存空间被释放两次，会出错2、浅拷贝后，指针指向同一内存空间，任何一方改变都会影响到另一方 拷贝/复制构造函数 默认的复制构造函数进行的是浅拷贝 何种情况会调用复制构造函数：1、程序中需要建立一个新对象，并用另一个同类的对象对它进行初始化时：A x = y;//不同于A a;a = y;后一种情况调用的是该类等号的重载函数（若存在的话，未定义的话，会存在一个默认的，同样是进行浅拷贝）2、当函数的参数为类对象时，传入实参，会调用复制构造函数3、当函数返回类型是一个类的时候 若要防止调用拷贝构造函数可声明一个private类型的拷贝函数 拷贝/复制构造函数：func(const typename &amp; x)#注意没void，func的命名和class名相同func(typename &amp; x)func(volatile typename &amp; x)func(const volatile typename &amp; x) 重载与重写 重载：函数的重载，只要满足名字相同，参数不同就可以实现重载（类型或个数不同都可以实现重载），只有返回类型不同，其他相同，编译器会报错，无法实现重载。返回类型和参数同时改变则可以实现重载 重写：需要返回类型相同，参数相同，函数名也相同才能实现重写。若只有返回类型不同，则会报错，若参数不同则会认为是另一个函数 C++引用 引用可以看做实参的别名，在函数内对形参的修改其实就是对实参的修改，非指针类型 C++中引用不可以传常量，如果用const修饰后则可以 const typename &amp;i 和 typename const &amp;i的区别（暂时认为是一样的） C++ Template 将数据类型变为可后期指定（使得数据类型可定制化） 非类型的模板形参可以当宏定义使用，但非类型形参只能是整型、指针和引用： template&lt;class T, int VALUE&gt;//VALUE为非类型模板形参 class B { private: T element = VALUE; } 静态成员变量和静态成员函数 静态成员变量：所有对象共享同一个静态成员变量（内存共享），初始化：类型 类名::变量名 = …; 静态成员函数： 单冒号 类构造函数初始化列表 class firstclass{ private: int a; const int b; public: firstclass(); }; firstclass::firstclass():a(1), b(1){}//对变量a和const变量b进行初始化，可以对const变量进行初始化赋值。初始化顺序要和类中成员变量的声明顺序相同 对于继承的类类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序对子类成员变量进行初始化 QT：信号和槽 connect一次，就会产生一个回调函数，并不会覆盖 connect(viewpic, SIGNAL(clicked()), this, SLOT(paintEvent(QPaintEvent )));这样写是不对的，错在：1、首先信号和槽函数参数类型需要一致，就类似int对int，不管是系统自带的还是自己定义的，首先参数类型都要一致。此处clicked()是无参数的，而paintEvent(QpaintEvent )却带有参数2、其次，connect中不能传入实际的参数","categories":[],"tags":[{"name":"计算机语言_C++","slug":"计算机语言-C","permalink":"http://avalonlz.github.io/tags/计算机语言-C/"}]},{"title":"C语言notes","slug":"c-notes","date":"2016-01-26T07:29:03.000Z","updated":"2018-11-24T04:17:07.011Z","comments":true,"path":"2016/01/26/c-notes/","link":"","permalink":"http://avalonlz.github.io/2016/01/26/c-notes/","excerpt":"C语言中易遗忘的知识点，不定期更新。","text":"C语言中易遗忘的知识点，不定期更新。 指针数组与数组指针 指针数组：存放指针的数组，即数组内存放的都是地址。常用于将两个一维数组组成一个二维数组： 数组指针：指向一个数组的指针，即定义一个指针并且将它指向了一个相同类型的数组，该指针就叫数组指针。若要直接指向一个二维数组则需采用数组指针或数组： 给已知地址赋值int32_t *addressone=(int32_t*)0xAAAAAAAA; *addressone=99; 指向函数的指针在C语言中,函数名就是函数所在地址,跟数组名一样 const常量声明关键字 作用域随变量声明处变化，并不跟static一样放在静态存储区 const int k=10;等价于int const k=10;：k初始化后值将不可再改变 const int *k;：表示指向地址的内容不可改变 int *const k=&a;：表示k所指向的地址不可再发生改变，但是该地址的内容可以改变（初始化时必须有指向） 宏定义","categories":[],"tags":[{"name":"计算机语言_C","slug":"计算机语言-C","permalink":"http://avalonlz.github.io/tags/计算机语言-C/"}]},{"title":"Python notes","slug":"python-notes","date":"2015-10-16T04:36:39.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2015/10/16/python-notes/","link":"","permalink":"http://avalonlz.github.io/2015/10/16/python-notes/","excerpt":"Python2.7笔记","text":"Python2.7笔记 变量 id(a)可以查看a的地址 输入输出 raw_input():取得值为字符，化为整数需要用：int(raw_input) print ‘xxxxxx’(int():指可将纯数字字符串转成数字，type():可以查看变量类型) 运算符 3**2（运算结果为3^2） 5/2（2） 5.0/2（2.5） 5.0//2（2.0，整数除法，用于需要取商的整数部分，且除数或被除数中存在未知变量） 5%2（1） 成员测试:in, not in 数据类型 int: -2147483647~2147483647(超此变为long型) 213L(l)将强制定义为常整型 213.0将强制定义为浮点型 213j将强制定义为复数类型 ‘213’或”213”将强制定义为字符串 注释 单行注释：# 多行注释：’’’xxxx’’’ 索引 a = ‘acvfs’ a[2]为v，此为索引。a[1]+a[2]为’cv’(Python中加号两边都为字符类型，则会进行字符连接。若有一边为int则会异常。两边都是序列也会进行连接，两边同类型则不会异常) 切片 a[0:5]为acvfs(注意结束点要+1) a[:5]从0位置开始取到结尾 a[0:]从0位置开始取到结尾（更倾向于此种方式） 步长 a[::2] avs,此处步长为1 a[-1] s,负数反着取 a[:-1] acvf(负数最少都会丢一个尾数) a[1:-1] cvf 元组(tuple)一般用于定义不变数据 &gt;&gt;&gt; t = (&apos;lz&apos;, 23, &apos;boy&apos;) &gt;&gt;&gt; name , age, sex = t &gt;&gt;&gt; name &apos;lz&apos; &gt;&gt;&gt; age 23 &gt;&gt;&gt; sex &apos;boy&apos; &gt;&gt;&gt; 列表(list)列表操作方法： 取值操作：切片和索引列表名[] 添加：列表名.append() 删除：del(列表名)list.remove(元素)（不用特意加引号，用于删除列表中第一次出现的某元素）list.remove(列表名[xx])(用于删除列表中索引为xx的元素) 修改：列表名.[xx] = xx 查找：if 元素 in 列表名 字典 字典添加值：dir[add key] = add value 字典修改值：dir[old key] = new value 删除并返回key为’a’的元素:dict1.pop(‘a’) 删除字典所有元素：dict1.clear()#将为空字典 删除整个字典：del dict1#将无此字典类型的变量 : 一些常用函数： dir.get(‘key’,3)#有’key’对应的value则取出，若没有则返回3这一数值 dir.values():打印所有value值,组成一个list dir.keys():打印所有key值，组成一个list Python中的形参 传入元组，元组元素依次对应形参传入函数： &gt;&gt;&gt; def parmarytest(x,y,z): return x+y+z &gt;&gt;&gt; tuplenum = (1,2,3) &gt;&gt;&gt; parmarytest(*tuplenum)#传入元组时加入参数，可以使元组元素单独处理 6 &gt;&gt;&gt; listnum = [1,2,3] &gt;&gt;&gt; parmarytest(*list)#只可以使用元组，列表不行 Traceback (most recent call last): File &quot;&lt;pyshell#10&gt;&quot;, line 1, in &lt;module&gt; parmarytest(*list) TypeError: parmarytest() argument after * must be a sequence, not type &gt;&gt;&gt; 处理多余实参： &gt;&gt;&gt; def surplusparm(x,*y,**z): print x print y print z &gt;&gt;&gt; surplusparm(1,2,3,4,5,6,a = 7, b = 8, c = 9) 1 (2, 3, 4, 5, 6) {&apos;a&apos;: 7, &apos;c&apos;: 9, &apos;b&apos;: 8} &gt;&gt;&gt; surplusparm(1,2,3,4,5,6,x = 7, b = 8, c = 9) Traceback (most recent call last): File &quot;&lt;pyshell#25&gt;&quot;, line 1, in &lt;module&gt; surplusparm(1,2,3,4,5,6,x = 7, b = 8, c = 9) TypeError: surplusparm() got multiple values for keyword argument &apos;x&apos; &gt;&gt;&gt; lambda表达式 用lambda定义一个函数： g = lamdba x,y:x*y # 冒号后x*y为需要执行的内容。执行这个lamdba表达式：g(3,2) fun = lamdba : function()#用fun()即可执行function()函数 reduce函数switch实现 Python中没有switch case语句，但可以用字典和它的get方法加lamdba语句实现： def NumberToString(arg): switcher = {0:&apos;zero&apos;, 1:&apos;one&apos;, 2:&apos;two&apos;} return switcher.get(arg, &apos;none&apos;) Python常用内置函数（可查看想关函数库进行详细了解）abs()#返回绝对值 max()#返回最大值 min()#返回最小值 len()#返回字符串、列表、元组、字典的长度，字典长度按key或value个数来统计 divmod(x, y)#返回(x/y, x%y) pow(x, y)#返回x^y的值 round(x)#返回x的浮点数形式 callable(func)#测试func()函数是否可被调用，可以返回true type(x)#返回x的类型 isinstance(x, list)#判断x的类型是否是list是则true否则false cmp(x, y)#比较x和y的大小，x&lt;y返回-1，x&gt;y返回1，相等返回0 range(x, y)#生成x至y-1个数组成的list（顺序） tuple(x)#将x转换成元组 hex(x)#将十进制数x转换成十六进制数返回str类型 oct(x)#将十进制数x转换成八进制数，返回str类型 ord(x)#将一个ASCII码转换成十进制数，返回int类型 String函数str1.capitalize()#将str1字符串的第一个字符大写 str1.replace(&apos;xxx&apos;, &apos;2&apos;, 1)#从左到右将str1字符串中的&apos;xxx&apos;字符串替换为&apos;2&apos;这一字符，替换一次 str1.split(&apos;.&apos;, 1)#将str1字符串以&apos;.为界切割一次，返回一个list，list内两个元素字符串分别为分割的左右两边 序列处理函数 filter(func, list):#func为过滤规则，list为输入量，tulpe也可以进行过滤 &gt;&gt;&gt; list1 = [1,2,3,4,5,6,7] &gt;&gt;&gt; def f_fliter(x):#过滤规则，大于5的数保留 if x &gt;5: return True &gt;&gt;&gt; filter(f_fliter, list1) [6, 7] &gt;&gt;&gt; zip(list1, list2):可以遍历两个列表，组成一个对应的由元组组成的新列表 &gt;&gt;&gt; l = [2,4,5,6] &gt;&gt;&gt; li = [29,0,3] &gt;&gt;&gt; zip(li, l) [(29, 2), (0, 4), (3, 5)] &gt;&gt;&gt; zip(l,li) [(2, 29), (4, 0), (5, 3)] map(func, list1, list2):分别取两列表中的元素按func规定的方式进行处理，返回结果为一个list（list1和list2中的元素个数要相同） &gt;&gt;&gt; li1 = [1,2,3,4] &gt;&gt;&gt; li2 = [5,6,7,8] &gt;&gt;&gt; def Add(x, y): return x + y &gt;&gt;&gt; map(Add, li1, li2) [6, 8, 10, 12] &gt;&gt;&gt; li2 = [5,6,7,8,9] &gt;&gt;&gt; map(Add, li1, li2) Traceback (most recent call last): File &quot;&lt;pyshell#30&gt;&quot;, line 1, in &lt;module&gt; map(Add, li1, li2) File &quot;&lt;pyshell#27&gt;&quot;, line 2, in Add return x + y TypeError: unsupported operand type(s) for +: &apos;NoneType&apos; and &apos;int&apos; &gt;&gt;&gt; reduce(func, list):去列表中的元素按func定义的规则进行相应运算，并输出运算结果 &gt;&gt;&gt; li1 = [1,2,3,4] &gt;&gt;&gt; def func(x, y): return x + y &gt;&gt;&gt; reduce(func, li1) 10 &gt;&gt;&gt; Python模块（库） import的模块名和库名、脚本名相同：例如编写一个名为Items.py的脚本，则可在另一个脚本中使用import Items语句来导入它 __name__==’__main__’：在IDE中直接运行某py文件中的函数时等号会成立，若处于import引用的环境下则此处等号不成立 优先导入当前目录下的py文件 Python中的模块可以按目录组织为包：步骤如下：建立了一个名字为包名字的文件夹在该文件夹下创建一个__init__.py文件根据需要在该文件夹下存放脚本文件、已编译扩展及子包import pack.m1, pack.m2, pack.m3 from 文件夹名.py文件名 import .py文件中的类或函数 #from后一定要跟到.py文件，虽然导入的模块和当前编写的文件一般在同一文件夹中，但也可以用文件夹名来开头 import .py文件 #import后面跟到.py文件，在程序中具体要使用哪个类或者函数，再用.py文件名.类名/函数名，调用（一般推荐此种做法） 正则表达式浅拷贝与深拷贝 浅拷贝： &gt;&gt;&gt; a = [2,3,4] &gt;&gt;&gt; b = a#浅拷贝，可将b看做是一个a的引用（将b也放入了a的坑中），copy.copy(a)效果相同 &gt;&gt;&gt; a.append(1) &gt;&gt;&gt; a [2, 3, 4, 1] &gt;&gt;&gt; b [2, 3, 4, 1]#a增加的同时b也增加了 &gt;&gt;&gt; a = [0,6]#改变a的值，在Python中其实是将a丢入某个值中 &gt;&gt;&gt; b#所以b并未改变，b还是在a之前的那个坑中 [2, 3, 4, 1] 深拷贝： &gt;&gt;&gt; import copy &gt;&gt;&gt; a = [1,2,3] &gt;&gt;&gt; c = copy.deepcopy(a)#深拷贝，将a所在的坑重新复制了一个，并将c放入新坑中，所以c不能看做a的引用 &gt;&gt;&gt; a.append(5) &gt;&gt;&gt; a#a增加 [1, 2, 3, 5] &gt;&gt;&gt; c#c未增加 [1, 2, 3] Python文件读写mode: r：只读 r+：读写 w：写入，先删除原文件，再重新写入，如果文件没有则创建 w+：读写，先删除原文件，再重新写入，如果文件没有则创建（可以写入输出） a：写入，在文件末尾追加新的内容，文件不存在，则创建 a+：读写，在文件末尾追加新的内容，文件不存在，则创建 b：打开二进制的文件，可以与r,w,a,+结合使用 U：支持所有的换行符号 read： s = open/file(r&apos;路径&apos;) s.read() s.close() write： s = open/file(r&apos;路径&apos;，&apos;w&apos;) s.write(&apos;ssss&apos;) s.close()#一定要执行这一步才会真正写入文件 Python中的类（一般规定Python类名用大写开头，函数用小写字母开头） 类定义-&gt;类对象（class test: ,test就是一个类对象）-&gt;类实例对象：含self的方法必须要有实例对象才能被调用，不含self，且不含参数的方法可以直接被类对象调用。有self作为形参定义的方法才是实例对象可用的方法 类中属性名若和方法名相同，则属性将会覆盖方法 Python的重载只能使用def test(x, y, z=4)这种，参数默认值的方式实现重载（默认值就是python用来实现函数重载的重要方法） 私有变量的定义与访问 &gt;&gt;&gt; class test: def __init__(self): self.__test1 = 1 &gt;&gt;&gt; o = test() &gt;&gt;&gt; o._test__test1#通过此种调用可以访问到类中的私有成员变量 1 &gt;&gt;&gt; 继承：1、xxx一般是魔法方法，coding时一般不要这样定义一个属性2、子类中定义和父类同名属性或方法，此子类的实例对象会将父类方法覆盖3、子类中若定义了init方法，则会自动的将父类中的init方法覆盖掉，所以在子类的init方法中应该要包含一个父类的init方法：父类名.init(self) 或 super().init() 多重继承（慎用）：同时继承多个父类的属性和方法 访问实例对象self属性（非私有属性）：实例名.属性名 组合：在一个类中实例化其他类的对象就形成了组合 BIF：issubclass(a, b):检查a是否是b的子类，是True，否False，a,b同类也返回True。 （b不用是字符串的形式）isinstance(a, b):实例对象a是否属于b类(b也可以是类组成的元组)，是True。（b不用是字符串的形式）hasattr(a, “b”):实例对象a中是否有b这一属性，若b为私有属性，则都返回Falsegetattr(a, “b”, “no have the attribute”):实例对象a中若存在b属性，则返回该属性名，若没有则返回no have the attributesetattr(a, “b”, value):实例对象a中若存在b属性则将其值改为value，否则增加该属性值delattr(a, “b”):删除实例对象a中的b属性，若不存在则抛出异常property():通过属性来设置属性，在一个class中写：a = property(获得属性的方法名， 修改属性的方法名， 删除属性的方法名)使得我们可以通过 实例.a 这种方式去修改实例中的属性： &gt;&gt;&gt; class Student: def __init__(self): self.__name = &apos;lz&apos; def set_name(self, name): self.__name = name def display_name(self): return self.__name def delete_name(self): del self.__name a = property(display_name, set_name, delete_name) &gt;&gt;&gt; x = Student() &gt;&gt;&gt; x.a &apos;lz&apos; &gt;&gt;&gt; x.a = &apos;lizhong&apos; &gt;&gt;&gt; x.a &apos;lizhong&apos; &gt;&gt;&gt; del x.a &gt;&gt;&gt; &gt;&gt;&gt; x.a#这里是疑问点，按正常来说应该是不会存在了 &apos;lz&apos; &gt;&gt;&gt; del x.a Traceback (most recent call last): File &quot;&lt;pyshell#70&gt;&quot;, line 1, in &lt;module&gt; del x.a AttributeError: Student instance has no attribute &apos;a&apos; 魔法方法被(双下横线)包围的方法称为魔法方法常用魔法方法：1、def str(self)#使用print方法打印时会自动调用此魔法方法，但要注意return后必须为str类型2、def repr(self)#直接输入实例对象时需要返回的字符串，return后必须为str类型3、def getattribute(self, name)#当用户访问一个属性时，此方法被调用（只要有访问属性，就会调用此方法，无论访问的属性是否存在）4、def getattr(self, name)#当用户访问一个不存在的属性时，此方法被调用，name会传入用户访问的属性名5、def setattr__(self, name, value)#当一个属性被设置时，此方法被调用，类内部赋值也会触发此方法，此处name传入的是被设置的属性名，value传入的是值（可以是字符也可以是数值） class test(object): def __init__(self): self.wide = 0#此处也会调用__setattr__方法 self.height = 0 def __setattr__(self, name, value): print &apos;__setattr__ was callback&apos; if name == &apos;square&apos;: self.wide = value self.height = value else: object.__setattr__(self, name, value)#__setattr__和__getattribute__方法需要调用（返回）基类的中的此方法，防止死循环 6、def delattr(self, name)#当一个属性被删除时，此方法被调用7、def del(self)#该方法只有在del最后一个应用变量时，才会被调用 运算相关魔法方法： 闭包和装饰器闭包： 进制转换其中bin()、oct()、hex()只接收十进制数，int()需要格式为：二进制转十进制int(‘’, 2)、十六进制转十进制int(‘’, 16)、八进制转十进制int(‘’, 8)bin()、hex()后进行切片处理([2:])然后再加zfill()对数据进行补零处理，可保证数据位数","categories":[],"tags":[{"name":"计算机语言_Python","slug":"计算机语言-Python","permalink":"http://avalonlz.github.io/tags/计算机语言-Python/"}]},{"title":"Git相关","slug":"GitAbout","date":"2015-09-13T09:13:19.000Z","updated":"2018-11-24T04:10:01.000Z","comments":true,"path":"2015/09/13/GitAbout/","link":"","permalink":"http://avalonlz.github.io/2015/09/13/GitAbout/","excerpt":"Git相关记录，用到啥就记录啥，可能会略显杂乱","text":"Git相关记录，用到啥就记录啥，可能会略显杂乱由于笔者还是习惯在Linux下用命令行跟Git仓库进行交互，所以在此记录的都是命令行相关的命令（在win想用命令行可以装个Git Bash，也很方便） 基本操作1、将绑定远程主机名与仓库名绑定git remote:为了便于管理，Git要求为每个远程仓库都必须指定一个远程主机名，git remote命令就是用于管理远程主机名的，不带选项，命令将列出所有远程主机例：git remote add &lt;远程主机名&gt; &lt;远程仓库地址&gt;git remote add origin git@github.com:username/repository.gitgit remote -v//查看远程主机信息 2、查看所有分支git branch –all默认只有master分支，所以会看到如下两个分支master（本地分支）origin/master（远程主分支） 3、切换或创建本地分支git checkout &lt;本地分支名&gt;//切换本地分支 4、git checkout -b &lt;本地分支名&gt; &lt;远程主机名/远程分支名&gt;//创建本地分支并拉取远程分支的数据到此处，执行完后当前本地分支会自动切换到新创建的分支下 5、更新本地/远程分支git fetch:一旦远程主机的远程分支有了更新，将这些更新取回本地当前分支例：git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;git fetch origin master首次建仓需要git fetch origin//更新远程主机，使得系统认到远程分支，并在本地先建立一个master分支，该分支是必须存在的。 6、合并本地分支git merge:将当前分支和本地一分支合并例：git merge tem//假设当前在master分支上，则将tem与master分支合并 7、更新并合并本地分支git pull：当只需要更新分支，而不需要在新分支开发后再合并，这时候可以用git pull 8、将本地分支更新到远程分支上git push:将当前的本地分支更新到远程分支上例：git push &lt;远程主机名&gt; &lt;远程分支名&gt;git push origin master//假设当前本地分支为tem,则将tem分支更新到远程分支master上 9、克隆代码git clone:远程操作的第一步，通常是从远程主机克隆一个版本库例：git clone https://github.com/jquery/jquery.git 创建本地仓库并建立连接（一个新的项目必须走这步）1、git init//初始化git 2、git remote add origin git@github.com:……//创建远程主机 3、git fetch origin//更新远程主机 4、git merge origin/master//将远程主机的master分支更新到本地master分支(本地master分支自动创建) 至此可以在该master分支上进行开发，或者用git branch新建一个分支，并用git checkout切换到该分支上进行开发。最后可以将新分支合并到master上，再git push到远程仓库的master分支上，或者直接git push到远程仓库的新分支上 参加开源项目流程图：","categories":[],"tags":[{"name":"百科_Git","slug":"百科-Git","permalink":"http://avalonlz.github.io/tags/百科-Git/"}]}],"categories":[],"tags":[{"name":"Linux工具","slug":"Linux工具","permalink":"http://avalonlz.github.io/tags/Linux工具/"},{"name":"云计算","slug":"云计算","permalink":"http://avalonlz.github.io/tags/云计算/"},{"name":"闲书小记","slug":"闲书小记","permalink":"http://avalonlz.github.io/tags/闲书小记/"},{"name":"DPDK","slug":"DPDK","permalink":"http://avalonlz.github.io/tags/DPDK/"},{"name":"Docker","slug":"Docker","permalink":"http://avalonlz.github.io/tags/Docker/"},{"name":"百科_网络","slug":"百科-网络","permalink":"http://avalonlz.github.io/tags/百科-网络/"},{"name":"应用软件_Supervisor","slug":"应用软件-Supervisor","permalink":"http://avalonlz.github.io/tags/应用软件-Supervisor/"},{"name":"轮子_C","slug":"轮子-C","permalink":"http://avalonlz.github.io/tags/轮子-C/"},{"name":"Linux网络编程","slug":"Linux网络编程","permalink":"http://avalonlz.github.io/tags/Linux网络编程/"},{"name":"百科_Linux","slug":"百科-Linux","permalink":"http://avalonlz.github.io/tags/百科-Linux/"},{"name":"嵌入式_Linux","slug":"嵌入式-Linux","permalink":"http://avalonlz.github.io/tags/嵌入式-Linux/"},{"name":"计算机语言_Shell","slug":"计算机语言-Shell","permalink":"http://avalonlz.github.io/tags/计算机语言-Shell/"},{"name":"嵌入式_STM32","slug":"嵌入式-STM32","permalink":"http://avalonlz.github.io/tags/嵌入式-STM32/"},{"name":"软件工程_FrameWork","slug":"软件工程-FrameWork","permalink":"http://avalonlz.github.io/tags/软件工程-FrameWork/"},{"name":"Linux多进程编程","slug":"Linux多进程编程","permalink":"http://avalonlz.github.io/tags/Linux多进程编程/"},{"name":"应用软件_PyQt","slug":"应用软件-PyQt","permalink":"http://avalonlz.github.io/tags/应用软件-PyQt/"},{"name":"RTOS_UCOSII","slug":"RTOS-UCOSII","permalink":"http://avalonlz.github.io/tags/RTOS-UCOSII/"},{"name":"Linux多线程编程","slug":"Linux多线程编程","permalink":"http://avalonlz.github.io/tags/Linux多线程编程/"},{"name":"软件工程_DesignPatterns","slug":"软件工程-DesignPatterns","permalink":"http://avalonlz.github.io/tags/软件工程-DesignPatterns/"},{"name":"软件工程_UML","slug":"软件工程-UML","permalink":"http://avalonlz.github.io/tags/软件工程-UML/"},{"name":"计算机语言_Lua","slug":"计算机语言-Lua","permalink":"http://avalonlz.github.io/tags/计算机语言-Lua/"},{"name":"服务器_Django","slug":"服务器-Django","permalink":"http://avalonlz.github.io/tags/服务器-Django/"},{"name":"服务器_Tinyhttpd","slug":"服务器-Tinyhttpd","permalink":"http://avalonlz.github.io/tags/服务器-Tinyhttpd/"},{"name":"应用软件_Qt","slug":"应用软件-Qt","permalink":"http://avalonlz.github.io/tags/应用软件-Qt/"},{"name":"算法_Sort","slug":"算法-Sort","permalink":"http://avalonlz.github.io/tags/算法-Sort/"},{"name":"游戏编程","slug":"游戏编程","permalink":"http://avalonlz.github.io/tags/游戏编程/"},{"name":"飞思卡尔","slug":"飞思卡尔","permalink":"http://avalonlz.github.io/tags/飞思卡尔/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"http://avalonlz.github.io/tags/Raspberry-Pi/"},{"name":"服务器_MySQL","slug":"服务器-MySQL","permalink":"http://avalonlz.github.io/tags/服务器-MySQL/"},{"name":"嵌入式_MTK","slug":"嵌入式-MTK","permalink":"http://avalonlz.github.io/tags/嵌入式-MTK/"},{"name":"协议解析_MQTT","slug":"协议解析-MQTT","permalink":"http://avalonlz.github.io/tags/协议解析-MQTT/"},{"name":"协议解析_定位","slug":"协议解析-定位","permalink":"http://avalonlz.github.io/tags/协议解析-定位/"},{"name":"百科_存储","slug":"百科-存储","permalink":"http://avalonlz.github.io/tags/百科-存储/"},{"name":"百科_DNSpod","slug":"百科-DNSpod","permalink":"http://avalonlz.github.io/tags/百科-DNSpod/"},{"name":"百科_双系统安装","slug":"百科-双系统安装","permalink":"http://avalonlz.github.io/tags/百科-双系统安装/"},{"name":"计算机语言_C++","slug":"计算机语言-C","permalink":"http://avalonlz.github.io/tags/计算机语言-C/"},{"name":"计算机语言_C","slug":"计算机语言-C","permalink":"http://avalonlz.github.io/tags/计算机语言-C/"},{"name":"计算机语言_Python","slug":"计算机语言-Python","permalink":"http://avalonlz.github.io/tags/计算机语言-Python/"},{"name":"百科_Git","slug":"百科-Git","permalink":"http://avalonlz.github.io/tags/百科-Git/"}]}